<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<link REL="SHORTCUT ICON" href="http://www.dmitry-kazakov.de/favicon.ico">
<TITLE>Simple components for Ada</TITLE>
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<META name="keywords" content="smart pointer, garbage collection, container, unbounded array, parser, map, set, stack,
component, reusable component, storage pool, mark and release pool, list, doubly linked list, persistency, persistent storage, lock-free, FIFO,
queue, blackboard, lock-free queue, lock-free blackboard, synchronization, event, pulse event, array of events,
mutex, protected object, concurrency, tasking, parallel programming, concurrent programming, race condition, dining philosophers,
deadlock, memory management, Ada, Ada 95, Ada 2005, Ada programming">
<META name="Author" content="Dmitry Kazakov">
<META name="Description" content="Simple components for Ada">
<BODY bgcolor="#FFFFFF" link="#0000FF" vlink="#1100080">
<P align="center">
<BIG><BIG><BIG><b>SIMPLE COMPONENTS</b></BIG></BIG><br>
<EM>version 3.3</EM><BR>
by Dmitry A. Kazakov</BIG><BR>
(<A HREF="mailto:mailbox@dmitry-kazakov.de">mailbox@dmitry-kazakov.de</A>)<br>
<a href="http://www.dmitry-kazakov.de"><img border="0" src="home.jpg" alt="[Home]" width="40" height="40"></a></p>
<P>
This library is free software; you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later 
version. This library is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
FITNESS FOR A PARTICULAR PURPOSE. See the
<a href="http://www.gnu.org/licenses/gpl.html">GNU General Public License</a> 
for more details. You should have received a copy of the GNU General Public 
License along with this library; if not, write to the Free Software Foundation, 
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</P>
<P>
As a special exception, if other files instantiate generics from this unit, or 
you link this unit with other files to produce an executable, this unit does not 
by itself cause the resulting executable to be covered by the GNU General Public 
License. This exception does not however invalidate any other reasons why the 
executable file might be covered by the GNU Public License.</P>
Download <a href="http://www.dmitry-kazakov.de/ada/components_3_3.tgz">components_3_3.tgz</a> (<b>tar</b> + <b>gzip</b>, Windows users may use WinZip) <a href="http://www.dmitry-kazakov.de/ada/components_3_3.tgz">
<img src="download.jpg" align=middle alt="[Download]" width="29" height="29"></a><HR>
<P align="left">
The current version provides implementations of smart pointers, sets, maps, 
stacks, 
tables, string editing, unbounded arrays, expression analyzers, lock-free data 
structures, synchronization primitives (events, race condition free pulse 
events, arrays of events, reentrant mutexes, deadlock-free arrays of mutexes), pseudo-random 
non-repeating numbers, symmetric encoding and decoding, IEEE 754 representations 
support. It grew out of needs and does not pretend to be universal.
Tables management and strings editing are described in separate documents see <a href="tables.htm">Tables</a> 
and <a href="strings_edit.htm">Strings edit</a>. The library is kept conform to 
both <a href="http://www.adaic.com/standards/95lrm/html/RM-TTL.html">Ada 95</a> 
and <a href="http://www.adaic.com/standards/05rm/html/RM-TTL.html">Ada 2005</a> 
language standards.</p>
<P align="left">
<u><b>Quick reference</b></u></p>
<blockquote>
<P align="left">
<a href="#Cryptography">Cryptography</a><br>
<a href="#Generic_Blackboard">Blackboards</a> (lock-free)<br>
<a href="#Generic_Doubly_Linked_Web">Doubly-linked webs and lists</a><br>
<a href="#Events">Events</a> (plain, pulse, array of)<br>
<a href="#Generic_FIFO">FIFO</a> (lock-free)<br>
<a href="#IEEE_754">IEEE 754</a><br>
<a href="#Mutexes">Mutexes</a><br>
<a href="#Objects_etc">Objects and handles to<br>
</a>
<a href="#Parsers_etc">Parsers</a><br>
<a href="#persistent_objects">Persistent objects</a> and <a href="#persistent_object_handles">handles
to</a><br>
<a href="#persistent_storage">Persistent storage</a> and <a href="#persistent_storage_handle">handles
to</a><br>
<a href="#Pools_etc">Pools</a><br>
<a href="#Sets_etc">Sets and maps</a><br>
<a href="#Stacks_etc">Stacks</a><br>
<a href="strings_edit.htm">Strings editing</a><br>
<a href="tables.htm">Tables</a> (maps of strings)<br>
<a href="#Unbounded_arrays_etc">Unbounded arrays</a></p>
</blockquote>
<P align="left">
See also <a href="#changes_log">changes log</a>.</p>
<P align="right">
<A name="1"></A><A href="#16"><IMG src="index.gif" alt="[TOC]" width="29"
    height="29"></A><A href="#1.1"><IMG src="next.gif" alt="[Next]" width="29"
    height="29"></A></p>
<H2>1. Objects and handles (smart pointers)</H2>
<p><a name="Objects_etc"></a>The objects and handles are designed to provide automatic garbage
collection. The objects are created explicitly, but never explicitly destroyed. An
application program usually should not directly access objects, using object 
handles (smart pointers) instead. As long as at least one handle to an object 
exists the object will not be destroyed. When the last handle disappears the 
object is automatically destroyed. The presented implementation is oriented on 
large and rather complex objects. Usually it has little sense to have pointers 
to small objects, having no identity. For such objects by-value semantics is often safer, easier to understand and more efficient. For this
reason an object-oriented approach was chosen. The object type is
considered a descendant of a limited controlled type which can be extended as
necessary. Same handle type can be used for the whole class of descendant types.
The proxy operations can be defined on handles which implementations may
dispatch according to the actual type of the pointed object.
</p>
<p>A specialization of objects is provided to support object's <a href="#object_persistence">persistence</a>.
Such objects can be stored in an external persistent storage and then restored
from there. The persistent storage interface itself is an object. This allows
implementation of object serving as proxies of external objects permanently
resident in an external storage.
</p>
<p align="right">
  <A name="1.1"></A><A href="#1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#1.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>1.1. Objects</H3>
<p><a name="Entity"></a><a name="Object"></a>The package <a href="#Object"> Object</a> provides the
base type <a href="#Entity"> Entity</a> for all objects:
</p>
<blockquote>
<p>
<tt><font color="#0000FF">type </font>Entity<font color="#0000FF"> is new</font><br>
&nbsp;&nbsp;&nbsp;Ada.Finalization.Limited_Controlled<font color="#0000FF"> with</font><br>
<font color="#0000FF">record</font><br>
&nbsp;&nbsp;&nbsp;Use_Count : Natural := <font color="#1100000">0</font>;<br>
<font color="#0000FF">end record</font>;<br>
<font color="#0000FF">type</font> Entity_Ptr <font color="#0000FF"> is access all
</font>Entity'Class;</tt></p>
</blockquote>
<p>It is a limited controlled type. The following operations are defined on it:</p>
<blockquote>
<p><tt>
<font color="#0000FF"><a name="Object.Equal"></a>function</font>&nbsp;Equal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Left</b>&nbsp;&nbsp;:&nbsp;Entity;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Right</b>&nbsp;:&nbsp;Entity'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Flag</b>&nbsp;&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean;<br>
<font color="#0000FF"><a name="Object.Less"></a>function</font>&nbsp;Less<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Left</b>&nbsp;&nbsp;:&nbsp;Entity;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Right</b>&nbsp;:&nbsp;Entity'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Flag</b>&nbsp;&nbsp;:&nbsp;Boolean&nbsp;:=&nbsp;False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font>&nbsp;Boolean;
</tt></p>
</blockquote>
<p>These functions are used to compare objects. The meaning of comparison is
usually defined by the nature of the objects. However the main reason why
comparison is defined, is to support ordered sets of objects, so any order is
suitable. Thus the implementations of Equal and Less use storage addresses to
get <a href="#Entity">Entity</a> objects ordered. They should be overridden if a
more meaningful order of objects exists. Note that Ada does
not fully support multiple dispatch. Therefore the operations are declared
asymmetric. The second parameter is class-wide. If the operation is overridden,
an implementation should dispatch on the second parameter to emulate true
multiple dispatch. The parameter <b>Flag</b> indicates whether the function is
called recursively. The following code fragment illustrates how to do it:</p>
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#B8D3D1"><tt>
<font color="#0000FF">function</font> Less<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;Left&nbsp;&nbsp;: A_New_Object_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;: Object.Entity'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag&nbsp;&nbsp;: Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean
<font color="#0000FF"> is</font><br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font> (&nbsp; Flag<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">or else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;<font color="#0000FF">not</font>&nbsp;<font color="#0000FF">in</font>&nbsp;A_New_Object_Type'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">or else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right <font color="#0000FF">in</font> A_New_Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">-- Implement it here</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">-- Dispatch on the second parameter</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">not</font>&nbsp;(&nbsp;&nbsp;Less (Right, Left, True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">or else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equal (Right, Left, True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">end if</font>;<br>
<font color="#0000FF">end</font> Less;</tt></TD>
  </TR>
</TABLE>
<p>The idea is that a given overriding is responsible for implementation of <a href="#Object.Less">Less</a>
if and only if <b>Left :&gt; Right</b>, i.e. when <b>Left</b> is in the class of
<b>Right</b>. The dispatching mechanism warranties that <b>Left</b> is in the
type class, so if <b>Right</b> is of the same type or else does not belong to the
type class, then <b>Left :&gt; Right</b>. Otherwise, <b>Right</b> is used to
re-dispatch and <b>Flag</b> is set to indicate that no more dispatch may happen.
Observe, that if <b>Left</b> and <b>Right</b> are siblings and therefore neither
of <b>Left :&gt; Right</b>
 and <b>Left &lt;: Right</b> is true, then <b>Flag</b> will stop the recursion.
The if the
implementation cast <b>Right</b> down to a known type, as it usually would
do in other cases, then, in the case of siblings, that would cause propagation
of Constraint_Error out of <a href="#Object.Less">Less</a> or <a href="#Object.Equal">Equal</a>.
If this behavior is undesirable, then another way to deal with comparison of siblings is to find the most specific common ancestor of both.
In that case the
code of <a href="#Object.Less">Less</a> might look as follows:
  </p>
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#B8D3D1"><tt>
<font color="#0000FF">function</font> Less<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;Left&nbsp;&nbsp;:
  A_New_Object_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;:
  Object.Entity'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag&nbsp;&nbsp;: Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean
<font color="#0000FF"> is</font><br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">if</font>  (&nbsp; Right&nbsp;<font color="#0000FF">not</font>&nbsp;<font color="#0000FF">in</font>&nbsp;A_New_Object_Type'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">or else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right <font color="#0000FF">in</font> A_New_Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">-- Implement it here</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">elsif</font> Flag <font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">-- Using Less of the most
specific common ancestor,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- for example, the predefined Less:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#0000FF">return</font>&nbsp;Object.Less&nbsp;(Object.Entity&nbsp;(Left),&nbsp;Right,&nbsp;True);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">-- Dispatch on the second parameter</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">not</font>&nbsp;(&nbsp;&nbsp;Less (Right, Left, True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">or else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equal (Right, Left, True)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">end if</font>;<br>
<font color="#0000FF">end</font> Less;</tt></TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Finalize
  (<b>This</b> : <font color="#0000FF"> in out</font> Entity);</tt></p>
</blockquote>
<p>The destructor raises Program_Error if the destroyed object is still in use. Note
that a derived type shall call the destructor of the base if it overrides
Finalize.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Release (<b>Ptr</b> :
  <font color="#0000FF">in out </font>Entity_Ptr);</tt></p>
</blockquote>
<p>The object pointed by <b>Ptr</b> is deleted if its use count in 1. Otherwise 
the use count is decremented. <b>Ptr</b> becomes <font color="#0000FF">null</font> if the object it points 
to is 
deleted. The procedure does nothing if <b>Ptr</b> is already 
<font color="#0000FF">null</font>. It can be 
used for implementation of the smart pointers to Entity and its descendants.</p>
<p align="right">
  <A name="1.2"></A><A href="#1.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#1.3"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>1.2. Handles to objects</H3>
<p><a name="Handle"></a><a name="Object.Handle"></a>The generic child package <a href="#Object.Handle"> Object.Handle</a> defines the type
<a href="#Handle">Handle</a> used to access objects of a given type:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font> Object_Type (&lt;&gt;)<font color="#0000FF"> is abstract new </font>Entity <font color="#0000FF">with private</font>;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font> Object_Type_Ptr <font color="#0000FF">
is access </font> Object_Type'Class;<br>
<font color="#0000FF">package</font> Object.Handle <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font> Handle <font color="#0000FF">is 
new </font>Ada.Finalization.Controlled<font color="#0000FF"> with private</font>;</tt></p>
</blockquote>
<p>The package
has two generic parameters:</p>
<ul>
  <li><a name="Object.Handle.Object_Type"></a>Object_Type is a type derived from <a href="#Entity">Entity</a>.</li>
  <li><a name="Object.Handle.Object_Type_Ptr"></a>Object_Type_Ptr is an access type to class-wide objects of Object_Type.</li>
</ul>
<p><a name="operations_on_Handle"></a>Handles can be assigned to copy a
reference to the object. If a handle object is not initialized it is invalid. An
invalid handle cannot be used to access objects, but it can be used in some comparisons,
it can be copied and assigned. The constant Null_Handle
defined in the package is a predefined invalid handle. The following operations
are defined on a <a href="#Handle">Handle</a>:</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Finalize
  (<b>Reference</b> : <font color="#0000FF"> in out</font> Handle);</tt></p>
</blockquote>
<p>The destructor destroys the referenced object (if any) in case when the
handle was the last one pointing the object.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Object.Handle.Invalidate"></a>procedure</font> Invalidate
(<b>Reference</b> : <font color="#0000FF"> in out</font> Handle);</tt></p>
</blockquote>
<p>This procedure detaches handle from the object (if any) it points to. The
result handle cannot be used to access any object. The referenced object is
destroyed if it was the last handle.</p>
<blockquote>
<p><tt>
<font COLOR="#0000ff">function </font>Is_Valid (<b>Reference</b> : Handle) <font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
This function checks whether a handle points to an object.
<blockquote>
<p><tt>
<font COLOR="#0000ff"><a name="Object.Handle.Ptr"></a>function </font>Ptr (<b>Reference</b> : Handle) <font color="#0000FF"> return</font> Object_Type_Ptr;</tt></p>
</blockquote>
This function is used to get a pointer to the object the handle points to.

The pointer of to the
object shall be used no longer the handle it was get from exists. A safe way to
do it is to avoid declarations of any variables of the type Object_Type_Ptr.
<blockquote>
<p>
<tt><font COLOR="#0000ff"><a name="Object.Handle.Ref"></a>function </font> Ref (<b>Thing</b> : Object_Type_Ptr)
<font color="#0000FF"> return</font> Handle;</tt>
</p>
</blockquote>
<P>This function is used to get a handle from a pointer to an object.</p>
<blockquote>
<p>
<tt><font COLOR="#0000ff">procedure</font> Set (<b>Reference</b> :
<font COLOR="#0000ff">in out</font> Handle; <b>Thing</b> : Object_Type_Ptr);</tt></p>
</blockquote>
<P>This procedure resets the handle <b>Reference</b> to a possibly another 
object. In the course of this operation the previously pointed object may be 
destroyed if <b>Reference</b> was the last handle pointing to it. It is safe 
when <b>Thing</b> is the object Reference already points to. When <b>Thing</b> 
is null, this procedure is equivalent to <a href="#Object.Handle.Invalidate">
Invalidate</a>. </p>
<blockquote>
<p><tt><font color="#0000FF">function</font> "<font color="#FF0000">&lt;</font>"&nbsp;(<b>Left</b>, <b> Right</b> : Handle) <font color="#0000FF"> return</font> Boolean;<br>
<font color="#0000FF">function</font> "<font color="#FF0000">&lt;=</font>&quot;(<b>Left</b>, <b> Right</b> : Handle) <font color="#0000FF"> return</font> Boolean;<br>
<font color="#0000FF">function</font> &quot;<font color="#FF0000">&gt;=</font>&quot;(<b>Left</b>, <b> Right</b> : Handle) <font color="#0000FF"> return</font> Boolean;<br>
<font color="#0000FF">function</font> &quot;<font color="#FF0000">&gt;</font>&quot;&nbsp;(<b>Left</b>, <b> Right</b> : Handle) <font color="#0000FF"> return</font> Boolean;<br>
<font color="#0000FF">function</font> &quot;<font color="#FF0000">=</font>&quot;&nbsp;(<b>Left</b>, <b> Right</b> : Handle) <font color="#0000FF"> return</font> Boolean;<br>
<font color="#0000FF">function</font> &quot;<font color="#FF0000">=</font>&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Left</b>&nbsp; : Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Right</b> : <font color="#0000FF"> access
</font>Object_Type'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp; <font color="#0000FF">return</font> Boolean;<br>
<font color="#0000FF">function</font> &quot;<font color="#FF0000">=</font>&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Left </b>&nbsp;: <font color="#0000FF"> access</font> Object_Type'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Right</b> : Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp; <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<P>Valid handles are comparable. The result of comparison is one of the objects
they point to. Implementations of the comparisons use Less and Equal defined on
Object_Type. If one of arguments is invalid Contraint_Error is propagated for
all functions except &quot;<font color="#FF0000">=</font>&quot;. For equality
(and thus inequality) it is legal to compare with an invalid handle. The
result of such comparison is true if and only if both handles are invalid. One
of parameters in equality is allowed to be a pointer to an object.</p>
<p align="right">
  <A name="1.3"></A><A href="#1.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#1.4"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3><a name="1.1.3"></a>1.3. An example of use</H3>
<p>The usage of objects and handles is
illustrated by the following simplified example of an implementation of dynamic
strings:&nbsp;
</p>
<a name="test_my_string.ads"></a>
File <EM>test_my_string.ads</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> Object;<br><br>
<FONT color="#0000FF">package </font>Test_My_String <FONT color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;<FONT color="#0000FF">type</FONT> My_String (Length : Natural) <FONT color="#0000FF"> is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new</FONT> Object.Entity<FONT  color="#0000FF"> with record</FONT><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value : String (1..Length);<br>
&nbsp;&nbsp;&nbsp;<FONT color="#0000FF">end record</FONT>;<br>
&nbsp;&nbsp;&nbsp;<FONT  color="#0000FF">type</FONT>&nbsp;My_String_Ptr&nbsp;<FONT color="#0000FF">is</FONT>&nbsp;<FONT color="#0000FF">access</FONT>&nbsp;My_String'Class;<br>
<FONT color="#0000FF">end</font>  Test_My_String;</tt></TD>
  </TR>
</TABLE>
<P>
 An instance of My_String keeps the string body. But a user should rather use
 handles to My_String, provided by the child package:</P>
<a name="test_my_string.handle.ads"></a>
File <EM>test_my_string-handle.ads</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> Object.Handle;<br><br>
<font color="#0000FF">package</font>  Test_My_String.Handle <font color="#0000FF">is</font><br>
<font color="#008000">--<br>
-- Though an instantiation of Object.Handle provides handles to<br>
-- My_String, we would like to have some additional operations on<br>
-- handles.<br>
--</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">package</font> My_String_Handle <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">new</font> Object.Handle (My_String, My_String_Ptr);<br>
<font color="#008000">--<br>
-- So we immediately derive from the obtained type. Note that no<br>
-- additional components needed (with null record).&nbsp;<br>
--</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font> My_Safe_String <font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new</font> My_String_Handle.Handle <font color="#0000FF">with null record</font>;<br>
<font color="#008000">--<br>
-- Now define useful operations on string handles:<br>
--</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font> Create (Value : String) <font color="#0000FF">return</font> My_Safe_String;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font> Value (Reference : My_Safe_String) <font color="#0000FF">return</font> String;<br>
<font color="#008000">--<br>
--</font>&nbsp;<font color="#008000">Note</font>&nbsp;<font color="#008000">that</font>&nbsp;<font color="#008000">Copy</font>&nbsp;<font color="#008000">takes</font>&nbsp;<font color="#008000">handle</font>&nbsp;<font color="#008000">as</font>&nbsp;<font color="#008000">an</font>&nbsp;<font color="#008000">inout-parameter.</font>&nbsp;<font color="#008000">It</font>&nbsp;<font color="#008000">does</font>&nbsp;<font color="#008000">not</font>&nbsp;<font color="#008000">touch<br>
-- the old object it just creates a new one and sets handle to point to<br>
-- it. The old object is automatically destroyed if no more referenced.&nbsp;<br>
--</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">procedure</font> Copy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;Reference : <font color="#0000FF">in out</font> My_Safe_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Value : String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">procedure</font> Copy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;Reference : <font color="#0000FF">in out</font> My_Safe_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Value : My_Safe_String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
<font color="#0000FF">private</font><br>
<font color="#008000">--<br>
-- Note that Ref shall be overridden. This is a language requirement,<br>
-- which ensures that the results are covariant. We make it private<br>
-- because there is no need for a user to access it.<br>
--</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font> Ref (Pointer : 
My_String_Ptr)&nbsp;<font color="#0000FF">return</font> My_Safe_String;<br>
<br>
<font color="#0000FF">end</font>  Test_My_String.Handle;</tt></TD>
  </TR>
</TABLE>
<P>This package defines the type My_Safe_String which can be used with less care
about memory allocation and deallocation. A handle can be copied using the standard
assignment. A new string object can be created from a string. The value it
points to can be accessed using the function Value, etc. It is a good practice
to provide Create returning a handle instead of a direct use of Ref on an
existing object, because it prevents referring stack-allocated objects which
could get out of scope before handles to them. <a href="#Object"> Object</a>.Finalize would notice
that and raise Program_Error. An implementation of My_Safe_String might
look like follows.</P>
File <EM>test_my_string-handle.adb</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">package body</font> 
  Test_My_String.Handle<font color="#0000FF"> is</font><br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font> Create (Value : String) <font color="#0000FF">return</font> My_Safe_String <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ptr : My_String_Ptr := <font color="#0000FF"> new</font> My_String (Value'Length);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ptr.Value := Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Ref (Ptr);<br>
<font color="#0000FF">&nbsp;&nbsp;&nbsp;end</font> Create;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font> Value (Reference : My_Safe_String) <font color="#0000FF">return</font>  String <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Ptr (Reference).Value;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">end</font> Value;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">procedure</font> Copy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;Reference : <font color="#0000FF">in out</font> My_Safe_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Value : String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;
<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reference := Create (New_Value);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">end</font> Copy;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">procedure</font> Copy<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;Reference : <font color="#0000FF">in out</font> 
My_Safe_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New_Value : My_Safe_String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;
<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reference := Create (Value (New_Value));<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">end</font> Copy;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font>&nbsp;Ref&nbsp;(Pointer&nbsp;:&nbsp;My_String_Ptr)&nbsp;<font color="#0000FF">return</font>&nbsp;My_Safe_String&nbsp;<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> (My_String_Handle.Ref (Pointer) <font color="#0000FF"> with null
record</font>);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">end</font> Ref;<br>
<br>
<font color="#0000FF">end</font>   Test_My_String.Handle;</tt></TD>
  </TR>
</TABLE>
<p align="right">
  <A name="1.4"></A><A href="#1.3"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#1.5"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>1.4. Bounded arrays of objects</H3>
<p align="left"><a name="Bounded_Array"></a><a name="Object.Handle.Generic_Bounded_Array"></a>The package
<a href="#Object.Handle.Generic_Bounded_Array">Object.Handle.Generic_Bounded_Array</a> defines the type
<a href="#Bounded_Array">Bounded_Array</a>. An instance of
<a href="#Bounded_Array">Bounded_Array</a> is  a  fixed size array of references to 
<a href="#Object">objects</a>. It is same as an array of <a href="#Handle">
handles</a> to <a href="#Object">objects</a> but more efficient.</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  </font>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Index_Type<font color="#0000FF"> is
  </font>
 (&lt;&gt;);<font color="#0000FF"><br>
&nbsp;&nbsp; type
  </font>
  Handle_Type <font color="#0000FF">is new</font> Handle <font color="#0000FF">
  with private</font>;<font color="#0000FF"><br>
  package
  </font>
  Object.Handle.Generic_Bounded_Array<font color="#0000FF"> is
  </font>
  ...</tt></p>
</blockquote>
<p>Here Index_Type is the type used to index the array elements. Handle_Type is
any descendant of Handle including itself. The type
<a href="#Bounded_Array">Bounded_Array</a> is defined in the package as:</p>
<blockquote>
<tt><font color="#0000FF">type
  </font>
 Bounded_Array (First, Last : Index_Type)<font color="#0000FF"> is<br>
&nbsp;&nbsp; new
  </font>
 Ada.Finalization.Controlled <font color="#0000FF">with private</font>;</tt>
</blockquote>
<p>The discriminants <b>First</b> and <b>Last</b> define the index range. The following operations are defined on
<a href="#Bounded_Array">Bounded_Array</a>:</p>
<blockquote>
<tt><font color="#0000FF">procedure</font>
  Adjust
  (<b>Container</b> : <font color="#0000FF"> in out </font>Bounded_Array);</tt></blockquote>
<p>The assignment makes a copy of the array.</p>
<blockquote>
<tt>
<font color="#0000FF">function</font> Append<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Element</b>&nbsp;&nbsp; 
: Object_Type_Ptr := <font color="#0000FF">null</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Count</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: Natural&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :=
<font color="#1100000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Bounded_Array;<br>
<font color="#0000FF">function</font> Append<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Element</b>&nbsp;&nbsp; 
: Handle_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Count</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: Natural := <font color="#1100000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Bounded_Array;</tt>
</blockquote>
<p>These functions add <b>Element</b> <b>Count</b> times to the end of <b>
Container</b>. The result will have the lower bound <b>Container</b>.First. 
Constraint_Error is propagated when the upper bound cannot be represented in 
Index_Type.</p>
<blockquote>
<tt>
<font color="#0000FF">function</font> Delete<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>From</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Count</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: Natural := <font color="#1100000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Bounded_Array;</tt></blockquote>
<p>This function deletes <b>Count</b> elements from <b>Container</b> starting 
with the element <b>From</b>. When <b>Count</b> exceeds the number of elements 
in the array, the available elements are removed. The lower bound of the result 
is <b>Container</b>.First, except the case when all elements are removed. For an 
empty result, the lower bound is Index_Type'Succ (Index_Type'First). 
Constraint_Error is propagated when the result should be empty, but Index_Type 
has less than two values. It is also propagated when <b>From</b> is not in <b>
Container</b>.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Finalize
  (<b>Container</b> : <font color="#0000FF"> in out </font>Bounded_Array);</tt></blockquote>
<p>The destructor may delete some objects referenced by the array.</p>
<blockquote>
<tt>
<font color="#0000FF">procedure</font>&nbsp;Fill<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> 
: <font color="#0000FF">in out</font> Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>From</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>To</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Element</b>&nbsp;&nbsp;
: Object_Type_Ptr := <font color="#0000FF">null</font><br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
<font color="#0000FF">procedure</font>&nbsp;Fill<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b>&nbsp;:&nbsp;<font color="#0000FF">in out</font> Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>From</b>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;:&nbsp;Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>To</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Element</b>&nbsp;&nbsp;&nbsp;:&nbsp;Handle_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</tt>
</blockquote>
<p>These procedures are used to put in / replace a range of array elements. The
range <b>From</b>..<b>To</b> is filled with <b>Element</b>. Nothing happens if
<b>From</b> &gt; <b>To</b>. Otherwise Constraint_Error is propagated when <b>From</b>..<b>To
</b>is not in <b>Container</b>.First..<b>Constainer</b>.Last.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> Object_Type_Ptr;</tt></blockquote>
<p>This function returns either a pointer to an object or <font color="#0000FF">null</font>.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>From</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>To</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Bounded_Array;</tt></blockquote>
<p>This function returns a slice of <b>Container</b>. The lower index of the 
slice is <b>From</b>, the upper index is <b>To</b>. Constraint_Error is 
propagated when <b>From</b>..<b>To</b> is not empty and does not belong to the 
range <b>First</b>..<b>Last</b> of <b>Container</b>. </p>
<blockquote>
<tt>
<font color="#0000FF">function</font> Prepend<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Element</b>&nbsp;&nbsp; 
: Object_Type_Ptr := <font color="#0000FF">null</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Count</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: Natural&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :=
<font color="#1100000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Bounded_Array;<br>
<font color="#0000FF">function</font> Prepend<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Element</b>&nbsp;&nbsp; 
: Handle_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Count</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: Natural := <font color="#1100000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Bounded_Array;</tt>
</blockquote>
<p>These functions add <b>Element</b> <b>Count</b> times in front of <b>
Container</b>. The result will have the upper bound <b>Container</b>.Last. 
Constraint_Error is propagated when the upper bound cannot be represented in 
Index_Type.</p>
<blockquote>
<tt><font color="#0000FF">   procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;             (
&nbsp;<b>Container</b> : <font color="#0000FF"> in out </font>Bounded_Array;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Index</b>
&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Element</b>
&nbsp;   : Object_Type_Ptr<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;             );<br>
  <font color="#0000FF">   procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;             (
&nbsp;<b>Container</b> : <font color="#0000FF"> in out </font>Bounded_Array;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Index</b>
&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Element</b>
&nbsp;   : Handle_Type<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;             );</tt></blockquote>
<p>These procedures are used to put in / replace an array element using its index.
Constraint_Error is propagated when <b>Index</b> is illegal.</p>
<blockquote>
<tt>
  <font color="#0000FF">   procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;             (
&nbsp;<b>Container</b> : <font color="#0000FF"> in out </font>Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>From</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>To</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Elements</b>&nbsp; : Bounded_Array<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;             );</tt></blockquote>
<p>This procedures replaces the slice <b>From</b>..<b>To</b> of <b>Container</b> 
with <b>Elements</b>. <b>Container</b> and <b>Elements</b> can be the same 
object. Else if <b>Elements</b> is shorter than the slice, the rightmost 
elements of the slice are replaced with invalid handles. When <b>Elements</b> is 
longer, then its rightmost elements are ignored. The operation is void when <b>
From</b>..<b>To</b> is empty. Constraint_Error is propagated when <b>From</b>..<b>To</b> 
is not empty and does not belong to the range <b>First</b>..<b>Last</b> of <b>
Container</b>.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Ref<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> : 
Bounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> 
Handle_Type;</tt></blockquote>
This function returns a valid handle to an object. Otherwise Constraint_Error
is propagated.<blockquote>
<tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">&amp;</font>&quot; (<b>Left</b>,
<b>Right</b> : Bounded_Array) <font color="#0000FF">return</font> Bounded_Array;</tt></blockquote>
<p>This function returns a concatenation of two arrays. If <b>Right</b> is 
empty, the result <b>Left</b>, else if <b>Left</b> is empty, the result is <b>
Right</b>. Otherwise, the lower bound of the result is Index_Type'First.</p><blockquote>
<tt>Empty : <font color="#0000FF">constant</font> Bounded_Array;</tt></blockquote>
<p>Empty array constant.</p>
<p align="right">
  <A name="1.5"></A><A href="#1.4"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#1.6"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>1.5. Unbounded arrays of objects</H3>
<p><a name="Object.Handle.Generic_Unbounded_Array"></a>The package
<a href="#Object.Handle.Generic_Unbounded_Array">Object.Handle.Generic_Unbounded_Array</a> defines the type
<a href="#Object.Handle.Generic_Unbounded_Array">Unbounded_Array</a>. An instance of
<a href="#Object.Handle.Generic_Unbounded_Array">Unbounded_Array</a> is  an unbounded array of references to 
<a href="#Object">objects</a>. The package has same functionality as an 
instance of <a href="#Generic_Unbounded_Array">Generic_Unbounded_Array</a> 
with <a href="#Handle">Handle</a> as Object_Type, but it is more efficient.</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  </font>
<font COLOR="#000000">
&nbsp;&nbsp;&nbsp;</font><font color="#0000FF">type
  </font>
 Index_Type<font color="#0000FF"> is
  </font>
 (&lt;&gt;);<font color="#0000FF"><br>
  &nbsp;&nbsp; type
  </font>
  Handle_Type <font color="#0000FF">is new</font> Handle <font color="#0000FF">
  with private</font>;<br>
&nbsp;&nbsp;&nbsp;Minimal_Size&nbsp;: Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp;&nbsp;Increment&nbsp;&nbsp;&nbsp;&nbsp;: Natural&nbsp; := <font color="#1100000">50</font>;<br>
  <font color="#0000FF">package
  </font>
  Object.Handle.Generic_Unbounded_Array<font color="#0000FF"> is
  </font>
  ...</tt></p>
</blockquote>
<p>Here:
</p>
<ul>
  <li>Index_Type is the type used to index the array elements;</li>
  <li>Handle_Type is the type of handles to the elements. It is any descendant 
  of Handle or the Handle itself;</li>
  <li>Minimal_Size is the minimal number of elements by which the array vector is enlarged. When the first
    element is put into the array, this will
    be the initial vector size.</li>
  <li>Increment controls further vector enlargements. The vector is enlarged by <i>n</i>*Increment/100,
    where <i> n</i> is the current vector size. If the evaluated increment of 
  the vector size is less than Minimal_Size
    elements, then the latter is used instead.</li>
</ul>
<p>The type is declared as:</p>
<blockquote>
<p><tt><font color="#0000FF">type
  </font>
 Unbounded_Array <font color="#0000FF"> is new
  </font>
 Ada.Finalization.Controlled <font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The following operations are defined on
<a href="#Object.Handle.Generic_Unbounded_Array">Unbounded_Array</a>:</p>
<blockquote>
<tt><font color="#0000FF">procedure</font>
  Adjust
  (<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array);</tt></blockquote>
The assignment does not make a copy of the array. It just increments an
internal use count. The array will be copied only when a destructive operation 
is applied.<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Erase
  (<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array);</tt></p>
</blockquote>
<p>This procedure removes all elements from <b>Container</b> making it empty. The objects referenced only 
by <b>Container </b>will be deleted.</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Finalize
  (<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array);</tt></p>
</blockquote>
<p>The destructor may delete some objects referenced by the array.</p>
<blockquote>
<tt><font color="#0000FF">function</font> First<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> : 
Unbounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> 
Index_Type;</tt></blockquote>
<p>This function returns the current lower bound of the array. Constraint_Error
is propagated when the array is empty.</p><blockquote>
<tt><font color="#0000FF">function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> : 
Unbounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> Object_Type_Ptr;</tt></blockquote>
<p>This function returns either a pointer to an object or <font color="#0000FF">null</font>.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Last<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> : 
Unbounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> 
Index_Type;</tt></blockquote>
<p>This function returns the current upper bound of the array. Constraint_Error
is propagated when the array is empty.</p>
<blockquote>
<tt><font color="#0000FF">   procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;             (
&nbsp;<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Index</b>
&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Element</b>
&nbsp;   : Object_Type_Ptr<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;             );<br>
  <font color="#0000FF">   procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;             (
&nbsp;<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Index</b>
&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Element</b>
&nbsp;   : Handle_Type<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;             );</tt></blockquote>
<p>These procedures are used to put in / replace an array element using its index.
The array is automatically expanded as necessary. It never happens if <b>Element</b> 
is <font color="#0000FF">null</font> or an invalid handle.</p><blockquote>
<tt><font color="#0000FF">function</font> Ref<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> : 
Unbounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font>
Handle_Type;</tt></blockquote>
This function returns a valid handle to an object. Otherwise Constraint_Error
is propagated.<p align="right">
  <a href="#1.4" name="1.6"></a><a href="#1.5"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#1.7"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>1.6. Unbounded sets of objects</H3>
<p><a name="Object.Handle.Generic_Set"></a><a name="Object.Handle.Generic_Set.Set"></a>
The package
<a href="#Object.Handle.Generic_Set">Object.Handle.Generic_Set</a> defines the type
<a href="#Object.Handle.Generic_Set.Set">Set</a>. An instance of
<a href="#Object.Handle.Generic_Set">Generic_Set</a> is  a set of references to 
<a href="#Object">objects</a>. The package has same functionality as an 
instance of <a href="#Generic_Set">Generic_Set</a> 
with <a href="#Handle">Handle</a> as Object_Type, but it is more efficient. It 
has the following generic parameters:</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  </font>
&nbsp;&nbsp;&nbsp;Minimal_Size&nbsp;: Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp;&nbsp;Increment&nbsp;&nbsp;&nbsp;&nbsp;: Natural&nbsp; := <font color="#1100000">50</font>;<br>
  <font color="#0000FF">package
  </font>
  Object.Handle.Generic_Set<font color="#0000FF"> is
  </font>
  ...</tt></p>
</blockquote>
<p>Here:
</p>
<ul>
  <li>Minimal_Size is the minimal number of elements by which set is enlarged. When the first
    element is put into the array, this will
    be the initial vector size.</li>
  <li>Increment controls further vector enlargements. The vector is enlarged by <i>n</i>*Increment/100,
    where <i> n</i> is the current vector size. If the evaluated increment of 
  the vector size is less than Minimal_Size
    elements, then the latter is used instead.</li>
</ul>
<p>The type
<a href="#Object.Handle.Generic_Set.Set">Set</a> is declared as:</p>
<blockquote>
<p><tt><font color="#0000FF">type
  </font>
 Set <font color="#0000FF"> is new
  </font>
 Ada.Finalization.Controlled <font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The following operations are defined on
<a href="#Object.Handle.Generic_Set.Set">Set</a>:</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out
</font> Set; <b> Item</b>&nbsp; : Handle);<font color="#0000FF"><br>
procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out
</font> Set; <b> Item</b>&nbsp; : Object_Type_Ptr);<font color="#0000FF"><br>
procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out </font> Set;
<b> Items</b> : Set);</tt></p>
</blockquote>
<p>These procedures are used to add an object to a set or all items of one set to
another. The parameter <b>Item</b> can be either a handle or a pointer to the 
object. Nothing happens if an item is already in the set or pointer is an 
invalid handle or <font color="#0000FF">null</font>.
</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font>
  Adjust
  (<b>Container</b> : <font color="#0000FF"> in out </font>Set);</tt></p>
</blockquote>
<p>The assignment does not make a copy of the <b>Container</b>. It just 
increments an internal use count of the set body. A set will be physicaly copied 
only when a destructive operation is applied to it.</p>
<blockquote>
<p>
<tt><font color="#0000FF">function </font> Create<font color="#0000FF"> return
  </font>Set;</tt></p>
</blockquote>
<p>This function returns an empty set.</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Erase
  (<b>Container</b> : <font color="#0000FF"> in out </font> Set);</tt></p>
</blockquote>
<p>This procedure removes all objects from the set. The objects referenced only 
by <b>Container </b>will be deleted.</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Finalize
  (<b>Container</b> : <font color="#0000FF"> in out </font>Set);</tt></p>
</blockquote>
<p>The destructor may delete some objects referenced by <b>Container</b>.</p>
<blockquote>
<p>
<tt><font color="#0000FF">function</font> Find
(<b>Container</b> : Set; <b> Item</b> : Handle)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Integer;<br>
<font color="#0000FF">function</font> Find
(<b>Container</b> : Set; <b> Item</b> : Object_Type_Ptr)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Integer;</tt></p>
</blockquote>
<p>This function is used to <b>Item</b> in the set <b>Container</b>. The result
is either a positive index of the found item or a negated index of the place
where the item should be if it were in the set. </p>
<blockquote>
<p>
<tt><font color="#0000FF">function</font> Get (<b>Container</b> : Set;
<b> Index</b> : Positive)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Object_Type_Ptr;</tt> </p>
</blockquote>
<p>This function is used to get an item of the set <b>Container</b> using a positive index. 
The result is a pointer to the object. It is valid as long as the object is in 
the set. See also <a href="#Object.Handle.Generic_Set.Ref">Ref</a> which 
represents a safer way of accessing the set items. Constraint_Error is propagated if <b>Index</b> is wrong.
</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Get_Size
(<b>Container</b> : Set)<font COLOR="#000000">&nbsp;</font><font color="#0000FF">return</font>
Natural;</tt></p>
</blockquote>
<p>This function returns the number of items in the set.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Empty
(<b>Container</b> : Set) <font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Container</b> is empty.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font> Is_In
  (<b>Container</b> : Set; <b> Item</b> : Handle)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean;<br>
  <font color="#0000FF">function</font> Is_In
  (<b>Container</b> : Set; <b> Item</b> : Object_Type_Ptr)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Item</b> is in <b>Container</b>. Item can be either a 
pointer to an object or a handle to it. The result is always <i>
<font color="#1100000">false</font></i> when Item is invalid or
<font color="#0000FF">null</font>.</p>
<blockquote>
<p>
<tt><font color="#0000FF"><a name="Object.Handle.Generic_Set.Ref"></a>function</font> 
Ref (<b>Container</b> : Set;
<b> Index</b> : Positive)&nbsp;<font color="#0000FF">return</font> Handle;</tt> </p>
</blockquote>
<p>This function is used to get an item of the set <b>Container</b> using a positive index. 
The result is a handle to the object. Constraint_Error is propagated if <b>Index</b> is wrong.
</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Remove
  (<b>Container</b> :<font color="#0000FF"> in out </font> Set; <b> Index</b> : Positive);<br>
  <font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b> Item</b>
&nbsp;: Handle);<font color="#0000FF"><br>
  procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b> Item</b>
&nbsp;: Object_Type_Ptr);<br>
  <font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b>Items</b>     : Set);</tt></p>
</blockquote>
<p>These procedures are used to remove items from the set <b>Container</b>.&nbsp;An item can be removed either by its index, or explicitly 
by a pointer or handle to it, or else by specifying a
set of items to be removed. If a particular item is not in the set, then nothing
happens. Also nothing happens if a handle is illegal or pointer is
<font color="#0000FF">null</font>. Constraint_Error is propagated when item index is wrong.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">and</font>&quot; (<b>Left</b>, <b> Right</b> : Set)
  <font color="#0000FF"> return</font> Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot;
  <font COLOR="#000000">
&nbsp;</font>(<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font> Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">xor</font>&quot;
  (<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font> Set;</tt></p>
</blockquote>
<p>These functions are conventional set operations - intersection, union,
difference. Difference is defined as a set which items are only in one of the
sets <b>Left</b> and <b>Right</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">=</font>&quot; (<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font>
  Boolean;</tt></p>
</blockquote>
<p>True is returned if both sets contain same items.</p>
<p align="right">
  <a href="#1.5" name="1.7"></a><a href="#1.5"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>1.7. Universal sets of objects</H3>
<p><a name="Object.Handle.Generic_Handle_Set"></a>
The packages <a href="#Object.Handle.Generic_Handle_Set">Object.Handle.Generic_Handle_Set</a> 
resembles
<a href="#Object.Handle.Generic_Set">Object.Handle.Generic_Set</a>, but it is 
more universal. It allows to specify a user-defined types both for the object 
handles and for the weak references to objects (usually pointers). It has the following generic parameters:</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type
  </font>Handle_Type<font color="#0000FF"> is new
  </font>Handle<font color="#0000FF"> with private</font>;<font color="#0000FF"><br>
&nbsp;&nbsp; type
  </font>Object_Ptr_Type<font color="#0000FF"> is private</font>;<font color="#0000FF"><br>
&nbsp;&nbsp;
  </font>Null_Object_Ptr : <font color="#0000FF">Object_Ptr_Type</font>;<font color="#0000FF"><br>
&nbsp;&nbsp; with function
  </font>Ptr (Object : Handle_Type) <font color="#0000FF">return
  </font>Object_Ptr_Type<font color="#0000FF"> is</font> &lt;&gt;;<br>
	<font color="#0000FF">&nbsp;&nbsp; with function</font> Ref (Object : 
	Object_Ptr_Type) <font color="#0000FF">return
  </font>Handle_Type<font color="#0000FF"> is</font> &lt;&gt;;<br>
	<font color="#0000FF">&nbsp;&nbsp; with function</font> To_Object_Ptr 
	(Object : Object_Ptr_Type) <font color="#0000FF">return</font> 
	Object_Type_Ptr <font color="#0000FF">is</font> &lt;&gt;;<font color="#0000FF"><br>
&nbsp;&nbsp; with function</font> &quot;<font color="#FF0000">&lt;</font>&quot; (Left, Right 
	: Object_Ptr_Type) <font color="#0000FF">return
  </font>Boolean<font color="#0000FF"> is</font> &lt;&gt;;<font color="#0000FF"><br>
&nbsp;&nbsp; with function
  </font>&quot;<font color="#FF0000">=</font>&quot; (Left, Right : Object_Ptr_Type)<font color="#0000FF"> 
	return
  </font>Boolean<font color="#0000FF"> is</font> &lt;&gt;;<font color="#0000FF"><br>
  </font>&nbsp;&nbsp;&nbsp;Minimal_Size&nbsp;: Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp;&nbsp;Increment&nbsp;&nbsp;&nbsp;&nbsp;: Natural&nbsp; := <font color="#1100000">50</font>;<br>
  <font color="#0000FF">package
  </font>
  Object.Handle.Generic_Handle_Set<font color="#0000FF"> is
  </font>
  ...</tt></p>
</blockquote>
<p>Here:
</p>
<ul>
  <li>Handle_Type is a type derived from <a href="#Handle">Handle</a> to be used 
	as an object handle (strong reference);</li>
	<li>Object_Ptr_Type is a type used to reference objects (weak reference). Usually it is a 
	record type containing a pointer to <a href="#Object.Handle.Object_Type">Object_Type</a>'Class;</li>
	<li>Null_Object_Ptr is a value never be put in the set. Usually it has the 
	object pointer set to <font color="#0000FF">null</font>;</li>
	<li>
	<p align="left">Ptr is a function that converts a handle to the object to a 
	reference. It is analogous to the function <a href="#Object.Handle.Ptr">Ptr</a> 
	of the parent package;</li>
	<li>Ref is a function that converts a reference to the object to a handle 
	to. It is similar to the function <a href="#Object.Handle.Ref">Ref</a> of 
	the parent package;</li>
	<li>
	<p align="left">To_Object_Ptr is a function that gets
	<a href="#Object.Handle.Object_Type_Ptr">Object_Type_Ptr</a> from an object 
	reference;</li>
	<li>
	<p align="left">&quot;<font color="#FF0000">&lt;</font>&quot; and &quot;<font color="#FF0000">=</font>&quot; 
	are comparisons defined on object references;</li>
	<li>Minimal_Size is the minimal number of elements by which set is enlarged. When the first
    element is put into the array, this will
    be the initial vector size.</li>
  <li>Increment controls further vector enlargements. The vector is enlarged by <i>n</i>*Increment/100,
    where <i> n</i> is the current vector size. If the evaluated increment of 
  the vector size is less than Minimal_Size
    elements, then the latter is used instead.</li>
</ul>
<p>In other aspects both packages are identical. The interface subprograms 
described below are similar in both. The <a href="#Handle">Handle</a> should be 
read Handle_Type when <a href="#Object.Handle.Generic_Handle_Set">Object.Handle.Generic_Handle_Set</a> 
is considered.</p>
<p>
<a name="Object.Handle.Generic_Handle_Set.Set"></a>The type 
<a href="#Object.Handle.Generic_Handle_Set.Set">Set</a> is declared as:</p>
<blockquote>
<p><tt><font color="#0000FF">type
  </font>
 Set <font color="#0000FF"> is new
  </font>
 Ada.Finalization.Controlled <font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The following operations are defined on
<a href="#Object.Handle.Generic_Set.Set">Set</a>:</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out
</font> Set; <b> Item</b>&nbsp; : Handle_Type);<font color="#0000FF"><br>
procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out
</font> Set; <b> Item</b>&nbsp; : Object_Ptr_Type);<font color="#0000FF"><br>
procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out </font> Set;
<b> Items</b> : Set);</tt></p>
</blockquote>
<p>These procedures are used to add an object to a set or all items of one set to
another. The parameter <b>Item</b> can be either a handle or a pointer to the 
object. Nothing happens if an item is already in the set or pointer is an 
invalid handle or <font color="#0000FF">null</font>.
</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font>
  Adjust
  (<b>Container</b> : <font color="#0000FF"> in out </font>Set);</tt></p>
</blockquote>
<p>The assignment does not make a copy of the <b>Container</b>. It just 
increments an internal use count of the set body. A set will be physicaly copied 
only when a destructive operation is applied to it.</p>
<blockquote>
<p>
<tt><font color="#0000FF">function </font> Create<font color="#0000FF"> return
  </font>Set;</tt></p>
</blockquote>
<p>This function returns an empty set.</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Erase
  (<b>Container</b> : <font color="#0000FF"> in out </font> Set);</tt></p>
</blockquote>
<p>This procedure removes all objects from the set. The objects referenced only 
by <b>Container </b>will be deleted.</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Finalize
  (<b>Container</b> : <font color="#0000FF"> in out </font>Set);</tt></p>
</blockquote>
<p>The destructor may delete some objects referenced by <b>Container</b>.</p>
<blockquote>
<p>
<tt><font color="#0000FF">function</font> Find
(<b>Container</b> : Set; <b> Item</b> : Handle_Type)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Integer;<br>
<font color="#0000FF">function</font> Find
(<b>Container</b> : Set; <b> Item</b> : Object_Ptr_Type)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Integer;</tt></p>
</blockquote>
<p>This function is used to <b>Item</b> in the set <b>Container</b>. The result
is either a positive index of the found item or a negated index of the place
where the item should be if it were in the set. </p>
<blockquote>
<p>
<tt><font color="#0000FF">function</font> Get (<b>Container</b> : Set;
<b> Index</b> : Positive)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Object_Ptr_Type;</tt> </p>
</blockquote>
<p>This function is used to get an item of the set <b>Container</b> using a positive index. 
The result is a pointer to the object. It is valid as long as the object is in 
the set. See also <a href="#Object.Handle.Generic_Handle_Set.Ref">Ref</a> which 
represents a safer way of accessing the set items. Constraint_Error is propagated if <b>Index</b> is wrong.
</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Get_Size
(<b>Container</b> : Set)<font COLOR="#000000">&nbsp;</font><font color="#0000FF">return</font>
Natural;</tt></p>
</blockquote>
<p>This function returns the number of items in the set.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Empty
(<b>Container</b> : Set) <font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Container</b> is empty.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font> Is_In
  (<b>Container</b> : Set; <b> Item</b> : Handle_Type)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean;<br>
  <font color="#0000FF">function</font> Is_In
  (<b>Container</b> : Set; <b> Item</b> : Object_Ptr_Type)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Item</b> is in <b>Container</b>. Item can be either a 
pointer to an object or a handle to it. The result is always <i>
<font color="#1100000">false</font></i> when Item is invalid or
<font color="#0000FF">null</font>.</p>
<blockquote>
<p>
<tt><font color="#0000FF"><a name="Object.Handle.Generic_Handle_Set.Ref"></a>function</font> 
Ref (<b>Container</b> : Set;
<b> Index</b> : Positive)&nbsp;<font color="#0000FF">return</font> Handle_Type;</tt> </p>
</blockquote>
<p>This function is used to get an item of the set <b>Container</b> using a positive index. 
The result is a handle to the object. Constraint_Error is propagated if <b>Index</b> is wrong.
</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Remove
  (<b>Container</b> :<font color="#0000FF"> in out </font> Set; <b> Index</b> : Positive);<br>
  <font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b> Item</b>
&nbsp;: Handle_Type);<font color="#0000FF"><br>
  procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b> Item</b>
&nbsp;: Object_Ptr_Type);<br>
  <font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b>Items</b>     : Set);</tt></p>
</blockquote>
<p>These procedures are used to remove items from the set <b>Container</b>.&nbsp;An item can be removed either by its index, or explicitly 
by a pointer or handle to it, or else by specifying a
set of items to be removed. If a particular item is not in the set, then nothing
happens. Also nothing happens if a handle is illegal or pointer is
<font color="#0000FF">null</font>. Constraint_Error is propagated when item index is wrong.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">and</font>&quot; (<b>Left</b>, <b> Right</b> : Set)
  <font color="#0000FF"> return</font> Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot;
  <font COLOR="#000000">
&nbsp;</font>(<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font> Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">xor</font>&quot;
  (<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font> Set;</tt></p>
</blockquote>
<p>These functions are conventional set operations - intersection, union,
difference. Difference is defined as a set which items are only in one of the
sets <b>Left</b> and <b>Right</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">=</font>&quot; (<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font>
  Boolean;</tt></p>
</blockquote>
<p>True is returned if both sets contain same items.</p>

<hr><p align="right">
  <A name="2"></A><a href="#1.7"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#2.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H2>2. Persistency</H2>
<a name="Sets_etc0"></a>The packages <a href="#Generic_Set"> Gene</a><p>&nbsp;</p>
<p align="right">
  <a href="#1.5" name="2.1"></a><a href="#1.7"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.1. Persistent objects</H3>
<p><a name="persistent_objects"></a><a name="object_persistence"></a>A persistent object is one stored in an external storage, independent on the 
application, that originally created it. A persistent object can be restored 
from the external storage in a fully functional state in the same or other
application. The provided 
implementation of persistent objects was designed with the following goals in 
mind:</p>
<ul>
  <li>Portability across different platforms in the sense that an object can be 
  stored on one platform and successfully restored on another;</li>
  <li>Independency on the nature of the external storage;</li>
  <li>Support for dependent objects;</li>
  <li>Garbage collection  within the application;</li>
  <li>A possibility to implement garbage collection within the external storage;</li>
  <li>Automatic synchronization with the persistent storage upon finalization.</li>
</ul>
<p>Like other objects, persistent ones are normally accessed through <a href="#persistent_object_handles">handles</a>.</p>
<H4>2.1.1. Types</H4>
<p><a name="Object.Archived"></a><a name="Deposit"></a><a name="Object.Archived.Deposit_Ptr"></a>The package
<a href="#Object.Archived">Object.Archived</a> defines the  type
<a href="#Deposit">Deposit</a> serving as the abstract base type for all persistent 
objects:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Deposit <font color="#0000FF">is 
abstract new </font>Entity<font color="#0000FF"> with private</font>;<br>
<font color="#0000FF">type</font> Deposit_Ptr <font color="#0000FF">is access</font> 
Deposit'Class;</tt></p>
</blockquote>
<span style="font-weight: 400">A type derived from <a href="#Deposit">
Deposit</a> should:</span>
<ul>
  <li>
<span style="font-weight: 400">Override the procedure  <a href="#Object.Archived.Store">Store</a> 
which will be used to get a string description of the object;</span></li>
  <li>
<span style="font-weight: 400">Define a procedure with the profile of  <a href="#Object.Archived.Restore">Restore</a> which will create 
the object from its string description;</span></li>
  <li>
<span style="font-weight: 400"><a href="#Object.Archived.Register_Class">Register</a> the restore procedure as a new class. This could be done 
once during elaboration of the package deriving the type from <a href="#Deposit">
Deposit</a>;</span></li>
  <li>
<span style="font-weight: 400">Override <a href="#Object.Archived.Get_Class">Get_Class</a> to return the object class for 
which  <a href="#Object.Archived.Restore">Restore</a> was registered;</span></li>
  <li>
<span style="font-weight: 400">Optionally, override
  <a href="#Object.Archived.Get_Referents">Get_Referents</a> if the object may depend on other objects which 
thus have to be  stored/restored together with it:</span></li>
  <li>
If it overrides Finalize, then it shall call <a href="#Object.Archived.Close">
Close</a> from there <i>before</i>
<span style="font-weight: 400">the object becomes impossible to store.</span></li>
</ul>
<p>
<span style="font-weight: 400">Objects may depend on other objects, but these 
dependencies may not be circular.  <a href="#Object.Archived.Store">Store</a> 
and  <a href="#Object.Archived.Restore">Restore</a> provide forth and back string 
conversions. String was chosen instead of Stream_Element_Array to make it portable across different systems.</span></p>
<p>
<u><b>Storing an object</b></u>:</p>
<ol>
  <li>
<span style="font-weight: 400"><a href="#Object.Archived.Get_Referents">
  Get_Referents</a> is called. Each object it refers is archived first. The order of the objects in the list is important and has to be preserved;</span></li>
  <li>
<span style="font-weight: 400"><a href="#Object.Archived.Get_Class">Get_Class</a> is called and its result is archived;</span></li>
  <li>
<span style="font-weight: 400"><a href="#Object.Archived.Store">Store</a> is called and its result is finally archived.</span></li>
</ol>
<p>
<u><b>Restoring an object</b></u>:</p>
<ol>
  <li>
<span style="font-weight: 400">A list of objects the archived object depends on is built, 
the objects are restored as necessary;</span></li>
  <li>
<span style="font-weight: 400">The object's class string is obtained;</span></li>
  <li>
<span style="font-weight: 400"><a href="#Object.Archived.Restore">Restore</a> is finally called with these parameters. 
The class is used to select an appropriate <a href="#Object.Archived.Restore">Restore</a>. 
This is equivalent to dispatching according to the class. The list of available 
classes and their <a href="#Object.Archived.Restore">Restore</a> procedures is 
formed by calls to <a href="#Object.Archived.Register_Class">Register</a>.</span></li>
</ol>
<p><a name="Backward_Link"></a>The type <a href="#Backward_Link">Backward_Link</a> 
is used when it is necessary to monitor deletion of an object.</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Backward_Link <font color="#0000FF">is 
abstract new</font> Entity <font color="#0000FF">with private</font>;<br>
<font color="#0000FF">type</font> Backward_Link_Ptr <font color="#0000FF">is 
access </font>Backward_Link'Class;</tt></p>
</blockquote>
<p>Reference counting is used to prevent deletion of a
<a href="#Deposit">Deposit</a> object, when it is in use. Such objects are referenced 
through <a href="#Object.Archived.Handle.Handle">handles</a>. These are <i>direct links</i> 
to the object, also known as <i>strong</i> references. But sometimes it 
is necessary to break the dependency of one object from another to delete the 
latter. For this the former object may get a notification about a desire to delete 
a referent. Upon this notification it can invalidate the handle to the referent 
and so allow the 
collector to delete it. A notification object is derived from
<a href="#Backward_Link">Backward_Link</a>, which represent a <i>backward link</i> 
from a referred object to a dependent one. Each
<a href="#Deposit">Deposit</a> object maintains a list of its backward links, 
also called <i>weak</i> references. 
Typically an external storage connection object tracks all persistent objects 
which are in the memory at the moment. Usually it has an index of such memory resident 
objects. A record of this index has a handle to a specialized descendant of
<a href="#Backward_Link">Backward_Link</a>. So when an object is no more in use 
and so the last handle to it disappears, the object is automatically destroyed. 
In the course of this operation the storage connection object becomes a notification via 
call to <a href="#Object.Archived.Destroyed">Destroyed</a>. At this point the 
object being destroyed can be stored and then removed from the external storage 
index of memory resident objects.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Deposit_Container"></a>type</font> 
Deposit_Container <font color="#0000FF">is abstract<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Controlled<font color="#0000FF"> with 
private</font>;</tt></p>
</blockquote>
<p>The type <a href="#Deposit_Container">Deposit_Container</a> is an abstract 
specialized container for
<a href="#Deposit">Deposit</a> objects. The container operates as a container of handles. That is when an object is put into it, then the object will not be 
deleted until it is in. Physically a reference to the object is placed into the 
container. <a href="#Deposit_Container">Deposit_Container</a> objects are used 
upon object storing and restoring to keep the list of things the object depends 
on. <a href="#Deposit_Container">Deposit_Container</a> is not limited so it can 
be copied when necessary. The child packages <a href="#Object.Archived.Sets">
Object.Archived.Sets</a> and 
<a href="#Object.Archived.Lists">Object.Archived.Lists</a> provide unordered 
(set) and ordered (list) implementations of <a href="#Deposit_Container">
Deposit_Container</a>.</p>
<H4>2.1.2. Operations on objects</H4>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Close"></a>procedure</font> 
  Close (<b>Object</b> : <font color="#0000FF">in out </font>Deposit'Class);</tt> </p>
</blockquote>
<p>This class-wide procedure is called before finalization of a persistent 
object. It cleans the list of backward links. So it plays the role of a 
class-wide destructor. <a href="#Object.Archived.Finalize">Finalize</a> should 
<i>always</i> call it. For example, if the derived type is a descendant of
<span style="font-weight: 400"> <a href="#Deposit">
Deposit</a> overriding</span> Finalize, then the implementation should look 
like:</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Finalize (Object :
<font color="#0000FF">in out</font> Derived) <font color="#0000FF">is<br>
begin<br>
&nbsp;&nbsp; </font>Close (Object);<br>
<i>&nbsp;&nbsp; ...<font color="#008000"> -- finalization of Derived</font><br>
</i>&nbsp;&nbsp; Finalize (Deposit (Object));<br>
<font color="#0000FF">end</font> Finalize;</tt></p>
</blockquote>
<p>It is safe to call it multiple times, though it is essential to call it 
before any vital object data get finalized. So Finalization of a type derived 
from Derived may call <a href="#Object.Archived.Close">Close</a> as well. Note 
that in Ada Finalize is called prior finalization of any object's components. So 
it is safe to use them. However, keep in mind that task components (if any) are 
though not yet finalized, but completed <i>before</i> Finalize, thus neither
<span style="font-weight: 400">  <a href="#Object.Archived.Store">Store</a> nor <a href="#Object.Archived.Get_Referents">
  Get_Referents</a> may communicate with task components of the object. </span></p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Create"></a>procedure </font>Create<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Source</b>&nbsp; 
  : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Pointer</b> : <font color="#0000FF">in out</font> Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Class</b>&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>List</b>&nbsp;&nbsp;&nbsp; 
  : Deposit_Container'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Object</b>&nbsp; : <font color="#0000FF">out</font> Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure calls
<span style="font-weight: 400"><a href="#Object.Archived.Restore">Restore</a> </span>
for <b>Class</b> simulating a dispatching call. Name_Error is propagated if <b>
Class</b> is not a registered object class. The string Source contains object 
description to be restored starting from the character <b>Source</b> (<b>Pointer</b>).
<b>Pointer</b>&nbsp; is advanced to the first object following from the used 
ones. The parameter <b>Object</b> accepts a pointer to the newly created object.
</p>
<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Data_Error</TD>
    <TD>Syntax error</TD>
  </TR>
  <TR>
    <TD>End_Error</TD>
    <TD>Nothing matched</TD>
  </TR>
  <TR>
    <TD>Layout_Error</TD>
    <TD>The value of <B>Pointer</B> is not in the range
      <B>Source</B>'First..<B>Source</B>'Last+1&nbsp;</TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD><b>Class</b> is not a registered class</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD>Insufficient dependencies list</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Delete"></a>procedure</font> 
  Delete (<b>Object</b> : <font color="#0000FF">in out</font> Deposit'Class);</tt></p>
</blockquote>
<p>This procedure is used when <b>Object</b> is being deleted. On each item in 
the <b>Object</b>'s obituary notices delivery list,
<a href="#Object.Archived.Delete">Delete</a> is called. This has the effect that 
some references to <b>Object</b> may disappear and so the object will be 
collected. Note that a call to <a href="#Object.Archived.Delete">Delete</a> does 
not guaranty <b>Object</b>'s deletion, because some references to it, may still 
be present. It is safe to add new backward links to the <b>Object</b>'s 
notification list from <a href="#Object.Archived.Delete">Delete</a>, because the 
items are appended at the end of the delivery list. This also means that they will receive a 
<a href="#Object.Archived.Deleted">Deleted</a> callback in 
the course of the same notification. Though <b>Object</b>'s deletion is not 
guaranteed it might happen. So to prevent undefined behavior 
a caller should hold a handle to <b>Object</b> when it calls to <a href="#Object.Archived.Delete">
Delete</a>.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Finalize"></a>procedure</font> 
  Finalize (<b>Object</b> : <font color="#0000FF">in out</font> Deposit);</tt></p>
</blockquote>
<p>Upon finalization backward links list is cleaned. All interested parties 
receive a notification via call to <a href="#Object.Archived.Destroyed">
Destroyed</a>. A derived type implementation have to call <a href="#Object.Archived.Finalize">
Finalize</a> as well as <a href="#Object.Archived.Close">Close</a>.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Free (<b>Object</b> :
  <font color="#0000FF">in out</font> Deposit_Ptr);</tt></p>
</blockquote>
<p>This procedure is used to delete manually created objects. It is never called 
for existing objects, only for improperly constructed ones from an 
implementation of
<span style="font-weight: 400"><a href="#Object.Archived.Restore">Restore</a></span>.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Get_Class"></a>function</font> 
  Get_Class (<b>Object</b> : Deposit) <font color="#0000FF">return</font> String<font color="#0000FF"> 
  is abstract;</font></tt></p>
</blockquote>
<p>This function returns the class of <b>Object</b>. The class is a string 
uniquely describing the object's type. It is analogous to external type tag 
representation. Though, different types of objects may share same class if 
necessary.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Get_Referents"></a>
  procedure</font> Get_Referents<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp; 
  : Deposit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Container</b> : <font color="#0000FF">in out</font> Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure adds objects referenced from <b>Object</b> to <b>Container</b> 
objects. 
Only immediately viewed objects are stored there. No deep search has to be made 
to detect all objects. Objects shall not depend recursively. The default 
implementation does nothing, which behavior corresponds to an independent 
object. An implementation may raise Use_Error on a wrong object. See also notes 
about <a href="#Object.Archived.Close">Close</a>.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Is_Modified"></a>function</font> Is_Modified (<b>Object</b> : 
  Deposit)<font color="#0000FF"><br>
&nbsp;&nbsp; return </font>Boolean<font color="#0000FF"> is abstract;</font></tt></p>
</blockquote>
<p>This function is used to check if <b>Object</b>'s state was changed. 
Persistent objects serving as proxies to a persistent storage will require 
synchronization if this function returns <i><font color="#1100000">true</font></i>. 
An implementation of a mutable object would normally have a Boolean flag to be 
set by any destructive operation or new object creation.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Reset_Modified"></a>procedure </font>Reset_Modified (<b>Object</b> :
  <font color="#0000FF">in out</font> Deposit) <font color="#0000FF">is 
  abstract;</font></tt></p>
</blockquote>
<p>This procedure is used to reset <b>Object</b>'s state modification flag. It 
is called immediately after synchronization the object with the persistent 
storage. </p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Restore"></a>type </font>
  Restore<font color="#0000FF"> is access procedure<br>
&nbsp;&nbsp;&nbsp; </font>&nbsp;(&nbsp; <b>Source</b>&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Pointer</b> :
  <font color="#0000FF">in out</font> Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Class</b>&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>List</b>&nbsp;&nbsp;&nbsp; : 
  Deposit_Container'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp; :
  <font color="#0000FF">out</font> Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure creates a new object from its string 
representation. It parses <b>Source</b> starting from <b>Source</b> (<b>Pointer</b>).
<b>Pointer</b> is then advanced to the first character following the object's 
description in the string. The procedure has to be dispatching depending on the 
object's class, which is impossible in Ada. For this reason it is defined as an 
access to procedure type. Each object class has to define such a function and 
register it (see <a href="#Object.Archived.Register_Class">Register_Class</a>). The parameter <b>Class</b> contains the actual 
object class according to which dispatch to an implementation of
<span style="font-weight: 400"><a href="#Object.Archived.Restore">Restore</a> </span>
was made. The parameter <b>List</b> contains the references to the objects the 
restored object depends on. The order of the objects in the list is same as one 
returned in
<span style="font-weight: 400"><a href="#Object.Archived.Get_Referents">
Get_Referents</a></span>. The result is a newly allocated object pointed by the
<b>Object</b> parameter. An implementation may raise the following exceptions to 
indicate  errors:
</p>
<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Data_Error</TD>
    <TD>Syntax error</TD>
  </TR>
  <TR>
    <TD>End_Error</TD>
    <TD>Nothing matched</TD>
  </TR>
  <TR>
    <TD>Layout_Error</TD>
    <TD>The value of <B>Pointer</B> is not in the range
      <B>Source</B>'First..<B>Source</B>'Last+1&nbsp;</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD>Insufficient dependencies list</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Store"></a>procedure
  </font>Store<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Destination</b> 
  : <font color="#0000FF">in out</font> String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Pointer</b>&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> 
  Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Object</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Deposit<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
  <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>An implementation places string describing <b>Object</b> is into <b>
Destination</b> starting from the position specified by <b>Pointer</b>. <b>
Pointer</b> is then advanced to the next position following the output. 
Layout_Error is propagated when <b>Pointer</b> not in <b>Source</b>'First..<b>Source</b>'Last 
+ 1 or there is no room for output. Use_Error can be raised when <b>Object</b> is 
wrong. See also notes about <a href="#Object.Archived.Close">Close</a>.</p>

<H4>2.1.3. Operations on backward links to objects</H4>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Attach"></a>procedure </font>Attach<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Link</b>&nbsp;&nbsp; 
  : Backward_Link_Ptr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Object</b> : Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure places <b>Link</b> at the end of <b>Object</b>'s delivery 
list. If it is already in another list then it is removed from there first. 
Nothing happens if <b>Object</b> is <font color="#0000FF">null</font>. </p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Deleted"></a>procedure
  </font>Deleted<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Link</b>&nbsp; 
  :<font color="#0000FF"> in out </font>Backward_Link;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Temps</b> : <font color="#0000FF">in out</font> Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) <font color="#0000FF">&nbsp;is 
  abstract</font>;</tt></p>
</blockquote>
<p>This procedure is used when an object is requested to be deleted. Normally
<a href="#Object.Archived.Deleted">Deleted</a> is called as a result of object 
deletion request via call to <a href="#Object.Archived.Delete">Delete</a>. The 
parameter <b>Temps</b> is the list of temporal objects the implementation might 
create. For example, some objects might be created to be notified within the 
course of the operation performed by the caller. Note that the caller should 
hold a handle to <b>Link</b>, to allow the callee to undertake actions which 
would otherwise lead to <b>Link</b> deletion. Note also that object's 
finalization does not cause a call to <a href="#Object.Archived.Delete">Delete</a> 
it calls <a href="#Object.Archived.Destroyed">Destroyed</a> instead.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Destroyed"></a>procedure</font> 
  Destroyed (<b>Link</b> : <font color="#0000FF">in out</font> Backward_Link)<font color="#0000FF"> 
  is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is used when an object is finally destroyed, but 
is still fully operable. Thus an implementation of <a href="#Object.Archived.Destroyed">Destroyed</a> may safely access  the 
object referred by <b>Link</b>. It may for example synchronize the object&nbsp;with the external 
storage or remove the object from the index cache etc. The caller should hold a 
handle to <b>Link</b>. </p>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font>Detach (<b>Link</b> :<font color="#0000FF"> 
  in out</font> Backward_Link);</tt></p>
</blockquote>
<p>This procedure removes <b>Link</b> from object's delivery list, if any.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Finalize (<b>Link</b> :
  <font color="#0000FF">in out</font> Backward_Link);</tt></p>
</blockquote>
<p>This procedure should be called by a derived type if overridden. <b>Link</b> 
is removed for object's delivery list if any.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font> Self (<b>Link</b> : Backward_Link)
  <font color="#0000FF">return</font> Backward_Link_Ptr;</tt></p>
</blockquote>
<p>This function returns a pointer to the link object (to <b>Link</b> itself). 
Constraint_Error is propagated when <b>Link</b> is not bound to any object.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.This"></a>function</font> This (<b>Link</b> : Backward_Link)
  <font color="#0000FF">return</font> Deposit_Ptr;</tt></p>
</blockquote>
<p>This function returns a pointer to the target of <b>Link</b>. 
Constraint_Error is propagated when <b>Link</b> is not bound to any object.</p>

<H4>2.1.4. Operations on containers</H4>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Add"></a>procedure </font>
  Add<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
  : <font color="#0000FF">in out </font>Deposit_Container;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Object</b>&nbsp;&nbsp;&nbsp; : Deposit_Ptr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Backward</b>&nbsp; : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) <font color="#0000FF">&nbsp;is 
  abstract</font>;</tt></p>
</blockquote>
<p>This procedure puts a reference to <b>Object</b> into <b>Container</b>. The implementation should ensure 
that <b>Object</b> will not be destroyed until it is in. The parameter <b>
Backward</b>, when <i><font color="#1100000">true</font></i> indicates a backward 
link. Backward links are used when the dependent object associated with the 
container can survive deletion of <b>Object</b>. It is an optional parameter 
which may be ignored by some implementations. When it is supported, then marking 
an <b>Object</b> as a backward link should override the effect of any placing 
the same object as a direct link (with <b>Backward</b> = <i>
<font color="#1100000">false</font></i>). Nothing happens if <b>Object</b> is
<font color="#0000FF">null</font>.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font>Erase (<b>Container</b> :
  <font color="#0000FF">in out</font> Deposit_Container) <font color="#0000FF">
  is abstract</font>;</tt></p>
</blockquote>
<p>This procedure removes all objects from <b>Container</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Get"></a>function </font>
  Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
  Deposit_Container;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp; 
  : Positive<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return </font>Deposit_Ptr<font color="#0000FF"> is abstract</font>;</tt></p>
</blockquote>
<p>This function is used to enumerate the objects in a container <b>Objects</b> 
indices start with 1. Contraint_Error is propagated when Index is wrong.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Get_Size"></a>function </font>
  Get_Size (<b>Container</b> : Deposit_Container)<font color="#0000FF"><br>
&nbsp;&nbsp; return </font>Natural<font color="#0000FF"> is abstract</font>;</tt></p>
</blockquote>
<p>This function returns the number of objects in <b>Container</b>, i.e. the 
largest possible index allowed in <a href="#Object.Archived.Get">Get</a>. 0 
is returned when the container is empty. Note that the objects in a container need not to be 
all different. This depends on the container implementation.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Is_Backward"></a>
  function </font>Is_Backward<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
  Deposit_Container;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp; 
  : Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return </font>Boolean<font color="#0000FF"> is abstract</font>;</tt></p>
</blockquote>
<p>The result of this function is <i><font color="#1100000">true</font></i> if a 
backward link is used for <b>Object</b> in <b>Container</b>. Constraint_Error is 
propagated when <b>Object</b> is not in <b>Container</b>. Use_Error is 
propagated when the container implementation does not distinguish direct and 
backward links.</p>
<blockquote>
  <p><tt><font color="#0000FF">function </font>Is_Empty (<b>Container</b> : 
  Deposit_Container'Class)<font color="#0000FF"><br>
&nbsp;&nbsp; return </font>Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#1100000">true</font></i> if <b>
Container</b> is empty. It is class-wide.</p>
<blockquote>
  <p><tt><font color="#0000FF">function </font>Is_In<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
  Deposit_Container;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp; 
  : Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return </font>Boolean<font color="#0000FF"> is abstract</font>;</tt></p>
</blockquote>
<p>This function returns <i><font color="#1100000">true</font></i> if <b>Object</b> 
is in <b>Container</b>. Note that <font color="#0000FF">null</font> cannot be in 
any container.</p>

<H4>2.1.5. Registering classes of objects</H4>
<blockquote>
  <p><tt><font color="#0000FF">function</font> Is_Registered (<b>Class</b> : 
  String) <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <font color="#1100000"><i>true</i></font> if there is a class of objects registered under 
the name <b>Class</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Register_Class"></a>
  procedure </font>Register_Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Class</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Constructor</b> : Restore<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is used to register each new class of objects. It is analogous 
to creating a dispatching table. It is necessary to register a class to make
<span style="font-weight: 400"><a href="#Object.Archived.Restore">Restore</a> </span>
functions working. Nothing happens if the class is already registered and has 
same constructor. Name_Error is propagated when class is registered with a 
different constructor.</p>

<H4>2.1.6. Sets of persistent objects</H4>

<p><a name="Object.Archived.Sets"></a><a name="Deposit_Set"></a>The package
<a href="#Object.Archived.Sets">Object.Archived.Sets</a> provides an 
implementation of <a href="#Deposit_Container">Deposit_Container</a>. The type
<a href="#Deposit_Set">Deposit_Set</a> is derived there:</p>
<blockquote>
  <p><tt><font color="#0000FF">type </font>Deposit_Set<font color="#0000FF"> is 
  new </font>Deposit_Container<font color="#0000FF"> with private</font>;</tt></p>
</blockquote>
<p>Sets do not distinguish multiple insertion of an object.  they also ignore 
the <b>Backward</b> parameter of <a href="#Object.Archived.Add">Add</a>. So
<a href="#Object.Archived.Is_Backward">Is_Backward</a> will raise Use_Error. 
Additionally to the predefined operations, <a href="#Deposit_Set">Deposit_Set</a> 
provides standard set-operations:</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font>Remove<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
  : <font color="#0000FF">in out </font>Deposit_Set;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Object</b>&nbsp;&nbsp;&nbsp; : Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure removes <b>Object</b> from <b>Container</b>. Nothing happens 
if it is <font color="#0000FF">null</font> or not in.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">and</font>&quot; (<b>Left</b>, <b> Right</b> : 
  Deposit_Set)
  <font color="#0000FF"> return</font> Deposit_Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot;
  <font COLOR="#000000">
&nbsp;</font>(<b>Left</b>, <b> Right</b> : Deposit_Set) <font color="#0000FF"> return</font> 
  Deposit_Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">xor</font>&quot;
  (<b>Left</b>, <b> Right</b> : Deposit_Set) <font color="#0000FF"> return</font> 
  Deposit_Set;</tt></p>
</blockquote>
<p>These functions are conventional set operations - intersection, union,
difference. Difference is defined as a set which items are only in one of the
sets <b>Left</b> and <b>Right</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">=</font>&quot; (<b>Left</b>, <b> Right</b> : 
  Deposit_Set) <font color="#0000FF"> return</font>
  Boolean;</tt></p>
</blockquote>
<p><font color="#1100000"><i>true</i></font> is returned if both sets contain same items.</p>

<H4>2.1.7. Lists of persistent objects</H4>

<p><a name="Object.Archived.Lists"></a><a name="Deposit_List"></a>The package
<a href="#Object.Archived.Lists">Object.Archived.Lists</a> provides an 
implementation of <a href="#Deposit_Container">Deposit_Container</a>. The type
<a href="#Deposit_List">Deposit_List</a> is derived there as:</p>
<blockquote>
  <p><tt><font color="#0000FF">type </font>Deposit_List<font color="#0000FF"> is 
  new </font>Deposit_Container<font color="#0000FF"> with private</font>;</tt></p>
</blockquote>
<p>All objects in the list are enumerated  from 1. The same object can 
occupy several places in the list. In the external storage <a href="#Deposit_List">Deposit_List</a> can 
be stored as a set of objects, where objects do not repeat, followed by
a list of values identifying the objects in the set. Additionally to the 
predefined operations, <a href="#Deposit_List">Deposit_List</a> provides:</p>
<blockquote>
  <p><tt><font color="#0000FF">function </font>Get_Total (<b>Container</b> : 
  Deposit_List)<font color="#0000FF"> return</font> Natural;</tt></p>
</blockquote>
<p>This function returns the number of distinct objects in <b>Container</b>. 
This value is less or equal to the one returned by
<a href="#Object.Archived.Get_Size">Get_Size</a>.</p>
<blockquote>
  <p><tt><font color="#0000FF">function </font>Is_First<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
  Deposit_List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp; 
  : Positive<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#1100000">true</font></i> if <b>Index</b> 
is the least index of the object it specifies. I.e. the least index of the 
object returned by
<a href="#Object.Archived.Get">Get</a> (<b>Container</b>, <b>Index</b>). 
Constraint_Error is propagated if <b>Index</b> is wrong.</p>

<H4>2.1.8. Referent objects enumeration</H4>

<p><a name="Object.Archived.Iterators"></a><a name="References_Iterator"></a>The package
<a href="#Object.Archived.Iterators">Object.Archived.Iterators</a> provides an 
abstract iterator of references:</p>
<blockquote>
  <p><tt><font color="#0000FF">type </font>References_Iterator<br>
&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Referents : <font color="#0000FF">access </font>
  Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp; ) <font color="#0000FF">&nbsp;is new </font>
  Ada.Finalization.Limited_Controlled<font color="#0000FF"> with private;</font></tt></p>
</blockquote>
<p>The type <a href="#References_Iterator">References_Iterator</a> can be used 
directly or be extended. It provides the following operations:</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Iterators.Enumerate">
  </a>procedure </font>Enumerate<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Iterator</b> : <font color="#0000FF">
  in out</font> References_Iterator'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Object</b>&nbsp;&nbsp; : Deposit'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This class-wide procedure is called to enumerate references of <b>Object</b>. This same procedure is used for both starting the 
process and continuing it for each found reference.
Enumerate calls <a href="#Object.Archived.Get_Referents">Get_Referents</a> for
<b>Object</b> and places all found objects which <b>Object</b> depends on into
<b>Iterator</b>.Referents.<font color="#0000FF">all</font>. A found object is 
placed only once which is detected by looking into <b>Iterator</b>.Referents.<font color="#0000FF">all</font>. 
The object itself is not put there. After completion the caller may inspect <b>
Iterator</b>.Referents.<font color="#0000FF">all</font> for any found objects.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font>On_Each <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Iterator</b> :<font color="#0000FF"> 
  in out </font>References_Iterator;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Referent</b> : Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure can be overridden. It is called by
<a href="#Object.Archived.Iterators.Enumerate">Enumerate</a> each time a new 
object is found. It may raise an exception to stop the iteration process. This 
exception will then propagate out of
<a href="#Object.Archived.Iterators.Enumerate">Enumerate</a>.</p>
<p align="right">
  <a href="#1.5" name="2.2"></a><a href="#2.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.3"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.2. Handles to persistent objects</H3>
<p><a name="Object.Archived.Handle"></a><a name="Object.Archived.Handle.Handle"></a><a name="persistent_object_handles"></a>Persistent
<a href="#persistent_objects">objects</a> are subject of garbage collection. The
recommended way to access them is through handles, which prevents premature
destruction of objects in use. Handles can be aggregated into other objects to
express object dependencies. Note that circular dependencies shall be avoided.
The best way to do it is to design object in a way that would exclude any
possibility of circular dependencies. If that is not possible, then <a href="#Object.Archived.Handle.Is_Dependent">Is_Dependent</a>
should be used to check dependencies at run time. The generic package
<a href="#Object.Archived.Handle">Object.Archived.Handle</a> defines the type
<a href="#Object.Archived.Handle.Handle">Handle</a> used to 
reference persistent object. It is derived from <a href="#Handle">Handle</a> 
obtained by an instantiation of <a href="#Object.Handle">Object.Handle</a>:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Object_Type<font color="#0000FF"> is abstract new </font>
Deposit<font color="#0000FF"> with private</font>;<font color="#0000FF"><br>
&nbsp;&nbsp; type </font>Object_Ptr_Type<font color="#0000FF"> is access</font> 
Object_Type'Class;<font color="#0000FF"><br>
package </font>Handles<font color="#0000FF"> is new </font>
Object.Handle (Deposit, Deposit_Ptr);<font color="#0000FF"><br>
&nbsp;&nbsp;
type </font>Handle<font color="#0000FF"> is new </font>Handles.Handle<font color="#0000FF"> 
with null record</font>;</tt></p>
</blockquote>
<p>The formal parameters of the package are:</p>
<ul>
  <li>Object_Type is a descendant of
<span style="font-weight: 400"> <a href="#Deposit">
Deposit</a>. It can be different from <a href="#Deposit">
Deposit</a> when it is necessary to narrow the class of persistent objects;</span></li>
  <li>Object_Ptr_Type is a class-wide pointer to Object_Type. Note that 
  Object_Ptr_Type should use the same storage pool as
  <a href="#Object.Archived.Deposit_Ptr">Deposit_Ptr</a>, because the 
  implementation requires conversions between them. Unfortunately there is no 
  formal way to express this requirement in Ada. Hopefully the compiler would 
  refuse infeasible
<a href="#Object.Archived.Handle">Object.Archived.Handle</a> instantiations.</li>
</ul>
<p>There is a ready-to use instantiation of
<a href="#Object.Archived.Handle">Object.Archived.Handle</a> with
<span style="font-weight: 400"> <a href="#Deposit">
Deposit</a> and </span><a href="#Object.Archived.Deposit_Ptr">Deposit_Ptr</a> as 
the actual parameters: <a href="#Deposit_Handles">Deposit_Handles</a>.</p>
<p>The package
<a href="#Object.Archived.Handle">Object.Archived.Handle</a> defines the 
following operations on <a href="#Object.Archived.Handle.Handle">
Handle</a>:</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Handle.Add"></a>procedure </font>
  Add<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
  : <font color="#0000FF">in out </font>Deposit_Container;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Object</b>&nbsp;&nbsp;&nbsp; : Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Backward</b>&nbsp; : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) <font color="#0000FF">&nbsp;is 
  abstract</font>;</tt></p>
</blockquote>
<p>This procedure puts <b>Object</b> into <b>Container</b>. The parameter <b>
Backward</b>, when <i><font color="#1100000">true</font></i> indicates a backward 
link. Backward links are used when the dependent object associated with the 
container can survive deletion of <b>Object</b>. Constraint_Error is propagated 
when <b>Object</b> is 
an invalid handle.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Handle.Delete"></a>procedure</font> Delete (<b>Object</b> : <font color="#0000FF">
  in out</font> Handle);</tt></p>
</blockquote>
<p>This procedure requests deletion of the object pointed by the handle <b>
Object</b>. As the result of the operation <b>Object</b> becomes an invalid 
handle. The object itself is deleted if possible. Nothing happens if <b>Object</b> 
is not a valid handle.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font> Get_Class (<b>Object</b> : 
  Handle) <font color="#0000FF">return</font> String;</tt></p>
</blockquote>
<p>This function returns the class of <b>Object</b>. The class is a string 
uniquely describing the object's type. It is analogous to an external type tag 
representation. Though, different types of objects may have same class if 
necessary.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Get_References<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp; 
  : Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Container</b> :<font color="#0000FF"> in out</font> Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure adds to <b>Container</b> references to all objects the object 
specified by the handle <b>Object</b> depends on. No objects added if <b>
Object</b> is an invalid handle. </p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Invalidate (<b>Object</b> : <font color="#0000FF">
  in out</font> Handle);</tt></p>
</blockquote>
<p>This procedure detaches handle from the object (if any) it points to. The
result handle cannot be used to access any object. The referenced object is
destroyed if it was the last handle.</p>
<blockquote>
  <p><tt><font color="#0000FF">function </font>Is_Backward<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
  Deposit_Container'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp; 
  : Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <font color="#1100000"><i>true</i></font> if a backward 
link used for <b>Object</b> in <b>Container</b>. Contstraint_Error is propagated 
when <b>Object</b> is not in <b>Container</b> or invalid handle. Use_Error does 
when <b>Container</b> does not distinguish direct and backward links.</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Object.Archived.Handle.Is_Dependent"></a>function </font>Is_Dependent<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Dependant</b> : 
  Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Referent</b>&nbsp; 
  : Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return</font> Boolean;<font color="#0000FF"><br>
  function </font>Is_Dependent<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Dependant</b> : 
  Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Referents</b> 
  : Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return</font> Boolean;</tt></p>
</blockquote>
<p>These functions check whether <b>Dependant</b> refers to <b>Referent</b> or, 
when the second parameter is a container, then whether <b>Dependant</b> refers to any 
of the objects from that container. The result is <i><font color="#1100000">false</font></i> 
if <b>Dependant</b>, <b>Referent</b> is invalid or <b>Referents</b> is empty. </p>
<blockquote>
  <p><tt><font color="#0000FF">function </font>Is_In<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
  Deposit_Container'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp; 
  : Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
  return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#1100000">true</font></i> if <b>Object</b> 
is in <b>Container</b>. When <b>Object</b> is an invalid handle, the result <i>
<font color="#1100000">false</font></i>.</p>
<blockquote>
<p><tt>
<font COLOR="#0000ff">function </font>Is_Valid (<b>Object</b> : Handle) <font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
<p>This function checks whether a handle points to any object, i.e. is valid. </p>
<blockquote>
<p><tt>
<font COLOR="#0000ff">function </font>Ptr (<b>Object</b> : Handle) <font color="#0000FF"> return</font> 
Deposit_Ptr;</tt></p>
</blockquote>
<p>This function is used to get a pointer to the object the handle <b>Object</b> points to.

The pointer of to the
object shall be used no longer the handle it was get from exists. A safe way to
do it is to avoid declarations of any variables of the type Deposit_Ptr. </p>
<blockquote>
<p>
<tt><font COLOR="#0000ff">function </font> Ref (<b>Thing</b> : Object_Type_Ptr)
<font color="#0000FF"> return</font> Handle;</tt>
</p>
</blockquote>
<P>This function is used to get a handle from a pointer to an persistent object.</p>
<blockquote>
<p>
<tt><font COLOR="#0000ff">function</font> Ref<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> : 
Deposit_Container'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: Positive<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font COLOR="#0000ff">
return</font> Handle;</tt></p>
</blockquote>
<P>This function can be used to enumerate the objects in a container. Objects are 
enumerated from 1. The result is a valid handle to an object in <b>Container</b>. 
Contraint_Error is propagated when <b>Index</b> is wrong. Note that objects may 
repeat in containers of some types.</p>
<blockquote>
  <p><tt><font color="#0000FF">function </font>References (<b>Object</b> : 
  Handle) <font color="#0000FF">return</font> Deposit_Set;</tt></p>
</blockquote>
<p>This function is used to query all objects its argument depends on. The 
result is a set of objects. It is empty if <b>Object</b> is an invalid handle.</p>
<p><a name="Deposit_Handles"></a>The package Deposit_Handles provides an 
instantiation of
<a href="#Object.Archived.Handle">Object.Archived.Handle</a>:</p>
<blockquote>
  <p><tt><font color="#0000FF">package </font>Deposit_Handles<font color="#0000FF"> 
  is<br>
&nbsp;&nbsp; new </font>Object.Archived.Handle (Deposit, Deposit_Ptr);</tt></p>
</blockquote>
<p align="right"><a name="2.3"></a><a href="#2.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.4"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.3. Persistent directories</H3>
<p><a name="Persistent.Directory"></a>There is no need to have dedicated objects 
to serve as persistent directories as any object could become a directory. 
Nevertheless the package <a href="#Persistent.Directory">Persistent.Directory</a> 
provides objects which can be used as directories. They have no any 
functionality except an ability to persist. The package declares:</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font>Create<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> Storage_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Directory</b> : <font color="#0000FF">out</font> Deposit_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Parent</b>&nbsp;&nbsp;&nbsp; : Deposit_Handle := Root_Directory<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure creates a new directory with the name <b>Name</b> and <b>
Parent</b> as the parent directory. The result is a handle <b>Directory</b> to 
the object. The parameter <b>Storage</b> is a handle <a href="#Persistent.Handle.Storage_Handle">Storage_Handle</a> 
to the persistent storage object where the directory has to be created.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle <b>Storage</b>, <b>Parent</b> is not 
	persistent in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD>Illegal name (such as empty), name conflict</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt>Directory_Class : <font color="#0000FF">constant</font> String := &quot;<font color="#FF0000">Directory</font>&quot;;</tt></p>
</blockquote>
<p>Is the class name of the directory objects.</p>
<p align="right"><a name="2.4"></a><a href="#2.3"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.5"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.4. Persistent storage implementation example</H3>
<p>This paragraph describes a simplified example of persistent storage. It provides an 
implementation of a persistent storage based on direct access file. As an 
example of persistent objects serve nodes of binary trees.</p>

<H4>2.4.1. Persistent storage implementation</H4>

<p><a name="test_persistent_file_storage"></a>The implementation uses a direct access file to store objects. Each object is 
stored in one file record. The record number serves as the object key. 
Observe that the implementation is independent from any implementation of 
concrete persistent object types (derived from <a href="#Deposit">Deposit</a>).
This example serves illustrative purpose. For abstract persistent storage
interface see <a href="#Persistent">Persistent</a>, <a href="#Persistent.Handle">Persistent.Handle</a>.
For persistent storage implementations see <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>.</p>

File <EM>test_persistent_file_storage.ads</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> Ada.Direct_IO;<br>
<font color="#0000FF">with</font> Ada.Finalization;<br>
<font color="#0000FF">with</font> Generic_Map;<br>
<font color="#0000FF">with</font> Object.Handle;<br>
<br>
<font color="#0000FF">with</font> Object.Archived; <font color="#0000FF">&nbsp;use</font> 
Object.Archived;<br>
<font color="#0000FF">with</font> Deposit_Handles; <font color="#0000FF">&nbsp;use</font> 
Deposit_Handles;<br>
<br>
<font color="#0000FF">package</font> Test_Persistent_File_Storage
<font color="#0000FF">is</font><br>
<font color="#008000">&nbsp;&nbsp;&nbsp;--<br>
&nbsp;&nbsp;&nbsp;--&nbsp;File_Storage&nbsp;--&nbsp;Direct&nbsp;I/O&nbsp;based&nbsp;storage&nbsp;for&nbsp;persistent&nbsp;objects<br>
&nbsp;&nbsp; --</font><br>
&nbsp;&nbsp; <font color="#0000FF">type</font> File_Storage
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new</font> Ada.Finalization.Limited_Controlled
<font color="#0000FF">with 
private</font>;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Key -- To reference stored objects = record number 1..<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">type</font> Key <font color="#0000FF">is new Integer</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">subtype</font> Deposit_Handle
<font color="#0000FF">is</font> Deposit_Handles.Handle;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Initialize (Storage : 
<font color="#0000FF">in out</font> File_Storage);<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Finalize (Storage : 
<font color="#0000FF">in out</font> File_Storage);<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Clean_Up;<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Store<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Storage :
<font color="#0000FF">access</font> File_Storage;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object : Deposit_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Key;<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Restore<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; (&nbsp; Storage : <font color="#0000FF">access</font> File_Storage;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Key<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Deposit_Handle;</tt></TD>
  </TR>
</TABLE>

<p>Here we declare the type File_Storage as a limited controlled type. The 
procedures Initialize / Finalize are overridden to provide construction / 
destruction. Upon construction the file is opened. Upon destruction it is 
closed. The procedure Clean_Up is provided to delete the file. The function Store 
will be used to store an object. It returns the object key, which identifies the 
object there. The key has the type Key also declared in this package. It is the 
number of the record reserved for the object in the file. When the object is 
already persistent in the file, its key is returned, so it is safe to call Store 
multiple times. The function Restore 
is the operation opposite to Store. It takes the object key and returns a handle 
to the object. Restore is also safe to call multiple times. So when the object 
referenced by a key, is already memory resident, a handle to it is returned 
instead of creating a new memory resident copy. The type <a href="#Object.Archived.Handle.Handle">Handle</a> from 
the package <a href="#Deposit_Handles">Deposit_Handles</a> is used to reference 
persistent objects. <a href="#Deposit_Handles">Deposit_Handles</a>.<a href="#Object.Archived.Handle.Handle">Handle</a> 
is &quot;renamed&quot; to Deposit_Handle for convenience. The objects themselves are never 
referenced directly but through handles only.</p>

File <EM>test_persistent_file_storage.ads</EM> (continued, the private part):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">private</font><br>
<font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Index_Record -- One per bound object<br>
&nbsp;&nbsp;
--<br>
&nbsp;&nbsp; </font><font color="#0000FF">type</font> Index_Record (Storage : 
<font color="#0000FF">access</font> File_Storage) <font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new</font> Backward_Link <font color="#0000FF">with<br>
&nbsp;&nbsp;
record</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;
ID : Key;<font color="#008000"> -- Object identifier</font><br>
&nbsp;&nbsp; <font color="#0000FF">end record</font>;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font>&nbsp;Index_Record_Ptr&nbsp;<font color="#0000FF">is&nbsp;access&nbsp;all</font>&nbsp;Index_Record'Class;<br>
<font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Implementation of Backward_Link's operation<br>
&nbsp;&nbsp;
--<br>
&nbsp;&nbsp; </font><font color="#0000FF">procedure</font> Deleted<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Link&nbsp; : <font color="#0000FF">in out </font>Index_Record;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Temps : <font color="#0000FF">in out</font> Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
); <br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Destroyed (Link : 
<font color="#0000FF">in out</font> Index_Record);</tt></TD>
  </TR>
</TABLE>

<p>A File_Storage object encapsulates the file and an index of all  memory resident objects from that file. The index consists of Index_Records. One 
record is allocated per memory resident object. Index_Record is derived from
<a href="#Backward_Link">Backward_Link</a> to monitor what happens with the 
object. It also contains the object's key in the file. Two operations of
<a href="#Backward_Link">Backward_Link</a> need to be implemented:
<a href="#Object.Archived.Deleted">Deleted</a> and
<a href="#Object.Archived.Destroyed">Destroyed</a>. The implementation of
<a href="#Object.Archived.Deleted">Deleted</a> is called upon a request of 
object deletion. It does nothing in our case.
<a href="#Object.Archived.Destroyed">Destroyed</a> is called when the object is 
about to be finalized. In our case we store that object into the file. A more 
advanced implementation would check if the object was modified. It could also 
check if the object was requested for deletion and is no more referenced from 
other objects, in which case it can be removed from the persistent storage as 
well. But 
that would be too complex for a small illustrative example.</p>

File <EM>test_persistent_file_storage.ads</EM> (continued, the private part):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Record_Handles -- Handles to index records<br>
&nbsp;&nbsp;
--<br>
</font>&nbsp;&nbsp; <font color="#0000FF">package</font> Record_Handles
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new</font> Object.Handle (Index_Record, Index_Record_Ptr);<br>
&nbsp;&nbsp; <font color="#0000FF">use</font> Record_Handles;<br>
&nbsp;&nbsp; <font color="#0000FF">subtype</font> Record_Handle
<font color="#0000FF">is</font> Record_Handles.Handle;<br>
&nbsp;<font color="#008000">&nbsp; --<br>
&nbsp;&nbsp; -- Map : object pointer -&gt; record handle<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font>&nbsp;&quot;<font color="#FF0000">&lt;</font>&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;Deposit_Ptr)&nbsp;<font color="#0000FF">return</font>&nbsp;Boolean;<br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Object_Maps<font color="#0000FF"> 
is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new</font> Generic_Map<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Key_Type&nbsp;&nbsp;&nbsp; 
=&gt; Deposit_Ptr,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Object_Type =&gt; Record_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp; <font color="#0000FF">use</font> Object_Maps;<br>
&nbsp;&nbsp; <font color="#0000FF">subtype</font> Object_Map
<font color="#0000FF">is</font> Object_Maps.Map;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Map : object key -&gt; record handle<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">package</font> Key_Maps
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new </font>Generic_Map<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Key_Type&nbsp;&nbsp;&nbsp; 
=&gt; Key,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Object_Type =&gt; Record_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp; <font color="#0000FF">use</font> Key_Maps;<br>
&nbsp;&nbsp; <font color="#0000FF">subtype</font> Key_Map <font color="#0000FF">
is</font> Key_Maps.Map;</tt></TD>
  </TR>
</TABLE>

<p>To reference Index_Record we will use handles provided by  Record_Handles, an instantiation of <a href="#Object.Handle">Object.Handle</a>. A handle to 
Index_Record is &quot;renamed&quot; to Record_Handle. Then we declare two maps: 
one to map objects 
to index records, another to map keys to the records. For this the package
<a href="#Generic_Map">Generic_Map</a> is instantiated once as Object_Maps and 
once as Key_Maps. Both use Record_Handle to reference Index_Record. So when the 
index record is deleted it is enough to remove it from the both maps and the 
object Index_Record will be automatically collected. Note also that Object_Map 
uses <a href="#Object.Archived.Deposit_Ptr">Deposit_Ptr</a>, a pointer to the 
persistent object rather than a handle to it. It is important to allow object 
deletion. Otherwise an object would be never deleted as long as Index_Record 
referring it exists, i.e. up to File_Storage finalization. It would a thinkable, 
but too crude implementation.
<a href="#Generic_Map">Generic_Map</a> requires map keys be comparable, so the 
implementation declares &quot;<font color="#FF0000">&lt;</font>&quot; on <a href="#Object.Archived.Deposit_Ptr">Deposit_Ptr</a>.</p>

File <EM>test_persistent_file_storage.ads</EM> (continued, the private part):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- File record<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font>&nbsp;Reference_List<font color="#0000FF">&nbsp;is&nbsp;array</font>&nbsp;(Integer&nbsp;<font color="#0000FF">range</font>&nbsp;<font color="#1100000">1</font>..<font color="#1100000">256</font>)&nbsp;<font color="#0000FF">of</font>&nbsp;Key;<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> File_Record <font color="#0000FF">
is record</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length&nbsp;&nbsp;&nbsp;&nbsp; : Natural :=
<font color="#1100000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Natural :=
<font color="#1100000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; References : Reference_List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Descriptor : String (<font color="#1100000">1</font>..<font color="#1100000">1024</font>);<br>
&nbsp;&nbsp; <font color="#0000FF">end record</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Record_Files
<font color="#0000FF">is new </font>Ada.Direct_IO (File_Record);<br>
&nbsp;&nbsp; <font color="#0000FF">use</font> Record_Files;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- File_Storage -- Implementation<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">type</font> File_Storage
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new</font> Ada.Finalization.Limited_Controlled
<font color="#0000FF">with<br>
&nbsp;&nbsp; record</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: File_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object_To_Record : Object_Map;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Key_To_Record&nbsp;&nbsp;&nbsp; : Key_Map;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Last_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Key := <font color="#1100000">0</font>;<font color="#008000"> -- Last used 
object key</font><br>
&nbsp;&nbsp; <font color="#0000FF">end record</font>;<br>
<br>
<font color="#0000FF">end</font> Test_Persistent_File_Storage;</tt></TD>
  </TR>
</TABLE>

<p>The type File_Record describes one record in the file. The field References 
is the list of the keys of all the objects referred by the object. Count is the 
length of the list. The field Descriptor is a string describing the object. The 
length of the string is the field Length.</p>

File <EM>test_persistent_file_storage.adb</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> 
Object.Archived.Lists; <font color="#0000FF">&nbsp;use</font> 
Object.Archived.Lists;<br>
<font color="#0000FF">with</font> Strings_Edit;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font> Strings_Edit;<br>
<br>
<font color="#0000FF">package body </font>Test_Persistent_File_Storage
<font color="#0000FF">is</font><br>
<br>
<font color="#0000FF">&nbsp;&nbsp;&nbsp;function</font>&nbsp;&quot;<font color="#FF0000">&lt;</font>&quot;&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;Deposit_Ptr)&nbsp;<font color="#0000FF">return</font>&nbsp;Boolean&nbsp;<font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</font> Right = <font color="#0000FF">null then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</font> False;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">elsif</font> Left =
<font color="#0000FF">null then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return </font>True;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return </font>Less (Left.<font color="#0000FF">all</font>, 
Right.<font color="#0000FF">all</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> &quot;<font color="#FF0000">&lt;</font>&quot;;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Clean_Up
<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
File : File_Type;<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Create (File, Out_File, &quot;<font color="#FF0000">test.dat</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Close (File);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Clean_Up;</tt></TD>
  </TR>
</TABLE>

<p>The implementation of &quot;<font color="#FF0000">&lt;</font>&quot; uses
<a href="#Object.Less">Less</a> defined on objects to order them. Clean_Up opens 
the file in Out_File mode and immediately closes it. This erases the file.</p>

File <EM>test_persistent_file_storage.adb</EM> (continued):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Write<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Storage : <font color="#0000FF">in out</font> File_Storage;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp; : Deposit'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Key<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
References&nbsp; : Deposit_List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Data_Record : File_Record;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer&nbsp;&nbsp;&nbsp;&nbsp; : Integer := Data_Record.Descriptor'First;<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Get_Referents (Object, References);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Data_Record.Count := Get_Size (References);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">for</font> Item 
<font color="#0000FF">in</font> <font color="#1100000">1</font>..Data_Record.Count
<font color="#0000FF">loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Data_Record.References (Item) :=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Store (Storage'<font color="#0000FF">Access</font>, Ref (References, Item));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put&nbsp;(Data_Record.Descriptor,&nbsp;Pointer,&nbsp;Get_Class&nbsp;(Object));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Put (Data_Record.Descriptor, Pointer, &quot;<font color="#FF0000">:</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Store (Data_Record.Descriptor, Pointer, Object);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Data_Record.Length := Pointer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Write (Storage.File, Data_Record, Count (ID));<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Write;</tt></TD>
  </TR>
</TABLE>

<p>The procedure Write is defined to store an object under the specified key. It 
calls to <a href="#Object.Archived.Get_Referents">Get_Referents</a> to obtain 
the list of the objects the stored object needs. Then for each such object it 
calls Store to ensure the object persistency in the file. The keys returned by 
Store are placed into the References array. After that Write starts to form the 
field Description. It places the object class there (<a href="#Object.Archived.Get_Class">Get_Class</a>) 
followed by a colon. Then object's <a href="#Object.Archived.Store">Store</a> is 
called to query the object description and to add it to Description. The 
completed object record is then written into the file.</p>

File <EM>test_persistent_file_storage.adb</EM> (continued):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Initialize (Storage : 
<font color="#0000FF">in out </font>File_Storage) <font color="#0000FF">is<br>
&nbsp;&nbsp;
begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open (Storage.File, Inout_File, &quot;<font color="#FF0000">test.dat</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Storage.Last_ID := Key (Size (Storage.File));<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Initialize;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Finalize (Storage : 
<font color="#0000FF">in out</font> File_Storage) <font color="#0000FF">is<br>
&nbsp;&nbsp;
begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
while not </font>Is_Empty (Storage.Key_To_Record) <font color="#0000FF">loop<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
declare</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index_Item : Index_Record <font color="#0000FF">renames</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ptr&nbsp;(Get&nbsp;(Storage.Key_To_Record,&nbsp;Integer'(<font color="#1100000">1</font>))).<font color="#0000FF">all</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write&nbsp;(Storage,&nbsp;This&nbsp;(Index_Item).<font color="#0000FF">all</font>,&nbsp;Index_Item.ID);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remove (Storage.Key_To_Record, 
Integer'(<font color="#1100000">1</font>));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remove (Storage.Object_To_Record,
<font color="#1100000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Close (Storage.File);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Finalize;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Bind<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Storage : <font color="#0000FF">access</font> File_Storage;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp; : Deposit_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Key<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Link_Ptr&nbsp;&nbsp; : Backward_Link_Ptr := <font color="#0000FF">new</font> Index_Record (Storage);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index_Item&nbsp;:&nbsp;Index_Record&nbsp;<font color="#0000FF">renames</font>&nbsp;Index_Record (Link_Ptr.<font color="#0000FF">all</font>);<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index_Item.ID := ID;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Attach (Link_Ptr, Ptr (Object));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Add<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Storage.Object_To_Record,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Ptr (Object),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Ref (Index_Item'Unchecked_Access)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Add<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Storage.Key_To_Record, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ID,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Ref (Index_Item'Unchecked_Access)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Bind;</tt></TD>
  </TR>
</TABLE>

<p>The implementation of Initialize just opens the file for input / output and 
initializes the field Last_ID. Finalize goes through the index of memory 
resident objects (the key to object map). For each record of the index it 
calls Write to store the corresponding object and then removes the references to 
the index record from both maps. This in turn deletes the record itself. Note 
how <a href="#Object.Archived.This">This</a> is used to get the object. The 
procedure Bind is defined to create an index record. It calls to
<a href="#Object.Archived.Attach">Attach</a> to bind Index_Record with the 
object and places handles to Index_Record in each of the maps.
<a href="#Object.Handle.Ref">Ref</a> is used to obtain them</p>

File <EM>test_persistent_file_storage.adb</EM> (continued):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">&nbsp;&nbsp;
function</font> Store<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Storage : access File_Storage;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp; : Deposit_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">return</font> Key <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This : Deposit_Ptr := Ptr (Object);<br>
&nbsp;&nbsp; <font color="#0000FF">begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;</font>This&nbsp;=&nbsp;<font color="#0000FF">null&nbsp;or&nbsp;else&nbsp;not</font>&nbsp;Is_In&nbsp;(Storage.Object_To_Record,&nbsp;This)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Storage.Last_ID := Storage.Last_ID + <font color="#1100000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Bind (Storage, Object, Storage.Last_ID);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Storage.Last_ID;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return</font> Ptr (Get (Storage.Object_To_Record, This)).ID;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Store;</tt></TD>
  </TR>
</TABLE>

<p>The implementation of Store first looks into the index 
to check if it is already there. If yes it returns the key of the object. 
Otherwise it generates a new key by incrementing the field Last_ID and calls 
Bind to create a new index record.</p>

File <EM>test_persistent_file_storage.adb</EM> (continued):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">function</font> Restore (Storage : 
<font color="#0000FF">access</font> File_Storage; ID : Key)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Deposit_Handle i<font color="#0000FF">s<br>
&nbsp;&nbsp;
begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Is_In (Storage.Key_To_Record, ID) 
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font>&nbsp;Ref&nbsp;(This&nbsp;(Ptr&nbsp;(Get&nbsp;(Storage.Key_To_Record,&nbsp;ID)).<font color="#0000FF">all</font>));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else</font><br>
<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- Read the object from the file<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
--</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">declare</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Data&nbsp;&nbsp;&nbsp; : File_Record;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
List&nbsp;&nbsp;&nbsp; : Deposit_List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp; : Deposit_Ptr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Result&nbsp; : Deposit_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer : Positive;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Read (Storage.File, Data, Count (ID));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">for</font> No <font color="#0000FF">in</font>
<font color="#1100000">1</font>..Data.Count <font color="#0000FF">loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Add (List, Restore (Storage, Data.References (No)));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer := Data.Descriptor'First;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">while</font> Data.Descriptor (Pointer) /= '<font color="#FF0000">:</font>' 
<font color="#0000FF">loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer := Pointer + <font color="#1100000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer := Pointer + <font color="#1100000">1</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Create<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Data.Descriptor,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Data.Descriptor (Data.Descriptor'First..Pointer - <font color="#1100000">2</font>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
List,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Result := Ref (Object);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Bind (Storage, Result, ID);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">return</font> Result;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Restore;</tt></TD>
  </TR>
</TABLE>

<p>The procedure Restore checks the index if an object with 
the specified key was already created. If yes it returns a handle to the object.
<a href="#Object.Archived.This">This</a> is used to get an object pointer from 
Index_Record. When the key identifies an unknown object, Restore reads its 
record from the file. The key is the record number. Restore goes through the array 
References and for each key calls itself to ensure this object to be 
restored too. The returned handle to that object is placed in a
<a href="#Deposit_List">Deposit_List</a> container. The container together with 
Descriptor's prefix (up to the first colon) as object's class name and the rest 
of it as the object's description, are passed to
<a href="#Object.Archived.Create">Create</a>. That creates the object. A handle 
to it is then returned after Bind is called to place the object into the storage 
index.</p>

File <EM>test_persistent_file_storage.adb</EM> (continued):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Deleted<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Link&nbsp; : <font color="#0000FF">in out </font>Index_Record;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Temps : <font color="#0000FF">in out </font>Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is<br>
&nbsp;&nbsp;
begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
null</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Deleted;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Destroyed (Link : 
<font color="#0000FF">in out</font> Index_Record) <font color="#0000FF">is<br>
&nbsp;&nbsp;
begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Write (Link.Storage.all, This (Link).<font color="#0000FF">all</font>, Link.ID);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove&nbsp;(Link.Storage.Object_To_Record,&nbsp;This (Link));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Remove (Link.Storage.Key_To_Record, Link.ID);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Destroyed;<br>
<br>
<font color="#0000FF">end</font> Test_Persistent_File_Storage;</tt></TD>
  </TR>
</TABLE>

<p>The implementation of <a href="#Object.Archived.Deleted">Deleted</a> does 
nothing. <a href="#Object.Archived.Destroyed">Destroyed</a> writes the object 
into the file and then removes it from the index.</p>

<H4>2.4.2. Persistent objects implementation</H4>

<p>Let's take binary tree node as an example of persistent object. A node may 
have up to two successors or none. Predecessor - successor relation is naturally 
mapped to dependant - referent.</p>

<a name="test_persistent_tree"></a>

File <EM>test_persistent_tree.ads</EM>:<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> Object.Archived; 
<font color="#0000FF">&nbsp;use</font> 
Object.Archived;<br>
<font color="#0000FF">with</font> Deposit_Handles; <font color="#0000FF">&nbsp;use</font> Deposit_Handles;<br>
<br>
<font color="#0000FF">package</font> Test_Persistent_Tree <font color="#0000FF">is</font><br>
&nbsp;<font color="#008000">&nbsp;
--<br>
&nbsp;&nbsp;
-- Nothing -- No node handle<br>
&nbsp;&nbsp;
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Nothing <font color="#0000FF">return</font> Handle;<br>
<font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Create_Node -- This function creates a new node<br>
&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Field - Identifies the node<br>
&nbsp;&nbsp;
-- Left&nbsp; - Successor on the left (a handle to)<br>
&nbsp;&nbsp;
-- Right - Successor on the right (a handle to)<br>
&nbsp;&nbsp;
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Field : Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Left&nbsp; : Handle := Nothing;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Right : Handle := Nothing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">return</font> Handle;<br>
<font color="#008000">&nbsp;&nbsp;
-- <br>
&nbsp;&nbsp;
-- Print -- Prints the tree rooted in a node<br>
&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
--&nbsp;&nbsp;&nbsp; Root - The root node (a handle to)<br>
&nbsp;&nbsp;
--<br>
</font>&nbsp;&nbsp;&nbsp;<font color="#0000FF">procedure</font>&nbsp;Print&nbsp;(Root&nbsp;:&nbsp;Handle;&nbsp;Indentation&nbsp;:&nbsp;String&nbsp;:=&nbsp;&quot;&quot;);<br>
<br>
<font color="#0000FF">private</font><br>
<font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Node -- Binary tree node type<br>
&nbsp;&nbsp;
--<br>
</font>&nbsp;&nbsp; <font color="#0000FF">type</font> Node<font color="#0000FF"> is new</font> Deposit 
<font color="#0000FF">with record</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Field : Integer; <font color="#008000">-- Node identifier</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Left&nbsp; : Handle;&nbsp; <font color="#008000">-- Left successor, a handle to</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Right : Handle;&nbsp; <font color="#008000">-- Right successor, a handle to</font><br>
&nbsp;&nbsp; <font color="#0000FF">end record</font>;<br>
<font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Implementation of Deposit's operations<br>
&nbsp;&nbsp;
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Get_Class (Object : Node) 
<font color="#0000FF">return</font> String;<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Get_Referents<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Object&nbsp;&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Container : <font color="#0000FF">in out</font> Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Is_Modified (Object : Node) 
<font color="#0000FF">return</font> Boolean;<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Reset_Modified (Object : 
<font color="#0000FF">in out </font>Node);<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Restore<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Source&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer : <font color="#0000FF">in out </font>Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Class&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
List&nbsp;&nbsp;&nbsp; : Deposit_Container'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp; : <font color="#0000FF">out</font> Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Store<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Destination : <font color="#0000FF">in out </font>String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Pointer&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out </font>Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
<font color="#0000FF">end</font> Test_Persistent_Tree;</tt></TD>
  </TR>
</TABLE>

<p>The public part of the package declares the function Create_Node and the 
procedure Print. Create_Node creates a new node and returns a handle to it. All 
nodes are referenced using <a href="#Object.Archived.Handle.Handle">Handle</a> 
of <a href="#Deposit_Handles">Deposit_Handles</a>. Each node is identified by an 
integer number. The next two parameters of Create_Node are the handles to the 
left and right successors. They are defaulted to an invalid handle for which the 
function Nothing is also declared. It plays role of a constant invalid handle. The 
procedure Print is used for control.&nbsp; It prints the tree rooted in the node specified 
by the parameter Root.</p>

<p>The private part is straightforward. It declares the type Node as a 
descendant of <a href="#Deposit">Deposit</a>. The operations
<a href="#Object.Archived.Get_Class">Get_Class</a>,
<a href="#Object.Archived.Get_Referents">Get_Referents</a>,
<a href="#Object.Archived.Is_Modified">Is_Modified</a>,
<a href="#Object.Archived.Reset_Modified">Reset_Modified</a>,
<a href="#Object.Archived.Restore">Restore</a> and
<a href="#Object.Archived.Store">Store</a> are overridden to provide  implementations.</p>

File <EM>test_persistent_tree.adb</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> Ada.Text_IO;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font> Ada.Text_IO;<br>
<font color="#0000FF">with</font> Strings_Edit;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font> Strings_Edit;<br>
<font color="#0000FF">with</font> Strings_Edit.Integers;&nbsp;
<font color="#0000FF">use</font> Strings_Edit.Integers;<br>
<br>
<font color="#0000FF">package body </font>Test_Persistent_Tree
<font color="#0000FF">is</font><br>
&nbsp;&nbsp; Class : <font color="#0000FF">constant</font> String := &quot;<font color="#FF0000">Node</font>&quot;;<font color="#008000"> 
-- The class of </font><br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Nothing <font color="#0000FF">
return</font> Handle <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; None : Handle;<br>
&nbsp;&nbsp; <font color="#0000FF">begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</font> None;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Nothing;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Field 
: Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Left&nbsp; : Handle := Nothing;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Right : Handle := Nothing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; 
return Handle is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node_Ptr : Deposit_Ptr := <font color="#0000FF">
new</font> Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object&nbsp;&nbsp; : Node <font color="#0000FF">
renames</font> Node (Node_Ptr.<font color="#0000FF">all</font>);<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object.Field := Field;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object.Left&nbsp; := Left;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object.Right := Right;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Ref (Node_Ptr);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Create_Node;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Get_Class (Object : Node)
<font color="#0000FF">return</font> String <font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</font> Class;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Get_Class;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Get_Referents<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Object&nbsp;&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Container : <font color="#0000FF">in out</font> Deposit_Container'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; 
is<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Is_Valid (Object.Left)
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add (Container, Object.Left);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Is_Valid (Object.Right)
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add (Container, Object.Right);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Get_Referents;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Is_Modified (Object : Node)
<font color="#0000FF">return</font> Boolean i<font color="#0000FF">s<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;</font>True;<font color="#008000">&nbsp;--&nbsp;Save&nbsp;it&nbsp;always,&nbsp;do&nbsp;not&nbsp;care&nbsp;about&nbsp;performance</font><br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Is_Modified;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Reset_Modified (Object :
<font color="#0000FF">in out</font> Node) <font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Reset_Modified;</tt></TD>
  </TR>
</TABLE>

<p>The implementation of
<a href="#Object.Archived.Get_Referents">Get_Referents</a> places handles to the 
node successors into a <a href="#Deposit_Container">Deposit_Container</a>. The 
left successor is placed first.
<a href="#Object.Archived.Is_Modified">Is_Modified</a> and
<a href="#Object.Archived.Reset_Modified">Reset_Modified</a> are void for sake 
of simplicity. So a node is always written into the persistent storage even if 
it is not changed.</p>

File <EM>test_persistent_tree.adb</EM> (continued):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Restore<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Source&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Pointer : <font color="#0000FF">in out </font>Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Class&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Deposit_Container'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Object&nbsp; : <font color="#0000FF">out</font> Deposit_Ptr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; 
is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Field : Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left&nbsp; : Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right : Handle;<br>
&nbsp;&nbsp; <font color="#0000FF">begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if </font>Source (Pointer) = '<font color="#FF0000">&lt;</font>' 
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left := Ref (List, 
<font color="#1100000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Source (Pointer +
<font color="#1100000">1</font>) = '<font color="#FF0000">&gt;</font>' 
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right := Ref 
(List, <font color="#1100000">2</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">elsif</font> Source (Pointer + 
<font color="#1100000">1</font>) = '<font color="#FF0000">&gt;</font>' 
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right := Ref (List, 
<font color="#1100000">1</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer := Pointer + <font color="#1100000">2</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get (Source, Pointer, Field);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object := <font color="#0000FF">new</font> Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">declare</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item : Node 
<font color="#0000FF">renames</font> Node (Object.<font color="#0000FF">all</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item.Field := Field;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item.Left&nbsp; := Left;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Item.Right := Right;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when others </font>=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">raise</font> Data_Error;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Restore;</tt></TD>
  </TR>
</TABLE>

<p>The implementation of <a href="#Object.Archived.Restore">Restore</a> first 
gets  description of node dependencies from the source string. It is two 
characters. The first one is either '&lt;' if there is a left successor or '-' 
otherwise. The second is '&gt;' if there is a right successor or else '-'. After 
that it gets the node identifier (plain integer number). Then a new node object 
is allocated. Note that the target access type should be
<a href="#Object.Archived.Deposit_Ptr">Deposit_Ptr</a> to ensure right storage 
pool selection.</p>

File <EM>test_persistent_tree.adb</EM> (continued):
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Store<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Destination : <font color="#0000FF">in out</font> String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Pointer&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; 
<font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if </font>Is_Valid (Object.Left)
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (Destination, Pointer, 
&quot;<font color="#FF0000">&lt;</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (Destination, Pointer, 
&quot;<font color="#FF0000">-</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Is_Valid (Object.Right) 
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (Destination, Pointer, 
&quot;<font color="#FF0000">&gt;</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (Destination, Pointer, 
&quot;<font color="#FF0000">-</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (Destination, Pointer, Object.Field);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Store;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Print (Root : Handle; Indentation : String := &quot;&quot;)<font color="#0000FF"> is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if </font>Is_Valid (Root) <font color="#0000FF">then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; declare</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The_Node : 
Node <font color="#0000FF">renames</font> Node (Ptr (Root).<font color="#0000FF">all</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put_Line 
(Indentation &amp; &quot;<font color="#FF0000">\_</font>&quot; &amp; Image (The_Node.Field));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print (The_Node.Left, 
Indentation &amp; &quot;<font color="#FF0000"> |</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print (The_Node.Right, 
Indentation &amp; &quot;<font color="#FF0000"> </font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put_Line (Indentation &amp; &quot;<font color="#FF0000">\_*</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Print;<br>
<br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp; Register_Class (Class, Restore'<font color="#0000FF">Access</font>);<br>
<font color="#0000FF">end</font> Test_Persistent_Tree;</tt></TD>
  </TR>
</TABLE>

<p>The procedure <a href="#Object.Archived.Store">Store</a> is reverse to
<a href="#Object.Archived.Restore">Restore</a>. Also the package defines a new class of persistent objects named <i>Node</i>. 
For this it calls Register_Class once upon elaboration with the class name and a 
pointer to <a href="#Object.Archived.Restore">Restore</a> as parameters. </p>

<H4>2.4.3. Test program</H4>
<p>The test program is shown below. It consists of two sessions. In the first 
session an object is stored. In the second one it is restored.</p>
<a name="test_persistent_storage"></a>
File <EM>test_persistent_storage.adb</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> Ada.Text_IO;
<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
use</font> Ada.Text_IO;<br>
<font color="#0000FF">with</font>&nbsp;Test_Persistent_File_Storage;<font color="#0000FF">&nbsp;&nbsp;use</font>&nbsp;Test_Persistent_File_Storage;<br>
<font color="#0000FF">with</font> Test_Persistent_Tree; <font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
use</font> Test_Persistent_Tree;<br>
<font color="#0000FF">with</font> Deposit_Handles; <font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
use</font> Deposit_Handles;<br>
<br>
<font color="#0000FF">procedure</font> Test_Persistent_Storage
<font color="#0000FF">is</font><br>
&nbsp;&nbsp; Root_Key : Key;<br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp; Clean_Up;<br>
&nbsp;&nbsp; Put_Line (&quot;<font color="#FF0000">Session 1</font>&quot;);<br>
&nbsp;&nbsp; <font color="#0000FF">declare</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp;&nbsp; : <font color="#0000FF">aliased</font> 
File_Storage;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root : Handle;<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root :=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <font color="#1100000">1</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create_Node (<font color="#1100000">2</font>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;
<font color="#1100000">3</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(&nbsp; <font color="#1100000">4</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Create_Node (<font color="#1100000">5</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Create_Node (<font color="#1100000">6</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print (Root);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root_Key := Store (DB'<font color="#0000FF">Access</font>, 
Root);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp; Put_Line (&quot;<font color="#FF0000">Session 2</font>&quot;);<br>
&nbsp;&nbsp; <font color="#0000FF">declare</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp;&nbsp; : <font color="#0000FF">aliased</font> 
File_Storage;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root : Handle;<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root := Restore (DB'<font color="#0000FF">Access</font>, 
Root_Key);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print (Root);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
<font color="#0000FF">end</font> Test_Persistent_Storage;</tt></TD>
  </TR>
</TABLE>
<p>The test program first calls Clean_Up to delete any existing storage file. 
Then it declares DB, a File_Storage object. After that a tree is created and Root 
becomes a handle to the tree root node. The tree is printed and then its root 
node is stored into DB. There result of the operation is the external key of the 
root node. This key can be used to restore the object. Note that the whole tree 
is stored because the any node depends on its child nodes. What Store does 
depends on the implementation. In our case physical file writing happens either 
upon finalization of the storage object (DB) or upon finalization of the 
persistent object (Root). Both objects are go out of scope at
<font color="#0000FF">end</font> closing the first session. The second session 
uses Restore and the external key to bring the root node back from the storage. 
Again, all the objects it depends on are restored as well. Finally, the restored 
tree is printed.</p>

<H4>2.4.4. Test programs that use a predefined persistent storage</H4>
<p>The test program that uses an ODBC data base as a persistent storage is shown
below:</p>
<a name="test_ODBC_persistence"></a>
File <EM>test_ODBC_persistence.adb</EM>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> Ada.Text_IO;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <font color="#0000FF">use</font> Ada.Text_IO;<br>
  <font color="#0000FF">with</font> Deposit_Handles;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <font color="#0000FF">use</font> Deposit_Handles;&nbsp;<br>
  <font color="#0000FF">with</font> Persistent.Handle;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">use</font>
  Persistent.Handle;<br>
  <font color="#0000FF">with</font>&nbsp;Test_Persistent_Tree;&nbsp;&nbsp;<font color="#0000FF">use</font>&nbsp;Test_Persistent_Tree;<br>
  <font color="#0000FF">with</font> Test_ODBC_Session;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">use</font>
  Test_ODBC_Session;<br>
  <br>
  <font color="#0000FF">procedure</font> Test_ODBC_Persistence <font color="#0000FF"> is</font><br>
  &nbsp;&nbsp; Name : <font color="#0000FF">constant</font> String := &quot;<font color="#FF0000">The
  tree</font>&quot;;<br>
  <font color="#0000FF">begin</font><br>
  &nbsp;&nbsp; Put_Line (&quot;<font color="#FF0000">Session 1</font>&quot;);<br>
  &nbsp;&nbsp; <font color="#0000FF">declare</font><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp;&nbsp; : Storage_Handle := Open;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root : Handle;<br>
  &nbsp;&nbsp; <font color="#0000FF">begin</font><br>
  </tt><tt>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root :=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <font color="#1100000">1</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create_Node (<font color="#1100000">2</font>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;
<font color="#1100000">3</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Create_Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(&nbsp; <font color="#1100000">4</font>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Create_Node (<font color="#1100000">5</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Create_Node (<font color="#1100000">6</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print (Root);<br>
  </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (DB, Root, Name);<br>
  &nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
  &nbsp;&nbsp; Put_Line (&quot;<font color="#FF0000">Session 2</font>&quot;);<br>
  &nbsp;&nbsp; <font color="#0000FF">declare</font><br>
  &nbsp;&nbsp;&nbsp;&nbsp; DB&nbsp;&nbsp; : Storage_Handle := Open;<br>
  &nbsp;&nbsp;&nbsp;&nbsp; Root : Handle;<br>
  &nbsp;&nbsp; <font color="#0000FF">begin</font><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Root := Get (DB, Name);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Print (Root);<br>
  &nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
  <font color="#0000FF">end</font> Test_APQ_Persistence;</tt></TD>
  </TR>
</TABLE>
<p> 
Then it declares DB, a <a href="#Persistent.Handle.Storage_Handle">Storage_Handle</a>.
The handle is initialized using the function Open defined in <i>Test_ODBC_Session.adb</i>.
It prompts for connection parameters and then calls <a href="#Persistent.ODBC.Create">Persistent.ODBC.Create</a>.
After that a tree is created and Root 
becomes a handle to the tree root node. The tree is printed and then its root 
node is stored into DB as &quot;<i>The three</i>&quot;. For this it calls <a href="#Persistent.Handle.Put">Put</a>.
Note that the whole tree 
is stored because the any node depends on its child nodes. The second session 
uses <a href="#Persistent.Handle.Get">Get</a> and the name &quot;<i>The three</i>&quot;
to bring the root node back from the storage. 
Again, all the objects it depends on are restored as well. Finally, the restored 
tree is printed. Carefully observe that the package Test_Persistent_Tree needed
no modifications to be able to work with a different type of storage.</p>
<p>A the test program for APQ data base can be found in the file <EM>test_APQ_persistence.adb</EM>.</p>

<p align="right">
  <a href="#1.5" name="2.5"></a><a href="#2.4"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.6"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.5. Abstract persistent storage</H3>
<p><a name="Persistent"></a><a name="Storage_Object"></a><a name="persistent_storage"></a>The package <a href="#Persistent"> Persistent</a> provides an
abstract persistent storage communication object. The corresponding persistent
storage can be implemented on the basis of a plain file, data base etc. Objects in the storage are identified by their names. Additionally anonymous  objects  can be created and deleted as required by the named  ones.
If an  object depends on some other objects,  then  when  stored  into  the  storage,  the  referred  objects  are  stored as well.
If they do not  already persist there, these objects will be anonymous.  Anonymous persistent objects are subject of garbage collection.  The  way of collection is determined by the implementation.</p>
<p>The objects can be named. The object names are UTF-8 encoded strings. An&nbsp; 
implementation can internally provide other encoding when the persistent storage 
natively supports Unicode different to UTF-8. Named objects  are  deleted only on 
explicit request or when they loose names becoming anonymous. Named objects 
build a hierarchy, where one named object can be a descendant of another. This 
hierarchy is a forest. The parent objects serve as folders for their children. 
It is not specified which nature parent objects should have. Objects of any kind 
can serve as parents. Also the parent-child relation does not impose any 
additional dependency between the objects. It is a relation solely between the 
names of.</p>
<p>The procedure <a href="#Object.Archived.Handle.Delete">Delete</a> can be  applied to 
a handle to the object in order to request its deletion. If  the  object  cannot  be  deleted
immediately it becomes anonymous for later  collection.  Persistent  storage  interfaces  are itself objects and are a subject of garbage  collection  as  well. 
When a named parent object becomes anonymous all its descendants do as well.</p>

<p>The package defines the abstract type <a href="#Storage_Object"> Storage_Object</a>
which describes the interface of a persistent storage communication object. It
is derived from <a href="#Entity">Entity</a>, so persistent storage interface
objects are subject of garbage collection:</p>

<blockquote>
  <p><tt><font color="#0000FF">   type </font> Storage_Object<font color="#0000FF"> is abstract new
  </font> Object.Entity<font color="#0000FF"> with private</font>;<font color="#0000FF"><br>
   type </font> Storage_Object_Ptr<font color="#0000FF"> is access </font> Storage_Object'Class;<font color="#0000FF"><br>
   for </font> Storage_Object_Ptr'Storage_Pool<font color="#0000FF"><br>
  &nbsp;&nbsp; use </font> Object.Entity_Ptr'Storage_Pool;</tt></p>

</blockquote>
<p>It is strongly recommended not to directly use derivatives of <a href="#Storage_Object"> Storage_Object</a>.
For this purpose serve <a href="#Persistent.Handle">handles to the objects</a>.</p>

<p><a name="Persistent.Deposit_Handle"></a>The subtype <a href="#Persistent.Deposit_Handle">Deposit_Handle</a>
is provided for convenience in referring persistent objects. It
&quot;renames&quot; the handle type of the package <a href="#Deposit_Handles">Deposit_Handles</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">subtype </font> Deposit_Handle <font color="#0000FF"> is</font> 
  Deposit_Handles.Handle;</tt></p>

</blockquote>

<p>The root-level objects have no parent. When a subprogram requires a parent 
specification the constant Root_Directory is used:</p>

<blockquote>
  <p><tt>Root_Directory : <font color="#0000FF">constant</font> Deposit_Handle;</tt></p>

</blockquote>
<p><a name="Persistent.Catalogue"></a>The package instantiates <a href="#Generic_Set">Generic_Set</a>
to obtain sets of object names.</p>

<blockquote>
  <p><tt><font color="#0000FF">package </font> Catalogue<font color="#0000FF"> is<br>
  &nbsp;&nbsp;      new </font> Generic_Set<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          (&nbsp; Object_Type&nbsp;  =>
  Unbounded_String,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Null_Element => Null_Unbounded_String<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          );</tt></p>

</blockquote>
<p>The following operations are defined on <a href="#Storage_Object"> Storage_Object</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">function</font> Get<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Deposit_Handle<font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This function returns a <a href="#Persistent.Deposit_Handle">  handle</a>  to  a  persistent  object
by its name and a <a href="#Persistent.Deposit_Handle">  handle</a>  to the 
parent object. The root-level objects have no parents, in which case <b>Parent</b> 
is an invalid handle. An implementation should first check if  the  the persistent  object  already  has   a   memory-resident   counterpart.
Otherwise it should create one from the persistent storage.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I></CAPTION>
  <TR>
    <TD valign="top">Constraint_Error</TD>
    <TD> The object specified by <b>Parent</b> is not persistent in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD valign="top">Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <tr>
    <TD valign="top">End_Error</TD>
    <TD> No such object</TD>
  </tr>
  <TR>
    <TD valign="top">Use_Error</TD>
    <TD> The class of the object is unknown. This error means that there is no 
	known Ada type yet registered to handle the objects from the persistent 
	storage. Normally Ada types register their classes upon corresponding 
	package elaboration. If the package is not used by the application, its 
	persistent objects cannot be restored.</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function</font> Get_Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font>String<font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This function returns the class of  a  persistent  object
by its name and a <a href="#Persistent.Deposit_Handle">  handle</a> to the 
parent object.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <tr>
    <TD>Constraint_Error</TD>
    <TD> The object specified by <b>Parent</b> is not persistent in <b>Storage</b></TD>
  </tr>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>End_Error</TD>
    <TD> No such object</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Get_List"></a>function </font> Get_List<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> access </font> Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Prefix</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String&nbsp;:= "";<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Suffix</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String&nbsp;:= "";<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Equivalence</b> : Unicode_Mapping_Function := <font color="#0000FF">null</font>;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Catalogue.Set<font color="#0000FF"> is
  abstract</font>;</tt></p>

</blockquote>
<p>This function returns a complete list of all named objects persistent in <b>Storage</b> 
which have parent object specified by the parameter <b>Parent</b>. The list does not include anonymous  persistent  objects, 
which have neither parents nor names. Only names starting with
<b> Prefix</b> and ending with <b> Suffix</b> are returned. When names are 
compared two characters are considered same if their corresponding values 
returned by
<b> Equivalence</b> are same. When Equivalence is null, it is assumed an 
identity mapping. For case insensitive mappings see
<a href="strings_edit.htm#Strings_Edit.UTF8.Mapping">Strings_Edit.UTF8.Mapping</a>.To_Lowercase.
<b> Prefix</b> and <b> Suffix</b> may not overlap when matched.
The list is a <a href="#Persistent.Catalogue">set of object names</a>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <tr>
    <TD>Constraint_Error</TD>
    <TD> The object specified by <b>Parent</b> is not persistent in <b>Storage</b></TD>
  </tr>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  </TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function </font> Get_Name<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access
  </font>Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> String<font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This function returns the object's name in <b>Storage</b>. The object is
specified by its <a href="#Persistent.Deposit_Handle">  handle</a>. Note that 
object names are relative to their parents, so only a pair name - parent does 
identify the object.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle or <b>Object</b> does not persist in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD><b>Object</b> is anonymous</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function </font> Get_Parent<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access
  </font>Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font>Deposit_Handle <font color="#0000FF">is abstract</font>;</tt></p>

</blockquote>
<p>This function returns the object's parent in <b>Storage</b>. The object is
specified by its <a href="#Persistent.Deposit_Handle">  handle</a>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle or <b>Object</b> does not persist in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD><b>Object</b> is anonymous</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function </font>Is_Descendant<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF">
	access </font>Storage_Object;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp; 
	: Deposit_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return </font>Boolean<font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This function checks if <b>Object</b> is a direct or indirect descendant of
<b>Parent</b>. The result is <i><font color="#1100000">false</font></i> if <b>
Object</b> is invalid, or else specifies an anonymous or non-persisting in <b>
Storage</b> object. Otherwise the result is <i><font color="#1100000">true</font></i> 
when <b>Parent</b> is invalid (i.e. identifies root-level objects) and <i>
<font color="#1100000">false</font></i> when <b>Parent</b> does not persist in <b>
Storage</b>. Data_Error is propagated on error in <b>Storage</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF">function </font> Is_In<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access
  </font> Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Boolean<font color="#0000FF"> is abstract</font>;<font color="#0000FF"><br>
  function </font> Is_In<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Boolean<font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>These functions check whether  an  object  persists  in <b>Storage</b>.  The object can be identified either by its name 
and parent or
by a <a href="#Persistent.Deposit_Handle">  handle</a> to  it.  When <b> Object</b> is not a valid handle the result is <i><font color="#1100000">false</font></i>.
</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <tr>
    <TD>Constraint_Error</TD>
    <TD> The object specified by <b>Parent</b> is not persistent in <b>Storage</b></TD>
  </tr>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  </TABLE>
<blockquote>
  <p><tt><font color="#0000FF">function </font> Is_Named<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Boolean<font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>These functions check whether  <b>Object</b>  persists and named  in <b>Storage</b>. 
When <b> Object</b> is not a valid handle the result is <i><font color="#1100000">false</font></i>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  </TABLE>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font> Put<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF"> in out </font> Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : <font color="#0000FF"> in out</font>  Deposit_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp; 
	: String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Parent</b>&nbsp; : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;<font color="#0000FF"><br>
   procedure </font> Put<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF"> in out</font>  Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : <font color="#0000FF"> in out</font> Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>These procedures are used to store <b> Object</b> in <b>Storage</b>. The parameters
<b> Name</b> and <b>Parent</b> specify the object's name and parent in <b>
Storage</b>. When omitted the object is  stored as  anonymous.  Anonymous  persistent  objects are collected when not used,  but  not before 
their memory-resident counterpart vanishes. When
<b> Object</b>  already persists in <b> Storage</b> and <b> Name</b> and <b>
Parent</b> are specified, then they are checked  to  be  same.  If  this  check  fails, 
or
<b>  Name</b>  is empty or illegal, or else conflicts with the name of another object Name_Error  is  propagated. When name is not specified, no check is made.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle, Parent does not persist in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD>Illegal name (such as empty) or name conflict</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font> Rename<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> in out </font> Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Old_Name&nbsp; </b> &nbsp;:
  String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Old_Parent</b> : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>New_Name&nbsp; </b> &nbsp;: String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	New_Parent</b> : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;<font color="#0000FF"><br>
   procedure </font> Rename<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF"> in out </font> Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp;&nbsp; :<font color="#0000FF"> in out </font> Deposit_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>New_Name</b>&nbsp;&nbsp; : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	New_Parent</b> : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>These procedures change the name of the object specified by either its old name
and parent (the parameters <b>Old_Name</b>, <b>Old_Parent</b>) or by a <a href="#Persistent.Deposit_Handle">  handle</a>
to it (the parameter <b>Object</b>). When renamed object was anonymous  before renaming it becomes a named one. When
<b> Object</b> is an invalid handle  or does   not   refer  to a  persistent  object  then Constraint_Error  is propagated.  End_Error is propagated when
<b> Old_Name</b> does not refer any persistent object. No object can become a 
parent of itself, so a check shall be made whether <b>New_Parent</b> specifies 
the object or any of its descendant. If yes, Name_Error is propagated.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD><b>Object</b> is invalid handle or does not refer to any object in <b>Storage</b>.
	<b>New_Parent</b> does not persist in <b>Storage</b>.</TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>End_Error</TD>
    <TD><b>Old_Name</b> indicates no object</TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD>Illegal name (such as empty) or name conflict. The object is an ancestor 
	of its new parent.</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font> Unname<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp; :
  <font color="#0000FF"> in out</font>  Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Name&nbsp; </b>&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	New_Parent</b> : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;<font color="#0000FF"><br>
   procedure </font> Unname<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF"> in out</font>  Storage_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : <font color="#0000FF"> in out </font> Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">  is
  abstract</font>;</tt></p>

</blockquote>
<p>These procedures make  object  anonymous. The object can be specified either
by its name and parent or by a <a href="#Persistent.Deposit_Handle">  handle</a> to it. Unnamed  objects  are automatically  deleted  when  no  more in use. Nothing happens if the object is already unnamed. Nothing also happens if
<b> Object</b> is an invalid <a href="#Persistent.Deposit_Handle">  handle</a>, not a handle to a persistent object or  does  not  exist.  Note  that anonymous  objects  are  not  deleted  as  long  as  they have memory-resident  counterparts.
Observe the difference  between Unname and <a href="#Object.Archived.Handle.Delete">Delete</a>
(<a href="#Object.Archived.Handle.Delete">Object.Archived.Delete</a>) called on an object handle.
<a href="#Object.Archived.Handle.Delete">Delete</a> requests object deletion from both memory  and persistent storage. Unname does it for persistent storage only.  Both  may  have  no immediate effect if the object is still in use.
Note that when a parent object becomes anonymous so all its descendants do.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <tr>
    <TD>Constraint_Error</TD>
    <TD> The object specified by <b>Parent</b> is not persistent in <b>Storage</b></TD>
  </tr>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  </TABLE>

<p align="right">
  <a href="#1.5" name="2.6"></a><a href="#2.5"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.7"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.6. Handles to persistent storage</H3>
<p><a name="Persistent.Handle"></a><a name="Persistent.Handle.Storage_Handle"></a><a name="persistent_storage_handle"></a>A
persistent storage interface is itself an
object, which can be referenced by another object. Usually it is a persistent
object which memory-resident counterpart of is a proxy to the data in the 
persistent storage.
For example, for a large data structure it might be very inefficient to load it
all into the memory. In this case in the memory one would create a small proxy
object, which will query the persistent storage for parts of the object's data as
necessary. Such proxy object will require a reference to its persistent storage.
This also would prevent the persistent storage interface object from premature
destruction. This is why it is strongly recommended to use handles to persistent
storage interface objects.</p>

<p>The package <a href="#Persistent.Handle"> Persistent.Handle</a> provides
the type <a href="#Persistent.Handle.Storage_Handle">Storage_Handle</a>, which
serves as a handle to an abstract persistent storage interface object. It is
guarantied that a persistent storage interface object will not be destroyed as
long at least one handle refers to it.</p>

<blockquote>
  <p><tt><font color="#0000FF">type </font> Storage_Handle<font color="#0000FF"> is
  private</font>;</tt></p>

</blockquote>
<p>The following operations are defined on <a href="#Persistent.Handle.Storage_Handle">Storage_Handle</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Handle.Get"></a>function</font> Get<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : String / Wide_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Deposit_Handle;</tt></p>

</blockquote>
<p>This function searches for the specified object by its name and parent.  The name is an 
UTF-8 encoded string or else a wide string. If  the object  is already available a <a href="#Persistent.Deposit_Handle">  handle</a>
to it is returned. Otherwise it first is restored from the persistent storage.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Constraint_Error</TD>
    <TD> Invalid handle <b>Storage</b>, <b>Parent</b> is not persistent in <b>
	Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <tr>
    <TD>End_Error</TD>
    <TD> No such object</TD>
  </tr>
	<tr>
    <TD valign="top">Use_Error</TD>
    <TD> The class of the object is unknown. This error means that there is no 
	known Ada type yet registered to handle the objects from the persistent 
	storage. Normally Ada types register their classes upon corresponding 
	package elaboration. If the package is not used by the application, its 
	persistent objects cannot be restored.</TD>
  </tr>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function</font> Get_Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : String / Wide_String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font>String;</tt></p>

</blockquote>
<p>These functions return the class of  a  persistent  object
by its name and parent. The 
name can be specified either an UTF-8 encoded string or as a wide string.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <tr>
    <TD>Constraint_Error</TD>
    <TD> Invalid handle <b>Storage</b>, <b>Parent</b> is not persistent in <b>
	Storage</b></TD>
  </tr>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>End_Error</TD>
    <TD> No such object</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF">function </font> Get_List<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Prefix</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String&nbsp;:= "";<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Suffix</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String&nbsp;:= "";<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Equivalence</b> : Unicode_Mapping_Function := <font color="#0000FF">null</font>;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> 
  Catalogue.Set;<br>
	<font color="#0000FF">function </font> Get_List<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Prefix</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : Wide_String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Suffix</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : Wide_String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Equivalence</b> : Unicode_Mapping_Function := <font color="#0000FF">null</font>;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> 
  Catalogue.Set;</tt></p>

</blockquote>
<p>These functions return a list of all immediate children of <b>Parent</b> persistent in <b>Storage</b>. Only names starting with <b> Prefix</b> and ending with <b> Suffix</b> 
are eligible. When names are compared two characters are considered same if 
their corresponding values according to <b> Equivalence</b> are same. When 
Equivalence is null, it is assumed an identity mapping. For case insensitive 
mappings see
<a href="strings_edit.htm#Strings_Edit.UTF8.Mapping">Strings_Edit.UTF8.Mapping</a>.To_Lowercase.
Observe that <b> Prefix</b> may not overlap <b> Suffix</b> when matched.  So  if
<b>Prefix</b>=&quot;AB&quot; and <b>Suffix</b>=&quot;BC&quot;, then "ABC" does not fit,
but &quot;ABBC&quot; does. The result of the function is a <a href="#Persistent.Catalogue">set of object names</a>. 
<b>Prefix</b> and <b>Suffix</b> are either UTF-8 encoded or wide strings.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle <b>Storage</b>, <b>Parent</b> is not persistent in <b>
	Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function </font> Get_Name<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> String;</tt></p>

</blockquote>
<p>This function returns the object's name in <b>Storage</b>. The object is
specified by its <a href="#Persistent.Deposit_Handle">  handle</a>. The result is an UTF-8 encoded string. 
Note that the object names are relative to the object's parent.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle or <b>Object</b>  does not persists in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD><b>Object</b> is anonymous</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function </font> Get_Parent<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font>Deposit_Handle;</tt></p>

</blockquote>
<p>This function returns the object's parent in <b>Storage</b>. The object is
specified by its <a href="#Persistent.Deposit_Handle">  handle</a>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle or <b>Object</b>  does not persists in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD><b>Object</b> is anonymous</TD>
  </TR>
</TABLE>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Invalidate
(<b>Storage</b> : <font color="#0000FF"> in out</font>  Storage_ Handle);</tt></p>
</blockquote>
<p>This procedure makes handle pointing to nothing. If it was  the  last reference to the
persistent storage interface object, the latter is destroyed.</p>

<blockquote>
  <p><tt><font color="#0000FF">function </font>Is_Descendant<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : Storage_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp; 
	: Deposit_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return </font>Boolean;</tt></p>

</blockquote>
<p>This function checks if <b>Object</b> is a direct or indirect descendant of
<b>Parent</b>. The result is <i><font color="#1100000">false</font></i> if <b>
Object</b> is invalid, or else specifies an anonymous or non-persisting in <b>
Storage</b> object. Otherwise the result is <i><font color="#1100000">true</font></i> 
when <b>Parent</b> is invalid (i.e. identifies root-level objects) and <i>
<font color="#1100000">false</font></i> when <b>Parent</b> does not persist in <b>
Storage</b>. Data_Error is propagated on error in <b>Storage</b>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function </font> Is_In<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : String / Wide_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Boolean;<font color="#0000FF"><br>
  function </font>Is_In<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Boolean;</tt></p>

</blockquote>
<p>These functions check whether  an  object  persists  in <b>Storage</b>.  The object can be identified either by its name 
and parent or
by a <a href="#Persistent.Deposit_Handle">  handle</a> to  it.  When <b> Object</b> is not a valid handle the result is <i><font color="#1100000">false</font></i>. 
The name can be specified either an UTF-8 encoded string or as a wide string.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle (<b>Storage</b>), <b>Parent</b> does not persists in <b>
	Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF">function </font> Is_Named<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return
  </font> Boolean;</tt></p>

</blockquote>
<p>These functions check whether  <b>Object</b>  persists and named  in <b>Storage</b>. 
When <b> Object</b> is not a valid handle the result is <i><font color="#1100000">false</font></i>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <tr>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle (<b>Storage</b>)</TD>
  </tr>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  </TABLE>
<blockquote>
<p><tt>
<font COLOR="#0000ff">function </font>Is_Valid (<b>Storage</b> : Storage_ Handle) <font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
This function checks whether a handle points to a persistent storage interface object.
<blockquote>
<p><tt><font COLOR="#0000ff">function </font>Ptr (<b>Storage</b> : Storage_ Handle) <font color="#0000FF"> return</font> 
 Storage_Object_Ptr;</tt></p>
</blockquote>
This function is used to get a pointer to the object the handle <b>Storage</b> points to.

The pointer of to the
object shall be used no longer the handle it was get from exists.
<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Handle.Put"></a>procedure </font> Put<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF">in out</font>  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : <font color="#0000FF"> in out</font>  Deposit_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Parent</b>&nbsp; : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure </font> Put<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF">in out</font>  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : <font color="#0000FF"> in out</font>  Deposit_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : Wide_String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Parent</b>&nbsp; : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
   procedure </font> Put<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : <font color="#0000FF"> in out</font> Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>

</blockquote>
<p>These procedures are used to store <b> Object</b> in <b>Storage</b>. The parameters
<b> Name</b> and <b>Parent</b> specify the object name there. It can be 
specified either an UTF-8 encoded string or as a wide string. When the name is 
omitted the object is stored anonymous. Anonymous persistent objects are 
collected when no more used. It is safe to put an anonymous object
into <b>Storage</b> and then reference it in another persistent object. When <b> Object</b> already persists in
<b> Storage</b> and <b> Name</b> is  specified, then  it  is  checked  that  it is same. If this check fails,
<b> Name</b> is empty, illegal,  or  conflicts with the name of another object Name_Error is propagated.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle (<b>Storage</b> or <b>Object</b>), <b>Parent</b> is not 
	persistent in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD>Illegal name (such as empty), name conflict, a renaming attempt</TD>
  </TR>
</TABLE>
<blockquote>
<p>
<tt><font COLOR="#0000ff">function </font> Ref (<b>Storage</b> :
Storage_Object_Ptr)
<font color="#0000FF"> return</font>   Storage_Handle;</tt>
</p>
</blockquote>

<p>This function obtains a handle to the persistent storage interface
object. Having a handle to the object prevents object's premature destruction.</p>

<blockquote>
  <p><tt><font color="#0000FF">procedure </font> Rename<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out </font>Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Old_Name</b>&nbsp;&nbsp; :
  String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Old_Parent</b> : Deposit_Handle := Root_Directory;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>New_Name</b>&nbsp;&nbsp; : String;<b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	New_Parent</b> : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
   procedure </font> Rename<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out </font>Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp;&nbsp; :<font color="#0000FF"> in out </font> Deposit_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>New_Name</b>&nbsp;&nbsp; : String;<b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	New_Parent</b> : Deposit_Handle := Root_Directory;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure </font> Rename<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out </font>Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Old_Name</b>&nbsp;&nbsp; :
  Wide_String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Old_Parent</b> : Deposit_Handle := Root_Directory;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>New_Name</b>&nbsp;&nbsp; : Wide_String;<br>
  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	New_Parent</b> : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
   procedure </font> Rename<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out </font>Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;&nbsp;&nbsp;&nbsp; :<font color="#0000FF"> in out </font> Deposit_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>New_Name</b>&nbsp;&nbsp; : Wide_String;<br>
  <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	New_Parent</b> : Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>

</blockquote>
<p>These procedures change the name of the object specified either by its old name 
and parent
(the parameter <b>Old_Name</b>, <b>Old_Parent</b>) or by a <a href="#Persistent.Deposit_Handle">  handle</a>
to it. The names can be specified either an UTF-8 encoded string or as a wide 
string. When the renamed object was anonymous  before renaming it becomes a named one.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>Invalid handle or <b>Object</b> is not persistent in <b>Storage</b>, <b>
	New_Parent</b> does not persists in <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
  <TR>
    <TD>End_Error</TD>
    <TD><b>Old_Name</b> indicates no object</TD>
  </TR>
  <TR>
    <TD>Name_Error</TD>
    <TD>Illegal name (such as empty) or name conflict. <b>New_Parent</b> is 
	anonymous or a descendant of the renamed object</TD>
  </TR>
</TABLE>
<blockquote>
  <p><tt><font color="#0000FF">procedure </font> Unname<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF">in out </font>Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Name&nbsp; </b>&nbsp;
  : String / Wide_String;<b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parent
	</b>&nbsp;: Deposit_Handle := Root_Directory<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
   procedure </font>Unname<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF">in out </font>Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : <font color="#0000FF"> in out </font> Deposit_Handle<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>

</blockquote>
<p>These procedures make an object  anonymous. The object can be specified either
by its name and parent object or by a <a href="#Persistent.Deposit_Handle">  handle</a> to it. The 
name is either an UTF-8 encoded string or a wide string. Unnamed  objects  are automatically  deleted  when  no  more in use. Nothing happens if the object is already unnamed. Nothing also happens if
<b> Object</b> is an invalid <a href="#Persistent.Deposit_Handle">  handle</a>, not a handle to a persistent object or  does  not  exist.  Note  that anonymous  objects  are  not  deleted
before objects pointed by either <b>Object</b> or <b>Storage</b> destroyed.
There is a difference  between  Unname and <a href="#Object.Archived.Handle.Delete">Delete</a>
called on an object handle. <a href="#Object.Archived.Handle.Delete">Delete</a> requests object deletion from both memory  and persistent storage. Unname does it for persistent storage only.  Both  may  have  no immediate effect if the object is still in use. 
When an object becomes anonymous so do all its descendants.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD><b>Storage</b> is ot a valid handle, <b>Parent</b> does persists in <b>
	Storage</b> </TD>
  </TR>
  <TR>
    <TD>Data_Error</TD>
    <TD> Inconsistent <b>Storage</b></TD>
  </TR>
</TABLE>

<p align="right">
  <a href="#2.6" name="2.7"></a><a href="#2.6"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.8"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.7. Persistent storage factory</H3>
<p><a name="Persistent.Handle.Factory"></a>The package <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>
provides a factory of persistent storage objects.</p>

<blockquote>
<P><tt><font color="#0000FF">function</font>  Create_APQ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Server_Type</b>&nbsp;&nbsp;&nbsp;
: Database_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Data_Base_Name</b> : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>User_Name</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Password</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Host_Name</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String&nbsp; := &quot;<font color="#FF0000">localhost</font>&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Port_Number</b>&nbsp;&nbsp;&nbsp;
: Natural := <font color="#1100000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Erase</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font>
 Storage_Handle;</tt></blockquote>
<P> This  function creates an APQ persistent storage interface object and returns  a  handle  to  it. The object is responsible for interacting
with a data base via APQ bindings. A connection is established to the server   specified   by   the   parameter
<b>Host_Name</b>.  The  parameter <b> Server_Type</b>  identifies   the   data   base   engine.
It   can   be Engine_PostgreSQL, Engine_MySQL etc, one  of  the  supported  by  APQ
engines. The enumeration type Database_Type is defined in the package APQ
delivered with the APQ distribution. <b>User_Name</b>  and <b>  Password</b>  identify  the  data  base   user.
<b> Data_Base_Name</b>  is  the  name  of  a data base managed by the server. <b> Port_Number</b>  specifies  the  TCP/IP port listened by the server. When specified  as  0,  a  reasonable default is used. The parameter Erase when
<font color="#1100000"><i>true</i></font>  erases  the data base contents by dropping all the tables used for storing persistent objects. If the data  base  contains  any additional tables, they remain untouched.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Data_Error</TD>
    <TD> Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> Connection problem. Either of the parameters identifying server, data
      base or user
      might be wrong</TD>
  </TR>
</TABLE>

<blockquote>
<P><tt><font color="#0000FF">function</font>  Create_ODBC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Server_Name</b> :
String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>User_Name</b>&nbsp;&nbsp;
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Password</b>&nbsp;&nbsp;&nbsp;
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Erase</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> 
 Storage_Handle;<br>
<font color="#0000FF">function</font>  Create_ODBC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Server_Name</b> :
Wide_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>User_Name</b>&nbsp;&nbsp;
: Wide_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Password</b>&nbsp;&nbsp;&nbsp;
: Wide_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Erase</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> 
 Storage_Handle;</tt></blockquote>
<P>This function creates a connection to an ODBC data base, i.e. any data base 
that has an ODBC driver and returns a valid handle to the persistent storage
interface object to communicate the data base. The parameter <b>Server_Name</b>
specifies the data server name. It denotes both the data base and the server
(driver). The parameters <b>User_Name</b> and <b>Password</b> specify the user and the
password to access the data base. All names here are UTF-8 encoded or wide 
strings.When the parameter <b>Erase</b> is set to <i><font color="#1100000">true</font></i>,
all used tables are erased upon establishing the connection. One can use it if
there is a possibility that the data base contains some corrupted or undesired
data. So the data base would initially contain no persistent objects.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Data_Error</TD>
    <TD> Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> Connection problem. Either of the parameters <b>Server_Name</b>, <b>User_Name</b>, <b>Password</b>
      might be wrong</TD>
  </TR>
</TABLE>

<p align="right">
  <a href="#1.5" name="2.8"></a><a href="#2.7"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><a href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></a><a href="#2.9"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.8. Persistent storage implementations</H3>
<p>Simple components provide ready-to-use persistent storage implementations.
The package <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>
 supports run-time selection of the most suitable implementation. That might be
undesirable, because the implementations rely on third party products such as <a href="http://gnade.sourceforge.net/">GNADE</a>
and APQ. So <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>
needs all of them installed. Alternatively, if it is known that only a
particular implementation will be actually used, one can do it directly without
the factory. This will remove any dependency on other implementations. This
section describes presently available implementations.</p>
<H4>2.8.1. ODBC data bases</H4>
<p><a name="Persistent.ODBC"></a>The package <a href="#Persistent.ODBC">Persistent.ODBC</a>
provides an implementation of abstract persistent storage based on <b>O</b>pen <b>D</b>ata<b>b</b>ase <b>C</b>onnectivity
(ODBC) interface to data bases. ODBC is provided for a great variety of
platforms and data bases. The package declares the following subroutines:</p>
<blockquote>
<P><tt><font color="#0000FF"><a name="Persistent.ODBC.Create"></a>function</font>  Create<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Server_Name</b> :
String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>User_Name</b>&nbsp;&nbsp;&nbsp;:&nbsp;String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Password</b>&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Erase</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> 
 Storage_Handle;</tt></blockquote>
<P>This function creates a connection to an ODBC data base, i.e. any data base 
that has an ODBC driver and returns a valid handle to the persistent storage
interface object to communicate the data base. The parameter <b>Server_Name</b>
specifies the data server name. It denotes both the data base and the server
(driver). The parameters <b>User_Name</b> and <b>Password</b> specify the user and the
password to access the data base. All these parameters are UTF-8 encoded 
strings. When the parameter <b>Erase</b> is set to <i><font color="#1100000">true</font></i>,
all used tables are erased upon establishing the connection. One can use it if
there is a possibility that the data base contains some corrupted or undesired
data. So the data base would initially contain no persistent objects.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Data_Error</TD>
    <TD> Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> Connection problem. Either of the parameters <b>Server_Name</b>, <b>User_Name</b>, <b>Password</b>
      might be wrong</TD>
  </TR>
</TABLE>

<blockquote>
<P><tt><font color="#0000FF">procedure</font> Disable_Tracing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> in out</font> Storage_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></blockquote>
<P>This procedure disables tracing of SQL requests. Constraint_Error is
propagated when <b>Storage</b> is not a handle to ODBC persistent storage.

<blockquote>
<P><tt><font color="#0000FF">procedure</font> Enable_Tracing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>  Storage</b> :
<font color="#0000FF"> in out</font>  Storage_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
: String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             );</tt></blockquote>
<P>This procedure starts tracing SQL requests using trace file <b>Name</b>.
Constraint_Error is propagated when <b>Storage</b> is not a handle to ODBC
persistent storage. Data_Error is propagated on any other error.

<blockquote>
<P><tt><font color="#0000FF">function</font> Is_ODBC (<b>Storage</b> :
Storage_Handle)
<font color="#0000FF"> return</font> Boolean;</tt></blockquote>
<P>This function returns <font color="#1100000"><i>true</i></font> if <b>Storage</b>
is a valid handle to an ODBC persistent storage interface object.

<blockquote>
<P><tt><font color="#0000FF">   function</font> Serializable (<b>Storage</b> :
Storage_Handle) <font color="#0000FF"> return</font> Boolean;</tt></blockquote>
<P>This function returns <font color="#1100000"><i>true</i></font> if the ODBC
driver communicated through <b>Storage</b> supports serializable transactions.
Constraint_Error is propagated when <b>Storage</b> is not a valid handle to an
ODBC persistent storage interface object.

<blockquote>
<P><tt><font color="#0000FF">   function</font> Unicode (<b>Storage</b> :
Storage_Handle) <font color="#0000FF"> return</font> Boolean;</tt></blockquote>
<P>This function returns <font color="#1100000"><i>true</i></font> if the ODBC
driver communicated through <b>Storage</b> natively supports Unicode.
Constraint_Error is propagated when <b>Storage</b> is not a valid handle to an
ODBC persistent storage interface object.
  <P><u><b>Implementation notes</b></u>. The implementation uses a minimal set of SQL
  features to support a greater number of data bases. Therefore almost
  everything, from generating unique keys to ON DELETE CASCADE is implemented
  without the data base engine. The most suitable types are selected according 
  to the results of SQLGetTypeInfo. As the result the performance might be not 
  optimal.<P>The minimal requirements for an ODBC driver:<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD>32-bit integers</TD>
    <TD>SQL_INTEGER. When 64-bit integers (SQL_BIGINT) are supported, they are 
    used for object unique keys. Otherwise, it is (signed) 32-bit ones</TD>
  </TR>
  <TR>
    <TD>Time stamping</TD>
    <TD>SQL_TIMESTAMP.</TD>
  </TR>
  <tr>
    <TD>Variable character strings</TD>
    <TD>SQL_LONGVARCHAR. Also when Unicode is supported (SQL_WLONGVARCHAR) it is 
    used to keep object names. When not supported, object names are stored in 
    plain strings.</TD>
  </tr>
  <tr>
    <TD>PRIMARY KEY</TD>
    <TD>Object primary keys are integers.</TD>
  </tr>
  <tr>
    <TD>MAX()</TD>
    <TD>In SELECT</TD>
  </tr>
  <tr>
    <TD>DISTINCT</TD>
    <TD>In SELECT</TD>
  </tr>
  <tr>
    <TD>NOW()</TD>
    <TD>In INSERT as a value for SQL_TIMESTAMP</TD>
  </tr>
  <tr>
    <TD>NULL</TD>
    <TD>In INSERT as a value for string</TD>
  </tr>
</TABLE>
  <p>The implementation tries to serialize data base transactions if the ODBC 
  driver support it. In any case the manual-commit mode is used to provide 
  atomic data base changes. The data base structure consists of three tables:</p>
<P>Table <i>objects</i>:<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Column</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Type</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Description</b></font></TD>
  </TR>
  <TR>
    <TD>object_id</TD>
    <TD>64- or 32-bit integer, primary key, unique</TD>
    <TD>Object key</TD>
  </TR>
  <tr>
    <TD>catalogue_name</TD>
    <TD>UTF-8 string</TD>
    <TD>Object name. Unset if object is anonymous</TD>
  </tr>
  <tr>
    <TD>class_name</TD>
    <TD>UTF-8 string</TD>
    <TD>Object's class</TD>
  </tr>
  <tr>
    <TD>object_data</TD>
    <TD>UTF-8 string</TD>
    <TD>Object data</TD>
  </tr>
  <tr>
    <TD>parameters_list</TD>
    <TD>UTF-8 string</TD>
    <TD>The dependency list</TD>
  </tr>
  <tr>
    <TD>created_at</TD>
    <TD>Time stamp</TD>
    <TD>Object creation time</TD>
  </tr>
  <tr>
    <TD>parent_id</TD>
    <TD>64- or 32-bit integer</TD>
    <TD>The key of the object's parent object</TD>
  </tr>
</TABLE>
<P>Tables <i>backward_links</i> and <i>direct_links</i>:<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Column</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Type</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Description</b></font></TD>
  </TR>
  <TR>
    <TD>dependant</TD>
    <TD>64- or 32-bit integer</TD>
    <TD>Object key</TD>
  </TR>
  <tr>
    <TD>referent</TD>
    <TD>64- or 32-bit integer</TD>
    <TD>Object key, the object&nbsp;</TD>
  </tr>
</TABLE>
  <p>The
  software was tested with:</p>
<ul>
  <li>MS Access (Office 2000 edition);</li>
  <li>MySQL 4.1 (see <a href="http://www.mysql.com/">MySQL
  home page</a>);</li>
  <li>PostgreSQL 8.2 (see <a href="http://www.postgresql.org/">PostgreSQL home
    page</a>)</li>
</ul>
<p>Some words of warning:</p>
<ul>
  <li>The ODBC driver provided for MS Excel does not fulfill the
requirements above and therefore cannot be used with <a href="#Persistent.ODBC">Persistent.ODBC</a>;</li>
  <li>MyODBC 3.51 for Linux seems to be corrupt (at least SQLGetData). Windows
    version works well;</li>
  <li>There should be something wrong with Unicode support in many ODBC drivers
    under Linux. The issue requires further investigation.</li>
</ul>
  <P><u><b>Installation notes</b></u>. The implementation is based on
  GNADE 1.5.3a (<b>GN</b>at <b>A</b>da <b>D</b>atabase <b>E</b>nvironment). The <a href="http://gnade.sourceforge.net/">GNADE
  project</a> is distributed under modified GNU Public License. To
  compile the package <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>
  you will need a GNADE distribution, at least its part related to ODBC 
  bindings. If you do not use <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>,
  you  need not compile it. For ODBC driver installation refer your
  data base documentation.
<H4>2.8.2. APQ-interfaced data bases</H4>
<p><a name="Persistent.APQ"></a>The package <a href="#Persistent.APQ">Persistent.APQ</a>
provides an implementation of abstract persistent storage based on Ada95 Database Binding to
PostgreSQL/MySQL by Warren W. Gay VE3WWG (APQ). APQ supports a number of data
bases accessed via a unified interface. The package <a href="#Persistent.APQ">Persistent.APQ</a>
provides the following subroutines:</p>
<blockquote>
<P><tt><font color="#0000FF">function</font>  Create<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Server_Type</b>&nbsp;&nbsp;&nbsp;
: Database_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Data_Base_Name</b> : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>User_Name</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Password</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Host_Name</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: String&nbsp; := &quot;<font color="#FF0000">localhost</font>&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Port_Number</b>&nbsp;&nbsp;&nbsp;
: Natural := <font color="#1100000">0</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Erase</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font>
 Storage_Handle;</tt></blockquote>
<P> This  function creates an APQ persistent storage interface object and returns  a  handle  to  it. The object is responsible for interacting
with a data base via APQ bindings. A connection is established to the server   specified   by   the   parameter
<b>Host_Name</b>.  The  parameter <b> Server_Type</b>  identifies   the   data   base   engine.
It   can   be Engine_PostgreSQL, Engine_MySQL etc, one  of  the  supported  by  APQ
engines. The enumeration type Database_Type is defined in the package APQ
delivered with the APQ distribution. <b>User_Name</b>  and <b>  Password</b>  identify  the  data  base   user.
<b> Data_Base_Name</b>  is  the  name  of  a data base managed by the server. <b> Port_Number</b>  specifies  the  TCP/IP port listened by the server. When specified  as  0,  a  reasonable default is used. The parameter Erase when
<font color="#1100000"><i>true</i></font>  erases  the data base contents by dropping all the tables used for storing persistent objects. If the data  base  contains  any additional tables, they remain untouched.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>Data_Error</TD>
    <TD> Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> Connection problem. Either of the parameters identifying server, data
      base or user
      might be wrong</TD>
  </TR>
</TABLE>

<blockquote>
<P><tt><font color="#0000FF">procedure</font> Disable_Tracing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>  Storage</b> :
<font color="#0000FF"> in out</font> Storage_Handle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             );</tt></blockquote>
<P>This procedure disables tracing of SQL requests. Constraint_Error is
propagated when <b>Storage</b> is not a handle to APQ persistent storage.

<blockquote>
<P><tt><font color="#0000FF">procedure</font> Enable_Tracing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             (&nbsp; <b>  Storage</b> :
<font color="#0000FF"> in out</font>  Storage_Handle;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;    : String<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             );</tt></blockquote>
<P>This procedure starts tracing SQL requests using trace file <b>Name</b>.
Constraint_Error is propagated when <b>Storage</b> is not a handle to APQ
persistent storage. Data_Error is propagated on any other error.

<blockquote>
<P><tt><font color="#0000FF">   function</font> Is_APQ (<b>Storage</b> :
Storage_Handle) <font color="#0000FF"> return</font> Boolean;</tt></blockquote>
<P>This function returns <font color="#1100000"><i>true</i></font> if <b>Storage</b>
is a valid handle to an APQ persistent storage interface object.
  <P><u><b>Implementation notes</b></u>. The data base structure consists of
  three tables:<P>Table <i>objects</i>:<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Column</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Type</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Description</b></font></TD>
  </TR>
  <TR>
    <TD>object_id</TD>
    <TD>64- or 32-bit integer, primary key, unique, auto-incremented</TD>
    <TD>Object key</TD>
  </TR>
  <tr>
    <TD>catalogue_name</TD>
    <TD>UTF-8 string</TD>
    <TD>Object name. Unset if object is anonymous</TD>
  </tr>
  <tr>
    <TD>class_name</TD>
    <TD>UTF-8 string</TD>
    <TD>Object's class</TD>
  </tr>
  <tr>
    <TD>object_data</TD>
    <TD>UTF-8 string</TD>
    <TD>Object data</TD>
  </tr>
  <tr>
    <TD>parameters_list</TD>
    <TD>UTF-8 string</TD>
    <TD>The dependency list</TD>
  </tr>
  <tr>
    <TD>created_at</TD>
    <TD>Time stamp</TD>
    <TD>Object creation time</TD>
  </tr>
	<tr>
    <TD>parent_id</TD>
    <TD>64- or 32-bit integer</TD>
    <TD>Parent object key</TD>
  </tr>
</TABLE>
<P>Tables <i>backward_links</i> and <i>direct_links</i>:<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Column</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Type</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Description</b></font></TD>
  </TR>
  <TR>
    <TD>dependant</TD>
    <TD>64- or 32-bit integer</TD>
    <TD>Object key</TD>
  </TR>
  <tr>
    <TD>referent</TD>
    <TD>64- or 32-bit integer</TD>
    <TD>Object key, the object&nbsp;</TD>
  </tr>
</TABLE>
  <p>The
  software was tested with:</p>
<ul>
  <li> MySQL 4.1 (see <a href="http://www.mysql.com/">MySQL
  home page</a>);</li>
  <li>PostgreSQL 8.2 (see <a href="http://www.postgresql.org/">PostgreSQL home
    page</a>)</li>
</ul>
<p>It was not tested under Linux because APQ 2.1 was targeted to 3.x versions of
MySQL.</p>
<P><u><b>Installation notes</b></u>. The implementation is based on APQ 2.1. It
can be found <a href="http://home.cogeco.ca/~ve3wwg/software.html">here</a>. The <a href="http://gnade.sourceforge.net/">APQ
  project</a> is distributed under modified GNU Public License 2 and Ada
Community Licenses. To
  compile the package <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>
  you will need an APQ distribution. If you do not use <a href="#Persistent.Handle.Factory">Persistent.Handle.Factory</a>,
  you  need not to compile it.

You might need to modify the sources in order to be able to work with the recent 
versions of GNAT compiler, PostgreSQL or MySQL.<p align="right">
  <a href="#2.9" name="2.9"></a><a href="#2.8"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#2.10"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.9. Implementation of a new persistent storage</H3>
<p>This chapter describes the internal packages used to ease implementation of a
persistent storage backed by a data base.</p>

<H4>2.9.1. Data bases</H4>
<p>Usually persistent storage is implemented on the basis of an external data base engine. In
that data base persistent objects are represented by records or other data
structures identified by keys. The packages <a href="#Persistent.Data_Bank">Persistent.Data_Bank</a>,
<a href="#Persistent.Data_Bank.Index">Persistent.Data_Bank.Index</a> and <a href="#Persistent.Data_Bank.Indexed">Persistent.Data_Bank.Indexed</a>
are provided for interfacing such data bases. The
package <a href="#Persistent.Data_Bank">Persistent.Data_Bank</a> is the parent
package providing basic types. The package <a href="#Persistent.Data_Bank.Index">Persistent.Data_Bank.Index</a> 
defines a storage index object to be used at run-time by the storage object. The
package <a href="#Persistent.Data_Bank.Indexed">Persistent.Data_Bank.Indexed</a>
 provides a specialized abstract storage which implements the abstract storage
operation used the interface defined in <a href="#Persistent.Data_Bank">Persistent.Data_Bank</a>.
That is used to derive a concrete implementation of persistent storage object,
that will override the remaining abstract operations.</p>

<H4>2.9.2. Storages with keys</H4>

<p><a name="Persistent.Data_Bank"></a><a name="Persistent.Data_Bank.Data_Bank_Object"></a>The
package <a href="#Persistent.Data_Bank">Persistent.Data_Bank</a> defines
abstract interface of the storage objects which identify stored objects using a
key. It derives the abstract base type <a href="#Persistent.Data_Bank.Data_Bank_Object">Data_Bank_Object</a>
from <a href="#Storage_Object">Storage_Object</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">type </font> Data_Bank_Object<font color="#0000FF"> is abstract<br>
  &nbsp;&nbsp; new </font> Storage_Object<font color="#0000FF"> with private</font>;</tt></p>

</blockquote>
<p><a name="Persistent.Data_Bank.Persistent_Key"></a>The keys are provided by
implementations by deriving from the abstract base type <a href="#Persistent.Data_Bank.Persistent_Key">Persistent_Key</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">type</font> Persistent_Key <font color="#0000FF"> is abstract<br>
  &nbsp;&nbsp; new</font> Ada.Finalization.Controlled <font color="#0000FF"> with null
  record</font>;<br>
  <font color="#0000FF">   type</font> Persistent_Key_Ptr <font color="#0000FF"> is access</font>
  Persistent_Key'Class;</tt></p>

</blockquote>
<p><a name="Persistent.Data_Bank.Persistent_Key_Array"></a>The arrays of keys are to 
be implemented by deriving from the abstract base type
<a href="#Persistent.Data_Bank.Persistent_Key_Array">Persistent_Key_Array</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">type</font> Persistent_Key_Array
	<font color="#0000FF">is abstract<br>
&nbsp;&nbsp; new</font> Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with null record</font>;</tt></p>

</blockquote>
<p><a name="Persistent.Data_Bank.Access_Mutex"></a>In order to support data base
transactions a special access policy is imposed on <a href="#Storage_Object">Storage_Object</a>s.
The type <a href="#Persistent.Data_Bank.Access_Mutex">Access_Mutex</a> is used
to represent transactions:</p>

<blockquote>
  <p><tt><font color="#0000FF">type </font> Access_Mutex (Storage : <font color="#0000FF"> access</font>
  Data_Bank_Object'Class)<font color="#0000FF"> is<br>
  &nbsp;&nbsp; abstract new </font> Ada.Finalization.Limited_Controlled<font color="#0000FF"> with
  private</font>;</tt></p>

</blockquote>
<p>This type is used as the  base  for  storage  specific  objects  that represent  atomic actions on storage, such as data base transactions.
Two concrete types are  derived  from  it.  Read_Mutex  is  used  for<br>
viewing storage content without modification. Write_Mutex is used for full access.</p>

<blockquote>
  <p><tt><font color="#0000FF">   type </font>Read_Mutex <font color="#0000FF"> is new
  </font> Access_Mutex <font color="#0000FF"> with private</font>;<br>
  <font color="#0000FF">   type </font>Write_Mutex <font color="#0000FF"> is new</font> Access_Mutex
  <font color="#0000FF"> with private</font>;</tt></p>

</blockquote>
<p>An operation that requires access to <a href="#Storage_Object">Storage_Object</a>
that might require data base communication should do it as follows:</p>

<blockquote>
  <p><tt><font color="#0000FF">declare<br>
  &nbsp;&nbsp; </font>Transaction : Write_Mutex (DB'<font color="#0000FF">Access</font>);<font color="#0000FF"><br>
  begin<br>
  &nbsp;</font><i><font color="#008000">&nbsp; -- Do something with DB</font></i><font color="#0000FF"><br>
  &nbsp;&nbsp; </font>Commit (Transaction);<font color="#0000FF"><br>
  end</font>;</tt></p>

</blockquote>
<p>When <a href="#Persistent.Data_Bank.Commit_mutex"> Commit</a> is not called on
Transaction, because of exception  propagation for instance, then <a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a>
will be in the course of Transaction finalization.</p>

<p>
<u><b>Operations defined on mutexes</b></u>:</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Commit_mutex"></a>procedure</font> Commit
  (<b>Mutex</b> : <font color="#0000FF"> in out</font>  Access_Mutex);</tt></p>

</blockquote>
<p>This procedure is basically one call:</p>

<blockquote>
<p><tt><a href="#Persistent.Data_Bank.Commit_storage"></a>Commit
(<b>Mutex</b>.Storage.<font color="#0000FF">all</font>);</tt> </p>

</blockquote>
<p> <a href="#Persistent.Data_Bank.Commit_mutex"> Commit</a>
can be called only once. Multiple commits cause Use_Error propagation. Any other
exception indicates a data base error.</p>

<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Finalize (<b>Mutex</b> : <font color="#0000FF"> in out</font> 
  Access_Mutex);</tt></p>

</blockquote>
<p>The destructor calls <a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a>
if no <a href="#Persistent.Data_Bank.Commit_mutex"> Commit</a> was called before.
This ensures data base consistency upon transaction errors.</p>

<p>
<u>
<b>Operations defined on keys</b></u>. Normally an implementation of a
persistent storage would provide a derived key type. That should override the
following abstract operations:</p>

<blockquote>
  <p><tt><font color="#0000FF">function</font> Image<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Data_Bank_Object'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> String
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This function returns a string unambiguously identifying <b>Key</b> in <b>Storage</b>.
Constraint_Error is propagated when <b>Key</b> cannot be used for <b>Storage</b>.</p>

<blockquote>
  <p><tt>
	<font color="#0000FF"><a name="Persistent.Data_Bank.Null_Key"></a>function</font> Null_Key <font color="#0000FF"> return</font> Persistent_Key
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This function returns a value that serves as an illegal key which can never
indicate an object.</p>

<blockquote>
  <p><tt><font color="#0000FF">function</font> Value<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : String<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Persistent_Key'Class
  <font color="#0000FF">is abstract</font>;</tt></p>

</blockquote>
<p>This function converts string to a key. Data_Error is propagated when <b>Key</b>
does not identify a valid key for <b>Storage</b>. The implementation should not
check for any objects existing under the key.</p>

<blockquote>
  <p><tt><font color="#0000FF">function</font> "<font color="#FF0000">&lt;</font>"
  (<b>Left</b>, <b> Right</b> : Persistent_Key)<br>
  &nbsp;&nbsp; <font color="#0000FF">return</font> Boolean <font color="#0000FF"> is
  abstract</font>;<br>
  <font color="#0000FF">   function</font> &quot;<font color="#FF0000">=</font>&quot;
  (<b>Left</b>, <b> Right</b> : Persistent_Key)<br>
  &nbsp;&nbsp; <font color="#0000FF">return</font> Boolean <font color="#0000FF"> is
  abstract</font>;</tt></p>

</blockquote>
<p>Persistent keys are comparable to provide ordered containers.</p>

<p>
<u>
<b>Operations defined on arrays of keys</b></u>. The following abstract operations 
shall be overridden by an implementation:</p>

<blockquote>
  <p><tt><font color="#0000FF">function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Container</b> : 
	Persistent_Key_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: Integer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ) <font color="#0000FF">&nbsp;return</font> 
	Persistent_Key'Class <font color="#0000FF">is abstract</font>;</tt></p>

</blockquote>
<p>This function returns a key by its index. Contraint_Error is propagated when 
index is wrong.</p>

<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
	: <font color="#0000FF">in out</font> Persistent_Key_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Index</b>&nbsp;&nbsp;&nbsp;&nbsp; : Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: Persistent_Key'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
	<font color="#0000FF">is abstract</font>;</tt></p>

</blockquote>
<p>This procedure places <b>Key</b> at the position in the array <b>Container</b> 
specified by <b>Index</b>. The array is expanded as necessary. When an 
implementation chooses a dense representation of the array it is allowed to fill 
unspecified array elements with <a href="#Persistent.Data_Bank.Null_Key">Null_Key</a>, 
which can be returned by Get without raising Constraint_Error.</p>

<p><u>
<b>Operations defined to handle transactions</b></u>. <a href="#Persistent.Data_Bank.Data_Bank_Object">Data_Bank_Object</a>
declares abstract operations on persistent storage supporting transaction
framework:</p>
<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Commit_storage"></a>procedure
  </font> Commit (<b>Storage</b> : <font color="#0000FF"> in out</font>
  Data_Bank_Object) <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This  abstract procedure is called at the end of each transaction: an atomic modification of the persistent storage.  There  should  be  no difference between
<a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a>  and
<a href="#Persistent.Data_Bank.Commit_storage">  Commit</a>  if  the  transaction  was initiated  by
Seize_Read. Normally,
<a href="#Persistent.Data_Bank.Commit_storage">  Commit</a> is never called directly, but only through
<a href="#Persistent.Data_Bank.Commit_mutex"> Commit</a> of a mutex object.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Roll_Back"></a>procedure
  </font> Roll_Back (<b>Storage</b> : <font color="#0000FF"> in out </font> Data_Bank_Object)
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p> This procedure  is  called  when  a  transaction  fails,  due  to  an exception.  It  is  always  called  from  an  exception handler which
re-raises  the exception. For this reason it is not recommended to raise any
exceptions in <a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a>. There is no difference between <a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a> and
<a href="#Persistent.Data_Bank.Commit_storage">  Commit</a> if the transaction was initiated by
<a href="#Persistent.Data_Bank.Seize_Read"> Seize_Read</a>. For&nbsp;a
transaction initiated by <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>
an implementation should discard any changes made.</p>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Seize_Read"></a>procedure
  </font> Seize_Read<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;  Storage : <font color="#0000FF"> in out
  </font> Data_Bank_Object<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             )&nbsp; <font color="#0000FF">  is
  abstract</font>;</tt></p>

</blockquote>
<p>This procedure is called  to  initiate  a read-only transaction with <b>Storage</b>. Only one transaction can be active at a time.
The  transaction   is finished by either a call to <a href="#Persistent.Data_Bank.Commit_storage">  Commit</a>
or to <a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a>. For a read-only
transaction there should be no sufficient difference between <a href="#Persistent.Data_Bank.Commit_storage">  Commit</a>
and <a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> A transaction is already active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Seize_Write"></a>procedure
  </font> Seize_Write<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             (&nbsp;  Storage :
  <font color="#0000FF"> in out </font> Data_Bank_Object<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             )&nbsp; <font color="#0000FF">  is
  abstract</font>;</tt></p>

</blockquote>
<p>This procedure is  called  to  initiate  a read/write  transaction with <b>Storage</b>. Only one transaction can be active at a time.  The  transaction   is finished by either a call to
<a href="#Persistent.Data_Bank.Commit_storage">  Commit</a> or to <a href="#Persistent.Data_Bank.Roll_Back"> Roll_Back</a>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> A transaction is already active (optional)</TD>
  </TR>
</TABLE>

<p><u>
<b>Operations defined in terms of keys</b></u>. It is recommended to check
active transaction in implementations of abstract operations and to raise
Use_Error. Though it is not mandatory. Carefully observe that object key is a
class-wide parameter. An implementation would usually check if the key's
specific type is one supported by the data base. If it is not then End_Error
should be used to indicate an absent object, except when otherwise is explicitly
specified.</p>
<p>The following operations should be implemented:</p>

<blockquote>
  <p><tt><font color="#0000FF">   <a name="Persistent.Data_Bank.Delete"></a>procedure</font> Delete<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>  Storage</b> :
  <font color="#0000FF"> in out</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>                Key</b>&nbsp;&nbsp;&nbsp;&nbsp;     : Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;             )&nbsp; <font color="#0000FF">  is
  abstract</font>;</tt></p>

</blockquote>
<p>This procedure deletes an object by its key. An  implementation may proceed from the assumption that all dependent objects  are already deleted and no object refers to the deleted one.
It can
be  called  only  within  a  transaction  following  a  call <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No write transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Find"></a>function </font> Find<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access
  </font> Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : Wide_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Persistent_Key'Class
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This procedure is used to determine  the  object's  key  by  the object's name 
and the key of its immediate parent.  It  is  allowed  only within a transaction initiated either by
<a href="#Persistent.Data_Bank.Seize_Read"> Seize_Read</a> or <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">function </font> Get<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font>
  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Deposit_Handle
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This   procedure   restores  a  persistent  object  by  its  key.  An implementation  shall  check  if  the object for the specified key is already memory-resident.
It is  allowed  to  call  only  within  a transaction  initiated  either  by <a href="#Persistent.Data_Bank.Seize_Read"> Seize_Read</a> or
<a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Get_Children"></a>procedure</font> 
	Get_Children<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp; 
	: <font color="#0000FF">in out</font> Data_Bank_Object;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: Persistent_Key'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Children</b> : <font color="#0000FF">in out</font> 
	Persistent_Key_Array'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Pointer</b>&nbsp; : <font color="#0000FF">in out</font> Integer<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>Implementation adds the keys of the immediate children of the object 
specified by <b>Key</b> into the array <b>Children</b>. The first item is placed 
at <b>Pointer</b>. Then <b>Pointer</b> is advanced.
<a href="#Persistent.Data_Bank.Get_Children">Get_Children</a> is allowed to call 
only within a transaction initiated either by <a href="#Persistent.Data_Bank.Seize_Read">Seize_Read</a> 
or
<a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>. An implementation 
need not to check that, but if it does then Use_Error should indicate failed 
check.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Get_Class"></a>
	function</font> Get_Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> in out</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return </font>String <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>Implementation returns the object's  class. The function is allowed only within a  transaction  initiated  either  by <a href="#Persistent.Data_Bank.Seize_Read">Seize_Read</a> or
<a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Get_Data"></a>procedure</font> Get_Data<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> in out</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Class</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> out</font>  Unbounded_String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Data</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> out</font>  Unbounded_String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parameters</b> :
  <font color="#0000FF"> out</font> Unbounded_String<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>Implementation returns the object's  description  stored  in <b>  Storage</b> under
<b> Key</b>. The description is used to restore the object. The  output  parameters  are the object's class and data as they were
generated by <a href="#Object.Archived.Store"> Object.Archived.Store</a> and  internally  used
<b>Parameters</b>, which  describe  the  dependency  list  of the object being restored.
The procedure is allowed only within a  transaction  initiated  either  by <a href="#Persistent.Data_Bank.Seize_Read">Seize_Read</a> or
<a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Get_Dependant"></a>function</font> Get_Dependant<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>No</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : Positive<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Persistent_Key'Class
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This  function  is used to enumerate objects having backward links to the  object  specified  by
<b>Key</b>. That are ones which have specified the object in the list of backward links (the parameter Backward_Links of
<a href="#Persistent.Data_Bank.Store"> Store</a> and <a href="#Persistent.Data_Bank.Update">Update</a>). All dependants are
enumerated starting from 1. The parameter <b>  No</b>  specifies  the  number  of  a  dependant  to  get.  An implementation  is  allowed  to use a cache, so the caller should not undertake any actions which may lead to updating the dependency  list of the object.
The function is allowed only within a  transaction  initiated  either  by <a href="#Persistent.Data_Bank.Seize_Read">Seize_Read</a> or
<a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No dependant found, end of list, no such object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Get_Name"></a>function</font> Get_Name<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp; 
	: <font color="#0000FF">access</font> Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> String
  <font color="#0000FF">is abstract</font>;</tt></p>

</blockquote>
<p>Implementation returns the object's name stored in <b> Storage</b> under <b>Key</b>.
The result is UTF-8 encoded. When the object has a parent, then the 
implementation sets <b>Parent</b> to the key of. Otherwise it sets <a href="#Persistent.Data_Bank.Null_Key">Null_Key</a> 
there. The function is allowed only within a  transaction  initiated  either  by  either  by <a href="#Persistent.Data_Bank.Seize_Read"> Seize_Read</a> or
<a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Constraint_Error</TD>
    <TD>The type of <b>Parent</b> does not match one of the object's parent</TD>
  </TR>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object</TD>
  </TR>
  <TR>
    <TD>  Name_Error</TD>
    <TD>Anonymous object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Get_References"></a>procedure</font> 
	Get_References<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> Data_Bank_Object;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 
	: Persistent_Key'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	References</b> : <font color="#0000FF">in out</font> 
	Persistent_Key_Array'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Pointer</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Integer<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>Implementation adds the keys of the immediate the objects referenced by the 
object 
specified by <b>Key</b> into the array <b>References</b>. The first item is placed 
at <b>Pointer</b>. Then <b>Pointer</b> is advanced.
An implementation need not to go after the references of the references. The 
procedure <a href="#Persistent.Data_Bank.Get_References">Get_References</a> is allowed to call 
only within a transaction initiated either by <a href="#Persistent.Data_Bank.Seize_Read">Seize_Read</a> 
or
<a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>. An implementation 
need not to check that, but if it does then Use_Error should indicate failed 
check.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">   <a name="Persistent.Data_Bank.Has_Dependants"></a>function</font> Has_Dependants<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Boolean
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p> An  anonymous  object  that has no dependants can be deleted, but not before its
memory-resident counterpart disappears. When key does not specify  any  object,  the result is
<font color="#1100000"><i>false</i></font>. This function is allowed only within a  transaction  initiated  either  by  either  by
<a href="#Persistent.Data_Bank.Seize_Read"> Seize_Read</a> or <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF">   <a name="Persistent.Data_Bank.Is_In"></a>function</font> Is_In<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : <font color="#0000FF"> access</font> 
  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Boolean
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>This  function  checks  whether <b>  Key</b>  specify an object persistent in
<b>Storage</b>. It is allowed only within a  transaction  initiated  either  by  either  by
<a href="#Persistent.Data_Bank.Seize_Read"> Seize_Read</a> or <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Put"></a>procedure</font> Put<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF"> in out</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Object</b>&nbsp;
  : Deposit'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>This  procedure  updates  a  persistent object by its key. Usually it calls <a href="#Persistent.Data_Bank.Update">Update</a>
for  this  purpose.  It  is within a  transaction  initiated by <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD><b>Key</b> does not identify an object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No write transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Rename"></a>procedure</font> Rename<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF"> in out</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;
  : Wide_String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Parent</b>&nbsp; : Persistent_Key'Class <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p> This procedure changes the name of the object  specified  by <b>  Key</b>  to
<b>Name</b>. The object's parent is specified by the parameter <b>Parent</b>. It 
is specified as <a href="#Persistent.Data_Bank.Null_Key">Null_Key</a> for a 
root-level object. When the renamed object was anonymous before renaming it becomes  a named  one.  I.e.  it  will  not  deleted  when  no  more  in use. An
implementation  can  proceed  from the assumption that the caller has already  checked for illegal and conflicting names.
This procedure is allowed only within a transaction initiated  by <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD><b>Key</b> does not identify an object (optional)</TD>
  </TR>
  <TR>
    <TD>  Name_Error</TD>
    <TD>Name conflict, there is another object named so (optional)</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No write transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Store"></a>function</font>
  Store<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> access</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parent</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: Persistent_Key'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Class</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Data</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parameters</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Direct_Links</b>&nbsp;&nbsp;
  : Deposit_Set;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Backward_Links</b> : Deposit_Set<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Persistent_Key'Class
  <font color="#0000FF"> is abstract</font>;<br>
  <font color="#0000FF">   function</font> Store<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> access</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Class</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Data</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parameters</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Direct_Links</b>&nbsp;&nbsp;
  : Deposit_Set;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Backward_Links</b> : Deposit_Set<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">return</font> Persistent_Key'Class
  <font color="#0000FF"> is abstract</font>;</tt></p>

</blockquote>
<p>These functions are used to write a persistent object. They are called internally. The parameters
<b> Name</b> and <b>Parent</b> specify the name of  the  object  in the storage 
and its parent. The name should be an unique UTF-8 encoded name. When not  specified,  the object  is  anonymous.  The  parameter
<b>  Data</b> contains   a   string unambiguously describing the object of the  class  specified  by  the parameter
<b>Class</b>. It is normally obtained using <a href="#Object.Archived.Store">Object.Archived.Store</a>.
<b>Parameters</b>   is  used  to  store  additional information   about   links.   The   parameters
<b>   Direct_Links</b>    and <b> Backward_Links</b>  define  the <a href="#Object.Archived.Sets">  set  of  objects</a>  in
<b>  Storage</b> the object depends on. Objects mentioned in the  set <b>  Backward_Links</b>  are  those which can be deleted without deletion of the object itself. The union of
<b>  Direct_Links</b>  and <b>  Backward_Links</b> specifies only directly visible dependencies, it is nCocsure. An implementation  usually  stores
<b> Class</b> and <b>  Data</b>  under  the  name <b>  Name</b>  and  corrects  a  persistent dependency table according to
<b>Direct_Links</b> and <b> Backward_Links</b>. Note that initially written object is not referenced.
<a href="#Persistent.Data_Bank.Store"> Store</a> is allowed only within a  transaction
by <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No write transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Unname"></a>procedure</font> Unname<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
  <font color="#0000FF"> in out</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>This procedure makes the  object  specified  by <b>  Key</b>  anonymous.  The object object should be automatically deleted when no  more  in  use, but  not  before  it   has   a
memory-resident   counterpart.   An implementation can  proceed  from  the  assumption  that  the  caller already checked for object existence.
The procedure is allowed only within a  transaction  by <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object (optional)</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No write transaction active (optional)</TD>
  </TR>
</TABLE>

<blockquote>
  <p><tt><font color="#0000FF"><a name="Persistent.Data_Bank.Update"></a>procedure</font> Update<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> in out</font>  Data_Bank_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Class</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Data</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Parameters</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Direct_Links</b>&nbsp;&nbsp;
  : Deposit_Set;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Backward_Links</b> : Deposit_Set<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is
  abstract</font>;</tt></p>

</blockquote>
<p>This  procedure is used to update a modified persistent object. It is called   internally.   The   parameter
<b>   Data</b> contains   a  string unambiguously describing the object of the  class  specified  by  the
parameter <b>Class</b>. <b> Parameters</b> is used internally  to  store  additional information about links. It is normally obtained using
<a href="#Object.Archived.Store">Object.Archived.Store</a>.  The  parameters <b>  Direct_Links</b>  and
<b> Backward_Links</b> are  same  as  in <a href="#Persistent.Data_Bank.Store"> Store</a>.
An  implementation would normally update <b> Class</b> and <b> Data</b> in the
object's record and correct  persistent  dependency  table. <a href="#Persistent.Data_Bank.Update">Update</a>
is allowed only within a  transaction  by <a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a>.&nbsp;</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I>
  </CAPTION>
  <TR>
    <TD>  Data_Error</TD>
    <TD>Data base error</TD>
  </TR>
  <TR>
    <TD>  End_Error</TD>
    <TD>No such object (optional)</TD>
  </TR>
  <TR>
    <TD>Use_Error</TD>
    <TD> No write transaction active (optional)</TD>
  </TR>
</TABLE>

<H4>2.9.3. Storage index</H4>

<p><a name="Persistent.Data_Bank.Index"></a>The child generic package <a href="#Persistent.Data_Bank.Index">Persistent.Data_Bank.Index</a>
implements an index of persistent objects:</p>

<blockquote>
  <p><tt><font color="#0000FF">generic</font><br>
  &nbsp;&nbsp; <font color="#0000FF">type</font> Data_Bank <font color="#0000FF"> is abstract new
  </font> Data_Bank_Object
  <font color="#0000FF"> with private</font>;<br>
  &nbsp;&nbsp; <font color="#0000FF">type</font> Key <font color="#0000FF"> is new</font> Persistent_Key
  <font color="#0000FF"> with private</font>;<br>
  <font color="#0000FF">package</font> Persistent.Data_Bank.Index i<font color="#0000FF">s<br>
  &nbsp;&nbsp; type </font> Catalogue (Storage : <font color="#0000FF"> access</font> 
  Data_Bank'Class)
  <font color="#0000FF"> is<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new </font> Ada.Finalization.Limited_Controlled
  <font color="#0000FF"> with private</font>;<br>
  &nbsp;&nbsp; <font color="#0000FF">type</font> Catalogue_Ptr <font color="#0000FF"> is access all</font> Catalogue;<br>
  &nbsp;&nbsp; ...</tt></p>

</blockquote>

<p>Persistent objects having memory-resident counterparts are said to be bound.
For each bound object the storage index of the Catalogue type contains a record.
When an object is requested from the persistent storage it is first searched in
the index. The index also contains information about object's keys and names.
Additionally the index registers a notification object to catch bound objects
destruction. Upon destruction of a bound object index checks if the object was
anonymous and no more referenced in the persistent storage, if so the object is
deleted from the storage. If the memory-resident object was modified it is
synchronized with the storage.</p>

<p>The package has two generic parameters:</p>

<ul>
  <li>Data_Bank is a descendant of <a href="#Persistent.Data_Bank.Data_Bank_Object">Data_Bank_Object</a>
    for which index should be used;</li>
  <li>Key is a descendant of <a href="#Persistent.Data_Bank.Persistent_Key">Persistent_Key</a>,
    a concrete type of keys used with <a href="#Persistent.Data_Bank.Data_Bank_Object">Data_Bank_Object</a>.</li>
</ul>

<H4>2.9.4. Indexed storage</H4>

<p><a name="Persistent.Data_Bank.Indexed"></a>The child generic
package <a href="#Persistent.Data_Bank.Indexed">Persistent.Data_Bank.Indexed</a>
implements persistent storage  interface  using  the  operations  defined in <a href="#Persistent.Data_Bank">Persistent.Data_Bank</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">generic</font><br>
  &nbsp;&nbsp; <font color="#0000FF">type</font> Data_Bank <font color="#0000FF"> is abstract new</font> Data_Bank_Object
  <font color="#0000FF"> with private</font>;<br>
  &nbsp;&nbsp; <font color="#0000FF">type</font> Key <font color="#0000FF"> is new</font> Persistent_Key
  <font color="#0000FF"> with private</font>;<br>
  <font color="#0000FF">package</font> Persistent.Data_Bank.Indexed <font color="#0000FF"> is</font>
  ...</tt></p>

</blockquote>

<p>The generic parameters:</p>

<ul>
  <li>Data_Bank is a descendant of <a href="#Persistent.Data_Bank.Data_Bank_Object">Data_Bank_Object</a>.
    It can be <a href="#Persistent.Data_Bank.Data_Bank_Object">Data_Bank_Object</a>
    itself;</li>
  <li>Key is a descendant of <a href="#Persistent.Data_Bank.Persistent_Key">Persistent_Key</a>,
    a concrete type of keys used with <a href="#Persistent.Data_Bank.Data_Bank_Object">Data_Bank_Object</a>.</li>
</ul>

<p><a name="Persistent.Data_Bank.Indexed.Indexed_Storage_Object"></a>The package
provides the abstract type <a href="#Persistent.Data_Bank.Indexed.Indexed_Storage_Object">  Indexed_Storage_Object</a>
which can  be used as the base type for a concrete  implementation  of  a  data  base
interface:</p>

<blockquote>
  <p><tt><font color="#0000FF">type</font> Indexed_Storage_Object <font color="#0000FF"> is abstract new</font> Data_Bank
  <font color="#0000FF"> with private</font>;</tt></p>

</blockquote>

<p>The derived type shall  implement the following remaining operations:</p>

<ul>
  <li><a href="#Persistent.Data_Bank.Commit_storage">Commit</a> to confirm a
    transaction with data base;</li>
  <li><a href="#Persistent.Data_Bank.Delete">Delete</a> to delete an object by key;</li>
  <li><a href="#Persistent.Data_Bank.Find">Find</a> to find an object by name;</li>
	<li><a href="#Persistent.Data_Bank.Get_Children">Get_Children</a> to get 
	object's immediate children;</li>
	<li><a href="#Persistent.Data_Bank.Get_Class">Get_Class</a> to get the 
	object's class;</li>
  <li><a href="#Persistent.Data_Bank.Get_Data">Get_Data</a> to get object's description string;</li>
  <li><a href="#Persistent.Data_Bank.Get_Dependant">Get_Dependant</a> to enumerate dependants with backward links;</li>
  <li><a href="#Persistent.Get_List">Get_List</a> to get the list of all persistent objects;</li>
	<li><a href="#Persistent.Data_Bank.Get_Name">Get_Name</a> to get the object's name and parent;</li>
	<li><a href="#Persistent.Data_Bank.Get_References">Get_References</a> to get 
	the objects immediately referenced by an object;</li>
  <li><a href="#Persistent.NHas_Dependants">Has_Dependants</a> to check if an object can be deleted;</li>
  <li><a href="#Persistent.Data_Bank.Is_In">Is_In</a> to check if the object in the storage, by key;</li>
	<li><a href="#Persistent.Data_Bank.Put">Put</a> to store an object by key;</li>
  <li><a href="#Persistent.Data_Bank.Rename">Rename</a> to set or change the object name;</li>
  <li><a href="#Persistent.Data_Bank.Roll_Back">Roll_Back</a> to discard changes
    made by a transaction;</li>
  <li><a href="#Persistent.Data_Bank.Seize_Read">Seize_Read</a> to initiate a
    read-only transaction;</li>
  <li><a href="#Persistent.Data_Bank.Seize_Write">Seize_Write</a> to initiate a
    read/write transaction;</li>
  <li><a href="#Persistent.Data_Bank.Store">Store</a> to create a new persistent object;</li>
  <li><a href="#Persistent.Data_Bank.Unname">Unname</a> to remove object's name;</li>
  <li><a href="#Persistent.Data_Bank.Update">Update</a> to modify a persistent object.</li>
</ul>

<H4>2.9.5. Proxy objects</H4>

<p><a name="Persistent.Data_Bank.Reference"></a><a name="Persistent.Data_Bank.Self_Reference"></a>Persistent  objects  that  are  not  fully represented by
their memory-resident counterparts require a reference to the storage they persist in.
This  is  necessary  at least to prevent persistent storage interface object from  being  prematurely
destroyed.  Further  the  operation <a href="#Object.Archived.Restore">  Object.Archived.Restore</a> does not contain a parameter referencing the  storage. Special objects of the type
<a href="#Persistent.Data_Bank.Self_Reference"> Self_Reference</a> defined in
the child package <a href="#Persistent.Data_Bank.Reference">Persistent.Data_Bank.Reference</a>
serve this purpose. An object may put a <a href="#Persistent.Data_Bank.Self_Reference"> Self_Reference</a> in its  dependency  list (see
<a href="#Object.Archived.Get_Referents">Object.Archived.Get_Referents</a>) by  calling  the  procedure
Add from  this  package. If it does so then in its <a href="#Object.Archived.Restore"> Restore</a> it will  find a
<a href="#Persistent.Data_Bank.Self_Reference"> Self_Reference</a> again. The
fields of that object denote  the persistent storage and the object's key there.</p>

<blockquote>
  <p><tt><font color="#0000FF">type</font> Self_Reference <font color="#0000FF"> is new
  </font> Deposit<font color="#0000FF"> with record</font><br>
  &nbsp;&nbsp; Storage : Storage_Handle;<br>
  &nbsp;&nbsp; Key&nbsp;&nbsp;&nbsp;&nbsp; : Persistent_Key_Ptr;<br>
  <font color="#0000FF">   end record</font>;</tt></p>

</blockquote>

<p>The following operations are defined on <a href="#Persistent.Data_Bank.Self_Reference"> Self_Reference</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Add<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>List</b>&nbsp;&nbsp;&nbsp;
  : <font color="#0000FF"> in out</font>  Deposit_Container'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Storage</b> :
  Storage_Handle;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;
  : Persistent_Key'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>

</blockquote>

<p>This procedure adds to <b> List</b> a reference to <b>Storage</b>. <b>  Key</b>  is the
<b>Storage</b> key of the object that requires a reference to <b>Storage</b>. The reference is placed at the list end.
Other operations are implementations of the interface defined in <a href="#Object.Archived">Object.Archived</a>.</p>

<p>The following sample code illustrates using <a href="#Persistent.Data_Bank.Self_Reference"> Self_Reference</a>
objects. A user-defined persistent object is Proxy_Object. It contains a handle
to the storage where it persists and implements some of its operations through
communication to the storage. For example, it can be a large array of data
stored there. When a piece of data is requested Proxy_Object routes the request
to the storage and returns the result. Additionally Proxy_Object contains its
key in the storage. Proxy_Object should call Add from its Get_Referents to add
reference to the storage in its dependency list. Then upon restore it will find
a <a href="#Persistent.Data_Bank.Self_Reference"> Self_Reference</a> object in
the list passed to its Restore:</p>

<blockquote>
  <p><tt><font color="#0000FF">type</font> Proxy_Object <font color="#0000FF">is
  new</font> </tt><tt> Deposit<font color="#0000FF"> with record</font><br>
  &nbsp;&nbsp; Storage : Storage_Handle;<font color="#008000"> -- The storage
  used</font><br>
  &nbsp;&nbsp; Key&nbsp;&nbsp;&nbsp;&nbsp; : Storage_Key;&nbsp;&nbsp;&nbsp;<font color="#008000">
  -- The storage key of the object</font><br>
  <i>&nbsp;&nbsp; ...&nbsp;<br>
  </i><font color="#0000FF">end record</font>;<font color="#0000FF"><br>
  <br>
  procedure</font> Get_Referents<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Object :
  Proxy_Object;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&nbsp;&nbsp;
  : <font color="#0000FF"> in out</font> Deposit_Container'Class<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is<br>
   begin</font><br>
  &nbsp;&nbsp; Add<br>
  &nbsp;&nbsp; (&nbsp; List,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object.Storage,<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object.Key<br>
  &nbsp;&nbsp; );<br>
  <font color="#008000"><i>&nbsp;&nbsp; </i></font><i>... </i><font color="#008000"><i>--
  adding other dependencies if any<br>
  </i></font><font color="#0000FF">   end</font>  Get_Referents;<br>
  <br>
  <font color="#0000FF">   procedure</font> Restore<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Source&nbsp; : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer :
  <font color="#0000FF"> in out</font> Integer;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class&nbsp;&nbsp;
  : String;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&nbsp;&nbsp;&nbsp;
  : Deposit_Container'Class;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  Object&nbsp; : <font color="#0000FF"> out</font> Deposit_Ptr<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is</font><br>
  &nbsp;&nbsp; Object&nbsp;&nbsp;&nbsp; : Deposit_Ptr := <font color="#0000FF">new</font>
  Proxy_Object;<br>
  &nbsp;&nbsp; Proxy&nbsp;&nbsp;&nbsp;&nbsp; : Proxy_Object <font color="#0000FF">renames</font>
  Proxy_Object (Result.<font color="#0000FF">all</font>);<br>
  &nbsp;&nbsp; Reference : Self_Reference'Class <font color="#0000FF"> renames</font><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  Self_Reference'Class (Get (List, 1).<font color="#0000FF">all</font>);<br>
  <font color="#0000FF">   begin</font><br>
  &nbsp;&nbsp; Proxy.Storage := Reference.Storage;<br>
  &nbsp;&nbsp; Proxy.Key&nbsp;&nbsp;&nbsp;&nbsp; := Storage_Key (Reference.Key.<font color="#0000FF">all</font>);<br>
  <font color="#008000"><i>&nbsp;&nbsp; </i></font><i>... </i><font color="#008000"><i>--
  restoring the rest of Proxy_Object as necessary</i></font><br>
  <font color="#0000FF">   end</font> Restore;</tt></p>

</blockquote>

<p align="right">
  <a href="#2.9" name="2.10"></a><a href="#2.9"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#3"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>2.10. Visual browsing of a persistent storage</H3>
<p>The package
<a href="http://www.dmitry-kazakov.de/ada/gtkada_contributions.htm#Gtk.Persistent_Storage_Browser">
Gtk.Persistent_Storage_Browser</a> provides 
<a href="http://www.gtk.org">GTK+</a> 
widgets for visual browsing of persistent storages. It is a part of the
<a href="http://www.dmitry-kazakov.de/ada/gtkada_contributions.htm">GtkAda 
contribution</a> software.</p>

<hr><p align="right">
  <A name="3"></A><a href="#2.10"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#3.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H2>3. Sets and Maps</H2>
<a name="Sets_etc"></a>The packages <a href="#Generic_Set"> Generic_Set</a> and <a href="#Generic_Map">
Generic_Map</a> provide sets and associative arrays of private types. Objects in 
a set are directly comparable which makes them distinguishable and so allows to 
decide whether an object is in a set or not. Objects in a map are 
indistinguishable and so an additional object called key is associated with each 
object in the map. In other words a map represents a mapping key to object. Both 
sets and maps are implemented using reference counting which allows a relatively 
efficient assigning of sets and maps.
<p>Note that only objects of non-limited type can be used in sets and maps. To
have sets of limited objects use pointers or <a href="#Handle">handles</a> as
elements. For sets of handles also see
<a href="#Object.Handle.Generic_Set">Object.Handle.Generic_Set</a>. For maps of
strings see
<a href="tables.htm">Tables</a>.</p>
<p align="right">
  <A name="3.1"></A><A href="#3"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#3.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>3.1. Sets</H3>
<p><a name="Generic_Set"></a><a name="Set"></a>The package <a href="#Generic_Set"> Generic_Set</a> defines the type
Set.
An instance of the type is a set of items. One can add to and remove from items
of the  set.
Items of the  set can be accessed using the positive index. They are ordered, so the set implementation may use binary search.  There  is  a  null
item, which is never included into the set and is  used  to  mark free memory slots. The package is
generic and has  the  following
generic parameters:
</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font> Object_Type <font color="#0000FF">is private</font>;<br>
&nbsp;&nbsp;&nbsp;Null_Element : Object_Type;<br>
&nbsp;&nbsp;&nbsp;Minimal_Size&nbsp;: Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp;&nbsp;Increment&nbsp;&nbsp;&nbsp;&nbsp;: Natural&nbsp; := <font color="#1100000">50</font>;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">with function</font> "<font color="#FF0000">&lt;</font>" (<b>Left</b>, <b> Right</b> :
Object_Type) <font color="#0000FF">return</font> Boolean <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">with function</font> &quot;<font color="#FF0000">=</font>&quot; (<b>Left</b>, <b> Right</b> :
Object_Type) <font color="#0000FF">return</font> Boolean <font color="#0000FF">is</font> &lt;&gt;;<br>
<font color="#0000FF">package</font> Generic_Set <font color="#0000FF">is<br>
&nbsp;&nbsp; type </font>Set<font color="#0000FF"> is new </font>
Ada.Finalization.Controlled <font color="#0000FF">with private</font>;<br>
&nbsp;&nbsp; ...</tt></p>
</blockquote>
<p>Here:</p>
<ul>
  <li>Object_Type is the type of set items;</li>
  <li>Null_Element is a value of Object_Type used as a null item;</li>
  <li>Minimal_Size is the minimal number of items by which the internal buffer
    of the set is enlarged. When the first item is put into the set, this will
    be the initial buffer size.</li>
  <li>Increment controls further buffer enlargements. The buffer is enlarged by <i>n</i>*Increment/100,
    where <i> n</i> is the current buffer size. If the evaluated increment of 
  the buffer is less than Minimal_Size
    items, then the
    later is used instead. For instance, if the set size should grow linearly by <i>m</i>
    items per increment, then Minimal_Size=<i>m</i>, Increment=0. If the set
    should grow exponentially, for instance, by doubling its size per increment, then Increment
    should be 100, while Minimal_Size could be the initial non-empty set size.</li>
  <li>&quot;<font color="#FF0000">&lt;</font>&quot; and &quot;<font color="#FF0000">=</font>&quot;
    are used to order items in the set.</li>
</ul>
<p>Sets can be assigned. Assignment makes no deep copy, which is delayed until the
time moment when the original and a copy become different. Items in the set are ordered so that lesser items have
lesser indices, when indexed. The first item in the set has index 1.</p>
<table border="1" cellspacing="0" cellpadding="5">
	<tr>
		<td><i>Note that Generic_Set cannot be instantiated with Object_Type set 
		to Integer or any its subtype. This feature is per design for safety 
		reasons. The elements in the set are enumerated by Integer, so if sets 
		of Integer are required then the Object_Type must be made different from 
		Integer. For example as.</i><blockquote><i><tt><font color="#0000FF">
			type</font> Integer_Object <font color="#0000FF">is new</font> 
			Integer;<br>
			<font color="#0000FF">package</font> Integer_Sets
			<font color="#0000FF">is<br>
&nbsp;&nbsp; new</font> Generic_Set (Object_Type =&gt; Integer_Object, ...);</tt></i></blockquote>
		</td>
	</tr>
</table>
<p>The
following operations are defined on Set:</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out
</font> Set; <b> Item</b>&nbsp; : Object_Type);<font color="#0000FF"><br>
procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out </font> Set;
<b> Items</b> : Set);</tt></blockquote>
<p>These procedures are used to add an item to a set or all items of one set to
another. Nothing happens if the item is already in the set or is a Null_Element.
Note that items are compared using the provided operations &quot;<font color="#FF0000">&lt;</font>&quot; and &quot;<font color="#FF0000">=</font>&quot;.
It is possible that these operations treat different items as same. Only one
item from such equivalence class may be in a set. To control which one will be
inserted use <a href="#Generic_Set.Insert">Insert</a> and <a href="#Generic_Set.Replace">Replace</a>.</p>
<blockquote>
<tt><font color="#0000FF">function </font> Create<font color="#0000FF"> return
  </font>Set;</tt></blockquote>
<p>This function returns an empty set.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Erase
  (<b>Container</b> : <font color="#0000FF"> in out </font> Set);</tt></blockquote>
<p>This procedure removes all items from the set.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Find
(<b>Container</b> : Set; <b> Item</b> : Object_Type)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Integer;</tt></blockquote>
<p>This function is used to find an item in the set <b>Container</b>. The result
is either a positive index of the found item or a negated index of the place
where the item should be if it were in the set.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Get (<b>Container</b> : Set;
<b> Index</b> : Positive)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font>   Object_Type;</tt>
</blockquote>
This function is used to get an item of the set <b>Container</b> using a positive index. Constraint_Error is propagated if <b>Index</b> is wrong.
<blockquote>
<p><tt><font color="#0000FF">function</font> Get_Size
(<b>Container</b> : Set)<font COLOR="#000000">&nbsp;</font><font color="#0000FF">return</font>
Natural;</tt></p>
</blockquote>
<p>This function returns the number of items in the set.</p>
<blockquote>
<tt><font color="#0000FF"><a name="Generic_Set.Insert"></a>procedure</font>   Insert (<b>Container</b>  :<font color="#0000FF"> in out
</font> Set; <b> Item</b>&nbsp;: <font color="#0000FF">in out</font>
Object_Type);</tt></blockquote>
<p>This procedure inserts an item into a set. Nothing happens if the item is
Null_Element. When <b>Container</b> already has an element equivalent to <b>Item</b>,
then <b>Item</b> will not replace it. Instead of that the element from <b>Container</b>
will be returned through <b>Item</b>. So upon completion <b>Item</b> always has
the value of the element in <b>Container</b>.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font>   Insert (<b>Container</b>  :<font color="#0000FF"> in out
</font> Set; <b> Item</b>&nbsp;:
Object_Type; <b>Inserted</b> : <font color="#0000FF">out</font> Boolean);</tt></blockquote>
<p>This procedure inserts an item into a set. <b>Item</b> is inserted only if it 
is not Null_Element and is not already in <b>Container</b>. When inserted <b>
Inserted</b> is set to <i><font color="#1100000">true</font></i>. Otherwise it is 
to <font color="#1100000"><i>false</i></font>..</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Empty
(<b>Container</b> : Set) <font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Container</b> is empty.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font> Is_In
  (<b>Container</b> : Set; <b> Item</b> : Object_Type)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Item</b> is in <b>Container</b>.</p>
<blockquote>
  <p><tt>
  <font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b> Item</b>
&nbsp;: Object_Type);<br>
  <font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Set; <b>Items</b>     : Set);</tt></p>
</blockquote>
<p>These procedures are used to remove items from the set <b>Container</b>.&nbsp;An item can be removed either explicitly, or by specifying a
set of items to be removed. If a particular item is not in the set, then nothing
happens.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Remove
  (<b>Container</b> :<font color="#0000FF"> in out </font> Set; <b> Index</b> : Positive);</tt></p>
</blockquote>
<p>This procedures removes an item from the set <b>Container</b> by its positive 
index. Constraint_Error is propagated when item index is wrong.</p>
<blockquote>
<tt><font color="#0000FF"><a name="Generic_Set.Replace"></a>procedure</font> Replace (<b>Container</b> :<font color="#0000FF"> in out
</font> Set; <b> Item</b> : Object_Type);<font color="#0000FF"><br>
procedure</font> Replace (<b>Container</b> :<font color="#0000FF"> in out </font> Set;
<b> Items</b> : Set);</tt></blockquote>
These procedures are used to add to / replace in an item or all items of a set. Nothing  an  is a
Null_Element. 
Any duplicated items are replaced by new ones. This operation has sense only if 
the equality operation defined on Object_Type does not distinguish some objects.<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">and</font>&quot; (<b>Left</b>, <b> Right</b> : Set)
  <font color="#0000FF"> return</font> Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot;
  <font COLOR="#000000">
&nbsp;</font>(<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font> Set;<br>
  <font color="#0000FF">function</font> &quot;<font color="#FF0000">xor</font>&quot;
  (<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font> Set;</tt></p>
</blockquote>
<p>These functions are conventional set operations - intersection, union,
difference. Difference is defined as a set which items are only in one of the
sets <b>Left</b> and <b>Right</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font>
  &quot;<font color="#FF0000">=</font>&quot; (<b>Left</b>, <b> Right</b> : Set) <font color="#0000FF"> return</font>
  Boolean;</tt></p>
</blockquote>
<p><font color="#1100000"><i>True</i></font> is returned if both sets contain same items.</p>
<p align="right">
  <A name="3.2"></A><A href="#3.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#4"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>3.2. Maps</H3>
<p><a name="Generic_Map"></a><a name="Map"></a>The package
<a href="#Generic_Map">Generic_Map</a> defines the type
Map which represents an associative array.
One can add to and remove from items
of the  map. Each item has an unique key associated with it. In other word a map 
is a function which for a given key yields an item. Items of the map can be also accessed using the positive index. 
Items in the map are ordered according to their keys, so the map implementation may use binary search.  
Reference counting is used for the objects of the type Map, which means that 
assigning Map objects is relatively cheap. The package is
generic and has  the  following
generic parameters:
</p>
<blockquote>
<tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font> Key_Type<font color="#0000FF"> 
is private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Object_Type <font color="#0000FF">is private</font>;<br>
&nbsp;&nbsp;&nbsp;Minimal_Size&nbsp;: Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp;&nbsp;Increment&nbsp;&nbsp;&nbsp;&nbsp;: Natural&nbsp; := <font color="#1100000">50</font>;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">with function</font> "<font color="#FF0000">&lt;</font>" (<b>Left</b>, <b> Right</b> :
Key_Type) <font color="#0000FF">return</font> Boolean <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">with function</font> &quot;<font color="#FF0000">=</font>&quot; (<b>Left</b>, <b> Right</b> :
Key_Type) <font color="#0000FF">return</font> Boolean <font color="#0000FF">is</font> &lt;&gt;;<br>
<font color="#0000FF">package</font> Generic_Map <font color="#0000FF">is<br>
&nbsp;&nbsp; type</font> Map <font color="#0000FF">is new</font> 
Ada.Finalization.Controlled <font color="#0000FF">with private</font>;<br>
&nbsp;&nbsp; ...</tt>
</blockquote>
<p>Here:</p>
<ul>
  <li>Key_Type is the type of the association keys;</li>
  <li>Object_Type is the type of map items;</li>
  <li>Minimal_Size is the minimal number of items by which the internal buffer
    of the map is enlarged. When the first item is put into the map, this will
    be the initial buffer size.</li>
  <li>Increment controls further buffer enlargements. The buffer is enlarged by <i>n</i>*Increment/100,
    where <i> n</i> is the current buffer size. If the evaluated increment of 
  the buffer is less than Minimal_Size
    items, then the
    later is used instead.</li>
  <li>&quot;<font color="#FF0000">&lt;</font>&quot; and &quot;<font color="#FF0000">=</font>&quot;
    are used to order keys of the items in the map.</li>
</ul>
<p>Both Key_Type and Object_Type can be controlled. The implementation warranties 
that when an item or key is no more used in the map it is erased by assigning it a 
value created by the default constructor (if any). This behavior ensures that items 
and keys removed from the map will be always finalized upon the operation. For 
example, when Object_Type is controlled, then Finalize will be called upon an 
item of Object_Type even if the item is not replaced but removed from a map. 
This happens through assigning some other object of Object_Type to the removed 
item. So when item is a <a href="#Handle">Handle</a>, then the reference count 
of an object it refers will be decreased as expected. On assignment no deep copy of a map is made. Deep copy is 
postponed till the
time moment when the original and a copy become different. Items in the map are ordered 
according to their keys, so that items with lesser keys have lesser indices, 
when indexed. The first item in the map has index 1.</p>
<table border="1" cellspacing="0" cellpadding="5">
	<tr>
		<td><i>Note that Generic_Map cannot be instantiated with Integer or any 
		its subtype as Key_Type. This feature is per design for safety reasons. 
		The objects in the map are enumerated by Integer, so if maps indexed by 
		Integer are required then the Key_Type must be made different from 
		Integer. For example as:</i><blockquote><i><tt><font color="#0000FF">
			type</font> Integer_Key <font color="#0000FF">is new</font> Integer;<br>
			<font color="#0000FF">package</font> Integer_Maps
			<font color="#0000FF">is<br>
&nbsp;&nbsp; new </font>Generic_Map (Key_Type =&gt; Integer_Key, ...);</tt></i></blockquote>
		</td>
	</tr>
</table>
<p>The
following operations are defined on the type Map:</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Add<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Container</b> :<font color="#0000FF"> in out
</font> Map;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</b>&nbsp;: Key_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b> Item</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></blockquote>
<p>This procedure adds a new item (<b>Item</b>) to the map <b>Container</b>. 
Constraint_Error propagates if <b>Container</b> already contains an item with 
the key equal to <b>Key</b>.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Add (<b>Container</b> :<font color="#0000FF"> in out </font> 
Map;
<b> Items</b> : Map);</tt>
</blockquote>
<p>This procedure adds all items of <b>Items</b> to <b>Container</b>. If <b>
Container</b> already has an item with the key equal to an item from <b>Items</b>, 
then that item from <b>Items</b> is ignored.</p>
<blockquote>
<tt><font color="#0000FF">function </font> Create<font color="#0000FF"> return
  </font>Map;</tt></blockquote>
<p>This function returns an empty map.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Erase
  (<b>Container</b> : <font color="#0000FF"> in out </font> Map);</tt></blockquote>
<p>This procedure removes all items from <b>Container</b>.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Find
(<b>Container</b> : Map; <b> Key</b> : Key_Type)&nbsp;<font color="#0000FF">return</font> Integer;</tt></blockquote>
<p>This function is used to find an item in the map <b>Container</b>. The result
is either a positive index of the found item or a negated index of the place
where the item should be if it were in the map.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Get (<b>Container</b> : Map; <b>Key</b>
: Key_Type)&nbsp;<font color="#0000FF">return</font>   Object_Type;</tt></blockquote>
<p>This returns an item of the map <b>Container</b> by its key. Constraint_Error 
is propagated if there is no item with the key equal to <b>Key</b>.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Get (<b>Container</b> : Map;
<b> Index</b> : Positive)&nbsp;<font color="#0000FF">return</font>   Object_Type;</tt></blockquote>
<p>This function is used to get an item of the map <b>Container</b> using
positive index. Constraint_Error is propagated if <b>Index</b> 
is wrong. Note that item 
index may change when items are added or removed.</p><blockquote>
<tt><font color="#0000FF">function</font> Get_Key (<b>Container</b> : Map;
<b> Index</b> : Positive)&nbsp;<font color="#0000FF">return</font>   Key_Type;</tt>
</blockquote>
This functions returns the key of an item in <b>Container</b>. Constraint_Error is propagated if <b>Index</b> is wrong.<blockquote>
<p><tt><font color="#0000FF">function</font> Get_Size
(<b>Container</b> : Map)<font COLOR="#000000">&nbsp;</font><font color="#0000FF">return</font>
Natural;</tt></p>
</blockquote>
<p>This function returns the number of items in the map.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Empty
(<b>Container</b> : Map) <font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Container</b> is empty.</p>
<blockquote>
  <p><tt><font color="#0000FF">function</font> Is_In
  (<b>Container</b> : Map; <b>Key</b> : Key_Type)<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>True is returned if <b>Container</b> has an item for <b>Key</b>.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Map; <b> Item</b>
&nbsp;: Key_Type);<br>
  <font color="#0000FF">procedure</font> Remove (<b>Container</b> :<font color="#0000FF"> in out
  </font> Map; <b>Items</b>     : Set);</tt></p>
</blockquote>
<p>These procedures are used to remove items from the map <b>Container</b>.&nbsp;An item can be removed either by its key, or by specifying a
map of items to be removed. If a particular item is not in the map, then nothing
happens.</p>
<blockquote>
  <p><tt><font color="#0000FF">procedure</font> Remove
  (<b>Container</b> :<font color="#0000FF"> in out </font> Map; <b> Index</b> : Positive);</tt></p>
</blockquote>
<p>This procedures removes an items from the map <b>Container</b> by its 
positive index.&nbsp;Constraint_Error is propagated when item index is wrong.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Replace<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Container</b> :<font color="#0000FF"> in out
</font> Map;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Key</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Key_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b> Item</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
procedure</font> Replace<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Container</b> :<font color="#0000FF"> in out </font> 
Map;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b> Items&nbsp;&nbsp;&nbsp; </b>&nbsp;: Map<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></blockquote>
These procedures are used to add or replace items. An can be either added or replaced by its key. That is when Container 
does contain an item with the key equal to <b>Key</b>, then it is replaced by <b>
Item</b>, otherwise <b>Item</b> is added under <b>Key</b>. The second&nbsp; variant 
adds or replaces all items from the map <b>Items</b>.<blockquote>
<tt><font color="#0000FF">procedure</font> Replace<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Container</b> :<font color="#0000FF"> in out
</font> Map;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Index</b>&nbsp;&nbsp;&nbsp;&nbsp; : Positive;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b> Item</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></blockquote>
This procedure replaces an items by its positive index. Contraint_Error is propagated 
when <b>Index</b> is wrong.<hr><p align="right">
  <A name="4"></A><A href="#3.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#5"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H2>4. Unbounded arrays</H2>
<p><a name="Generic_Unbounded_Array"></a><a name="Unbounded_Array"></a>
<a name="Unbounded_arrays_etc"></a>The package
<a href="#Generic_Unbounded_Array"> Generic_Unbounded_Array</a> defines the type
<a href="#Generic_Unbounded_Array">Unbounded_Array</a>. An instance of the type
is  a  dynamically  expanded  vector  of elements. The implementation keeps vector contiguous,  so  it  might  be
very  inefficient to put complex data structures into the array. In many cases it  is  better  to  put  pointers  to  elements  there.  See  also
the package <a href="#Generic_Unbounded_Ptr_Array"> Generic_Unbounded_Ptr_Array</a>  which instantiates
<a href="#Generic_Unbounded_Array"> Generic_Unbounded_Array</a> for this purpose.
The type wraps the component Vector which is a pointer to an array of elements.  One  can use Vector to access array elements
and query its present bounds, which are rather arbitrary. The unused&nbsp; elements  of
the array vector are padded using a distinguished null-element value The package
<a href="#Generic_Unbounded_Array"> Generic_Unbounded_Array</a>  is generic and has  the  following
generic parameters:
</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  </font>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font> Index_Type
  <font color="#0000FF"> is</font> (&lt;&gt;);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font> Object_Type<font color="#0000FF"> is private</font>; <br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font> Object_Array_Type<font color="#0000FF"> is<br>
 </font> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">array </font> (Index_Type <font color="#0000FF"> range</font> &lt;&gt;)
  <font color="#0000FF"> of </font> Object_Type;<br>
&nbsp;&nbsp;&nbsp;Null_Element : Object_Type;<br>
&nbsp;&nbsp;&nbsp;Minimal_Size&nbsp;: Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp;&nbsp;Increment&nbsp;&nbsp;&nbsp;&nbsp;: Natural&nbsp; := <font color="#1100000">50</font>;<br>
  <font color="#0000FF">
  package </font> Generic_Unbounded_Array<font color="#0000FF"> is </font>...</tt></p>
</blockquote>
<p>Here:
</p>
<ul>
  <li>Index_Type is the type used to index the array elements;</li>
  <li>Object_Type is the type of array elements;</li>
  <li>Object_Array_Type is an array type built on Index_Type and Object_Type.
    This is the type of the array's vector;</li>
  <li>Null_Element is a value of Object_Type used as a null element;</li>
  <li>Minimal_Size is the minimal number of elements by which the array vector is enlarged. When the first
    element is put into the array, this will
    be the initial vector size.</li>
  <li>Increment governs further vector enlargements. The vector is enlarged by <i>n</i>*Increment/100,
    where <i> n</i> is the current vector size. If the evaluated increment of 
  the vector is less than Minimal_Size
    elements, then the latter is used instead.</li>
</ul>
<p>The type
<a href="#Generic_Unbounded_Array">Unbounded_Array</a> is declared as follows:</p>
<blockquote>
  <p><tt><font color="#0000FF">   type
  </font>
 Object_Array_Ptr<font color="#0000FF"> is access
  </font>
  Object_Array_Type;<font color="#0000FF"><br>
   type
  </font>
 Unbounded_Array<font color="#0000FF"> is<br>
  </font>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">new
  </font>
 Ada.Finalization.Limited_Controlled <font color="#0000FF"> with<br>
   record<br>
  </font>
&nbsp;&nbsp;&nbsp;Vector : Object_Array_Ptr := <font color="#0000FF">null</font>;<font color="#0000FF"><br>
   end record</font>;</tt></p>
</blockquote>
<p>Array elements can be accessed through indexing the component Vector. Note
that single what can be said about the length of the vector is that it is big
enough to keep all elements put into the array. The unused elements in the
vector are padded using the value Null_Element. The implementation is very
straightforward. It does not implement any optimization of assignments, like the
implementation of <a href="#Generic_Set">Generic_Set</a> does. This choice was
intentionally made to mimic arrays as close as possible. If reference counting
is needed a wrapper type could be built around
<a href="#Generic_Unbounded_Array">Unbounded_Array</a>. The following operations are
defined on <a href="#Generic_Unbounded_Array">Unbounded_Array</a>:</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Erase
  (<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array);</tt></p>
</blockquote>
<p>This procedure removes all elements from <b>Container</b> making it empty.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Finalize
  (<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array);</tt></blockquote>
<p>The destructor frees the memory allocated for the array vector.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Fetch<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(
&nbsp;<b>Container</b>&nbsp;:&nbsp;Unbounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;<font color="#0000FF">return</font>   Object_Type;</tt></blockquote>
<p>This function returns a container element or Null_Element if <b>Index</b> is out of vector range.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(
&nbsp;<b>Container</b>&nbsp;:&nbsp;Unbounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
&nbsp;<font color="#0000FF">return</font>   Object_Type;</tt></blockquote>
<p>This function is an equivalent to <b>Container</b>.Vector (<b>Index</b>).
Constraint_Error is propagated if <b>Index</b> is out of vector range.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(
&nbsp;<b>Container</b> : <font color="#0000FF"> in out </font> Unbounded_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;     :
Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Element</b>&nbsp;&nbsp;   : Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</tt>
</blockquote>
This procedure is used to put / replace an element in array using its index.
The array vector is expanded as necessary. Unused elements are padded with
Null_Element.
<hr>
<p align="right">
  <A name="5"></A><A href="#4"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#6"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H2>5. Unbounded arrays of pointers</H2>
<p><a name="Generic_Unbounded_Ptr_Array"></a><a name="Unbounded_Ptr_Array"></a>The package
<a href="#Generic_Unbounded_Ptr_Array">Generic_Unbounded_Ptr_Array</a> defines the type
<a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a>. An instance of <a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a> is  a  dynamically  expanded
vector  of pointers to elements. Upon destruction objects pointed by array  elements  are  destroyed.  Same  happens  when  an element is
replaced. The package has the following generic parameters:</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  </font>
  &nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Index_Type<font color="#0000FF"> is
  </font>
 (&lt;&gt;);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Object_Type (&lt;&gt;)<font color="#0000FF"> is limited private</font>;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Object_Ptr_Type<font color="#0000FF"> is access
  </font>
  Object_Type;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Object_Ptr_Array_Type is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000FF">array
  </font>
  (Index_Type <font color="#0000FF"> range
  </font>
 &lt;&gt;) <font color="#0000FF"> of
  </font>
  Object_Ptr_Type;<br>
&nbsp;&nbsp;&nbsp;Minimal_Size&nbsp;: Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp;&nbsp;Increment&nbsp;&nbsp;&nbsp;&nbsp;: Natural&nbsp; := <font color="#1100000">50</font>;<br>
  <font color="#0000FF">
  package
  </font>
 Generic_Unbounded_Ptr_Array<font color="#0000FF"> is
  </font>
  ...</tt></p>
</blockquote>
<p>Here:</p>
<ul>
  <li>Index_Type is the type used to index the array elements;</li>
  <li>Object_Type is the type of array elements;</li>
  <li>Object_Ptr_Type is an access type for Object_Type;</li>
  <li>Object_Array_Ptr_Type is an array type built on Index_Type and
    Object_Ptr_Type. This is the type of the array's vector;</li>
  <li>Minimal_Size is the minimal number of elements by which the array vector is enlarged. When the first
    element is put into the array, this will
    be the initial vector size.</li>
  <li>Increment governs further vector enlargements. The vector is enlarged by <i>n</i>*Increment/100,
    where <i> n</i> is the current vector size. If the evaluated increment of 
  the vector is less than Minimal_Size
    elements, then the latter is used instead.</li>
</ul>
<p>The type <a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a> is declared
through an instantiation of the package <a href="#Generic_Unbounded_Array">Generic_Unbounded_Array</a>.
Array elements can be accessed through indexing the component Vector which are
pointers to the elements. Note that single what can be said about the length of
the vector is that it is big enough to keep all elements put into the array. The
unused elements in the vector are padded using <font color="#0000FF">null</font>.
The following operations are defined on <a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a>:</p>
<blockquote>
<p>
<tt><font color="#0000FF">procedure</font> Erase
  (<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Array);</tt></p>
</blockquote>
<p>This procedure removes all elements from <b>Container</b> making it empty.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Finalize
  (<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Ptr_Array);</tt></blockquote>
<p>The destructor frees the memory allocated for the array vector and all elements it refers to.</p>
<blockquote>
<tt><font color="#0000FF">function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;<b>Container</b> :
Unbounded_Ptr_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>Index</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;<font color="#0000FF">return</font> 
 Object_Ptr_Type;</tt></blockquote>
<p>This function is an equivalent to <b>Container</b>.Vector (<b>Index</b>) with 
the exception that <font color="#0000FF">null</font> is returned when <b>Index</b> is out of vector range.</p>
<blockquote>
<tt><font color="#0000FF">   procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;             (
&nbsp;<b>Container</b> : <font color="#0000FF"> in out </font>Unbounded_Ptr_Array;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Index</b>
&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;<b>                Element</b>
&nbsp;   : Object_Ptr_Type<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;             );</tt>
</blockquote>
<p>This procedure is used to put in / replace an array element using its index. If the replaced array element is not 
<font color="#0000FF">null</font> then the object it points
to is destroyed.
Note that the object pointed by Element is not copied. Thus it is not a responsibility of the caller to destroy  the  object.  It  will  be
automatically  destroyed upon  array destruction  or replacing the element in the array.
The array vector is expanded as necessary. Unused elements are padded with 
<font color="#0000FF">null</font>.</p>
<p>The implementation of
<a href="#Generic_Segmented_Stack">Generic_Segmented_Stack</a> provides an 
illustration of use
<a href="#Generic_Unbounded_Ptr_Array">Generic_Unbounded_Ptr_Array</a>. A 
segmented stack consists of segments of same size. The list of segments is 
viewed as an abstract array used to instantiate <a href="#Generic_Stack">
Generic_Stack</a>. The array index is split into the high-order index indicating 
a segment and the low-order one specifying the element in the segment. The list
of segments is implemented as an
<a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a> indexed by the high-order 
index. Observe that once allocated a segment gets referenced in
<a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a>, so there is no need to 
explicitly deallocate segments,
<a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a> willl do it. So the 
implementation of <a href="#Generic_Segmented_Stack">Generic_Segmented_Stack</a> 
can be as straightforward as:</p><ul>
<li>Declaration of the type of segments as a fixed sized array of stack 
elements;</li>
<li>Instantiation of
<a href="#Generic_Unbounded_Ptr_Array">Generic_Unbounded_Ptr_Array</a> using the 
segment type;</li>
<li>Instantiation of <a href="#Generic_Stack">Generic_Stack</a> based on that 
unbounded array. </li>
</ul>
<hr><p align="right">
  <A name="6"></A><A href="#5"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#6.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H2>6. Stacks</H2>
<P><a name="Stacks_etc"></a>Stack, also LIFO Stack (Last in
First Out), is a container in which the only accessible element is the last one.</p><p align="right">
  <A name="6.1"></A><A href="#6"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#6.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>6.1. Stacks based on abstract arrays</H3>
<p><a name="Generic_Stack"></a><a name="Stack"></a>The package
<a href="#Generic_Stack">Generic_Stack </a>defines the type <a href="#Stack">
Stack</a> which provides a generic stack. The stack is built upon an array type 
which might be a <a href="#Unbounded_Array">Unbounded_Array</a>, <a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a>, 
array of handles or some other type (like Unbounded_String). The package has the following generic parameters:</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  </font>
  &nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Index_Type<font color="#0000FF"> is
  </font>
 (&lt;&gt;);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Object_Type (&lt;&gt;)<font color="#0000FF"> is limited private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Array_Type <font color="#0000FF">
  is limited private</font>;<br>
&nbsp;&nbsp; Null_Element : Object_Type;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  (&nbsp; Container : Array_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  Index&nbsp;&nbsp;&nbsp;&nbsp; : Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  )&nbsp; <font color="#0000FF">return</font> Object_Type <font color="#0000FF">
  is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure </font>Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  (&nbsp; Container : <font color="#0000FF">in out </font>Array_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  Index&nbsp;&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  Element&nbsp;&nbsp; : Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  )&nbsp; <font color="#0000FF">is</font> &lt;&gt;;<br>
  <font color="#0000FF">package</font> Generic_Stack <font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Stack <font color="#0000FF">is 
  new </font>Ada.Finalization.Limited_Controlled <font color="#0000FF">with 
  private</font>;</tt></p>
</blockquote>
<p>Here the formal parameters are:
</p>
<ul>
  <li>Index_Type is the type used to index the array elements;</li>
  <li>Object_Type is the type of array / stack elements;</li>
  <li>Array_Type is a private limited type implementing an array indexed by Index_Type and
    containing Object_Ptr_Type;</li>
  <li>Null_Element is a value of Object_Type used as a null element. The items 
  removed from the stack are always padded with Null_Element. This warranties 
  that for a stack built on <a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a> 
  the popped items will be indeed destroyed. Observe that for this reason a 
  function Pop is not provided, because there is no safe way to return a popped 
  object without copying it;</li>
  <li>Get is the function used to get an array element by its index. It is never 
  called for elements which were not previously put using the procedure Put. 
  Thus any range checks can be omitted;</li>
  <li>Put is the procedure used to store array elements. When it is called for 
  some array new index, for which it was not called before, then the index value 
  is the next following the last new index. In other words the array grows by one 
  element at time. The stack can have a limited size. If so then Put is allowed 
  to 
  raise an exception when the value of the parameter Index is out of limit.</li>
</ul>
<p>The following operations are defined on <a href="#Stack">Stack</a>:</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Erase (<b>Container</b> :
  <font color="#0000FF">in out </font>Stack);</tt></blockquote>
<p>This procedure pops all items from the stack <b>Container</b>.</p><blockquote>
  <tt><font color="#0000FF"><a name="Generic_Stack.Get"></a>function</font> Get (<b>Container</b> : Stack; <b>
  Index</b> : Index_Type)<br>
&nbsp;<font color="#0000FF">&nbsp; return</font>   Object_Type;</tt></blockquote>
<p>This function returns the  stack item with the index specified by the
parameter <b>Index</b>. The item item on the stack top has the index returned by
<a href="#Generic_Stack.Mark">Mark</a>, so that</p>
<blockquote>
  <tt>Top&nbsp;(Container) = Get&nbsp;(Container,&nbsp;Mark&nbsp;(Container))</tt></blockquote>
<p>Constraint_Error is propagated if <b>Index</b> points out of stack.</p>
<blockquote>
  <tt><font color="#0000FF">function</font> Is_Empty (<b>Container</b> :
  Stack) <font color="#0000FF">return</font> Boolean;</tt></blockquote>
<p>This function returns <i><font color="#1100000">true</font></i> if Container
  is empty.</p><blockquote>
<tt><font color="#0000FF"><a name="Generic_Stack.Mark"></a>function</font>
  Mark (<b>Container</b> : Stack) <font color="#0000FF">return</font> 
 Index_Type;</tt></blockquote>
<p>The value returned by this function can be used in the procedure
  <a href="#Generic_Stack.Release">Release</a> to pop all the items pushed in
  between. When the type Index_Type is an integer type, then the difference
  between two values returned by <a href="#Generic_Stack.Mark">Mark</a> is the
  number of stack items.</p><blockquote>
  <tt><font color="#0000FF">procedure</font> Pop (<b>Container</b> :
  <font color="#0000FF">in out </font>Stack; <b>Count</b> : Natural :=
  <font color="#1100000">1</font>);</tt></blockquote>
  <P>This procedure pops <b>Count</b> items from the top of <b>Container</b>. If 
  the stack does not contain enough items, it is emptied.</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Push (<b>Container</b> :
  <font color="#0000FF">in out </font>Stack; <b>Item</b> : Object_Type);</tt></blockquote>
  <P>This procedure pushes <b>Item</b> onto <b>Container</b>.</p><blockquote>
  <tt><font color="#0000FF">procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Container</b> : 
  <font color="#0000FF">in out</font> Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Index</b>&nbsp;&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
  Element</b>&nbsp;&nbsp; : Object_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></blockquote>
  <P>This procedure replaces the stack item specified by the parameter <b>Index</b>
  with <b>Element</b>. The index is same as described in
  <a href="#Generic_Stack.Get">Get</a>. Constraint_Error is 
  propagated if <b>Index</b> points out of stack.</p><blockquote>
  <tt><font color="#0000FF"><a name="Generic_Stack.Release"></a>procedure</font>
  Release (<b>Container</b> : in out Stack; <b>Mark</b> : Index_Type);</tt></blockquote>
  <P>This procedure is used to pop all items pushed since a call to the function
  <a href="#Generic_Stack.Mark">Mark</a> which result was the value of the 
  parameter <b>Mark</b>. Nothing happens if the stack was already popped below
  <b>Mark</b>.</p><blockquote>
  <P><tt><font color="#0000FF">function</font> Top (<b>Container</b> : Stack)
  <font color="#0000FF">return</font>   Object_Type;</tt></p></blockquote>
  <P>This function returns the topmost stack item. Constraint_Error is
  propagated if <b>Container</b> is empty.</p><p align="right">
  <A name="6.2"></A><A href="#6.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#7"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>6.2. Segmented stacks</H3>
<p><a name="Generic_Segmented_Stack"></a>The package
<a href="#Generic_Segmented_Stack">Generic_Segmented_Stack</a> instantiates <a href="#Generic_Stack">Generic_Stack</a> 
so that the stack will use a list of segments of same 
size. The number of stack segments is unlimited. New segments are allocated as 
necessary. The package is generic:</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  </font>
  &nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Index_Type<font color="#0000FF"> is
  </font>
 (&lt;&gt;);<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type
  </font>
 Object_Type <font color="#0000FF"> is  private</font>;<br>
&nbsp;&nbsp; Null_Element : Object_Type;<br>
&nbsp;&nbsp; Segment_Size : Positive := <font color="#1100000">128</font>;<br>
&nbsp;&nbsp; Minimal_Size : Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp; Increment&nbsp;&nbsp;&nbsp; : Natural&nbsp;&nbsp;:=
  <font color="#1100000">50</font>;<br>
  <font color="#0000FF">package</font> Generic_Segmented_Stack
  <font color="#0000FF">is<br>
&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; package</font> Segmented_Stack <font color="#0000FF">is new </font>
  Generic_Stack ...</tt></p>
</blockquote>
<p><a name="Generic_Segmented_Stack_parameters"></a>Here the formal parameters are:</p>
<ul>
  <li>Index_Type is the type used to index the stack elements. It can be used to
  <a href="#Generic_Stack.Mark">mark</a> and <a href="#Generic_Stack.Release">
  release</a> the stack;</li>
  <li>Object_Type is the type of the stack elements;</li>
  <li>Null_Element is a value of Object_Type used as a null element. The items 
  removed from the stack are always padded with Null_Element;</li>
  <li>Segment_Size is the size of a stack segment in slots;</li>
  <li>Minimal_Size of the segment slots array. This parameter and the next one 
  control allocation of the array segment slots;</li>
  <li>Increment. When there is no free space the stack is enlarged by allocation 
  a new segment. A reference to the segment is placed in an array of the segment 
  slots. That array is enlarged by allocating Size * Increment / 100 new slots. 
  Here Size is the current number of slots. The allocated amount of slots cannot 
  be less than the parameter Minimal_Size specifies. So it will be the initial 
  size after the first segment gets allocated.</li>
</ul>
<p>The package can be used as follows:</p>
<blockquote>
<p><tt><font color="#0000FF">package</font> Float_Stack <font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">new</font> Generic_Segmented_Stack (Integer, Float,
<font color="#1100000">0.0</font>);<br>
<font color="#0000FF">use</font>   Float_Stack.Segmented_Stack;<br>
...<br>
LIFO : Stack;</tt></p>
</blockquote>
  <hr>  <p align="right">
  <A name="7"></A><A href="#6.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#7.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H2>7. Pools</H2>
<P><a name="Pools_etc"></a>User-defined storage pools can be
used for objects which creation / destruction policy allows a more efficient 
memory management strategy than the standard heap offers, but yet not enough 
strict to allocate them on the system stack.</p><p align="right">
  <A name="7.1"></A><A href="#7"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#7.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H3>7.1. Stack pool</H3>
<p><a name="Stack_Storage"></a><a name="Stack_Storage.Pool"></a>The package <a href="#Stack_Storage">
Stack_Storage</a> provides an implementation of a user-defined pool organized as 
a stack. The package the type <a href="#Stack_Storage.Pool">Pool</a> derived form
System.Storage_Pools.Root_Storage_Pool:</p>
<blockquote>
  <p><tt><font color="#0000FF">type</font>
  Pool<br>
&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Initial_Size : Storage_Count;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Items_Number : Positive<br>
&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is new</font>
  Root_Storage_Pool <font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>A stack pool consists of contiguous segments allocated dynamically as 
necessary. The discriminants control the stack segments allocation policy. <b>
Initial_Size</b> determines the initial default size of a newly allocated 
segment. If this size is less than the size of the object being allocated the 
default size is set to the object size multiplied to <b>Items_Number</b>. This 
value will then used as the default size for all further segments. The segments 
allocated earlier having lesser size will be freed when possible. Otherwise, 
they remain allocated until pool destruction. Upon stack pool destruction, all 
the stack segments are deallocated. No checks made whether some objects remain 
allocated on the stack. Note also that no checks made whether objects allocation 
/ deallocation order is indeed LIFO (last in, first out). Deallocation of an 
object frees the memory of all objects allocated after it. <i>The stack pool is 
<u>not</u> task-safe. If that is required it has to be protected from a concurrent
access</i>.</p>
<p align="right">
  <A name="7.2"></A><A href="#7.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#8"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>7.2. Mark and release pool for controlled objects</H3>
<p><a name="Stack_Storage.Mark_And_Release"></a>The generic 
child package <a href="#Stack_Storage.Mark_And_Release">Stack_Storage.Mark_And_Release</a> provides an implementation of a 
mark and release pool for limited controlled objects:</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; </font>Stack : <font color="#0000FF">in out</font>   Pool'Class;<font color="#0000FF"><br>
  package</font> Stack_Storage.Mark_And_Release <font color="#0000FF">is</font> 
  ...</tt></p>
</blockquote>
<p><a name="Pool_Object"></a>The generic parameter Stack is a descendant of <a href="#Stack_Storage.Pool">
Pool</a>, a stack pool. The package defines:</p>
<blockquote>
<p><tt><font color="#0000FF">type </font>Pool_Object<font color="#0000FF"> is<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Limited_Controlled <font color="#0000FF">
with private</font>;</tt></p>
</blockquote>
<p>This is the base type for all objects to be allocated on Stack. The pool 
objects should be allocated only in the pool (using an allocator
<font color="#0000FF">new</font>). If they are destroyed explicitly using
Unchecked_Deallocation, then it should happen LIFO and never under the last
<a href="#Pool_Mark">pool mark</a>. The type <a href="#Pool_Object">Pool_Object</a> 
has the following operations:</p>
<blockquote>
<tt><font color="#0000FF">procedure</font> Finalize
  (<b>Object</b> : <font color="#0000FF"> in out </font>Pool_Object);</tt></blockquote>
<p>The destructor has to be called by all descendants of <a href="#Pool_Object">
Pool_Object</a>. Storage_Error is propagated if <b>Object</b> is not the last
allocated object in the pool.</p><blockquote>
<tt><font color="#0000FF">procedure</font> Initialize
  (<b>Object</b> : <font color="#0000FF"> in out </font>Pool_Object);</tt></blockquote>
The constructor has to be called by all descendants.<blockquote>
<p><tt><font color="#0000FF">type </font>Pool_Object_Ptr<font color="#0000FF"> 
is access</font>   Pool_Object'Class;<font color="#0000FF"><br>
for </font>Pool_Object_Ptr'Storage_Pool <font color="#0000FF">use</font> Stack;</tt></p>
</blockquote>
<p>This is the access type, which can be used as the target for an allocator of 
a <a href="#Pool_Object">Pool_Object</a> descendant. If other access type used 
as the target, then it has to be specific to the pool Stack.</p>
<blockquote>
<tt><font color="#0000FF"><a name="Pool_Mark"></a>type</font> Pool_Mark
<font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">new</font> 
Ada.Finalization.Limited_Controlled<font color="#0000FF"> with private</font>;</tt></blockquote>
<p>Objects of <a href="#Pool_Mark">Pool_Mark</a> are used as snap-shots of the
pool state. When such a pool mark object is created it remembers the pool state. 
Upon its destruction it finalizes all the objects allocated in the pool since 
its construction and reclaims the storage occupied by the objects. If some pool
objects have to be destroyed explicitly, then that shall be ones created after the last pool 
mark creation only. The following operations are defined on <a href="#Pool_Mark">
Pool_Mark</a>:</p>
<blockquote><tt><font color="#0000FF">procedure</font> Finalize
  (<b>Snap</b> : <font color="#0000FF"> in out </font>Pool_Mark);</tt></blockquote>
<p>The destructor removes all objects remaining in the pool since construction 
of <b>Snap</b>. Storage_Error is propagated on object finalization errors.</p>
<blockquote><tt><font color="#0000FF">procedure</font> Initialize
  (<b>Snap</b> : <font color="#0000FF"> in out </font>Pool_Mark);</tt></blockquote>
<p>The constructor remembers the pool state.</p>
<p>The following short code sample
illustrates use of mark and release pool:</p>
<blockquote>
<tt><font color="#0000FF">declare</font><br>
&nbsp;&nbsp; Snap : Pool_Mark;<font color="#008000">&nbsp; -- Mark the pool 
state</font><br>
&nbsp;&nbsp; Ptr&nbsp; : Pool_Object_Ptr;<font color="#0000FF"><br>
begin</font><br>
&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; Ptr := <font color="#0000FF">new </font>Derived_Pool_Object;<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-- Allocate</font><br>
&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; Ptr := <font color="#0000FF">new</font> 
 Another_Derived_Pool_Object;
<font color="#008000">-- Allocate</font><br>
&nbsp;&nbsp; ...<br>
<font color="#0000FF">end</font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- Release all allocated objects</font></tt></blockquote>
<hr>

<p align="right">
  <a href="#8" name="8"></a><a href="#7.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#8.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<h2>8. Doubly-linked networks</h2>
<p><a name="Generic_Doubly_Linked_Web"></a>The generic package
<a href="#Generic_Doubly_Linked_Web">Generic_Doubly_Linked_Web</a> provides 
double-linked networks of items:</p>

<blockquote>
  <p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>List_Identification_Type <font color="#0000FF">is</font> 
	(&lt;&gt;);<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> List_Item_Type (&lt;&gt;)
	<font color="#0000FF">is limited private</font>;<br>
&nbsp;&nbsp; Pool : <font color="#0000FF">in out</font> Root_Storage_Pool'Class;<br>
	<font color="#0000FF">package</font> Generic_Doubly_Linked_Web
	<font color="#0000FF">is</font> ...</tt></p>

</blockquote>

<p>The items can be of any type as specifies the formal parameter List_Item_Type. 
This includes limited and unconstrained types. They are not required to be 
tagged. So protected objects or tasks can be items. The items are never copied when inserted 
into, moved along or 
removed from a list. All operations on the network lists and their items are 
referential. Insertion and removal are <i>O</i>(1). An item of the network may participate several lists of different types. The set 
of distinct list types is determined by the formal parameter List_Identification_Type, which is a discrete type. For each value of this type 
each item has a pair of pointers (links). So the number of values of List_Identification_Type is the number of lists an item can be simultaneously 
situated in. For a standard doubly-linked list where an item can be in only one 
list, the parameter List_Identification_Type could be, for example: </p>
<p><tt><font color="#0000FF">&nbsp;&nbsp; type </font>List_Identification
<font color="#0000FF">is</font> (The_List);</tt></p>
<p>For multiple lists as illustrated on the figure below, it could be: </p>
<p><tt><font color="#0000FF">&nbsp;&nbsp; type </font>List_Identification
<font color="#0000FF">is</font> (Blue, Green, Red);</tt></p>
<blockquote>
	<p><img border="0" src="d_l_lists.gif" width="499" height="544"></p>
</blockquote>

<p>The figure shows 5 items forming a network of 4 lists of 3 different types. For instance, 
the item B is in the <i>blue</i> list A-B-C-D, <i>green</i> list B-C-D and <i>red</i> list B-C-D-E.</p>
<p>The items are allocated in the storage pool specified by the formal parameter 
Pool. The service data (links) associated with an item are allocated in Pool.</p>
<p>The package provides the access type
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> for referencing the items 
and the access type <a href="#Generic_Doubly_Linked_Web.Web">Web</a> to 
reference the head items of lists. Note that each list is circular, so any of 
its items can be considered as a head. All list operations are defined in terms 
of <a href="#Generic_Doubly_Linked_Web.Node">Node</a> and
<a href="#Generic_Doubly_Linked_Web.Web">Web</a>. Naturally,
<a href="#Generic_Doubly_Linked_Web.Web">Web</a> and
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> are freely convertible to 
each other:</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Node"></a>type&nbsp;</font>Node<font color="#0000FF">&nbsp;is&nbsp;access&nbsp;</font>List_Item_Type;<font color="#0000FF"><br>
	<a name="Generic_Doubly_Linked_Web.Web"></a>type </font>Web<font color="#0000FF">&nbsp;is&nbsp;new&nbsp;</font>Node;</tt></p>
	<blockquote>
		<i>A distinct type was chosen to separate pointers to items from ones to lists. 
		This was important for aliasing prevention. For example if </i>
		<a href="#Generic_Doubly_Linked_Web.Node">Node</a><i> were used in
	</i><a href="#Generic_Doubly_Linked_Web.Delete">Delete</a><i>, then the following 
	would be legal:</i><blockquote>
			<p><tt>Delete (Messages, List_Head, List_Head);</tt></p>
		</blockquote>
		<p><i>So the operation </i><a href="#Generic_Doubly_Linked_Web.Delete">Delete</a><i> could 
finalize the item referenced by the third parameter, and thus set List_Head to
		</i><font color="#0000FF">null</font><i>. At the same time it would set the second 
parameter to point to the next item in the list, setting List_Head to some not
		</i><font color="#0000FF">null</font><i> value. 
The result would depend on the compiler and the program were erroneous. This 
		manifests an 
aliasing problem, which cannot occur because in&nbsp;</i><a href="#Generic_Doubly_Linked_Web.Delete">Delete</a>
		<i> the second 
parameter has the type </i><a href="#Generic_Doubly_Linked_Web.Web">Web</a><i>, 
		making it impossible to mistakenly alias it to another type.</i></p>
		<p><i>The representation clause</i></p>
		<blockquote>
			<p><tt><font color="#0000FF">for</font> Node'Size 
				<font color="#0000FF">use</font> 
		Integer_Address'Size;</tt></p>
		</blockquote>
		<p><i>is used to prevent the compiler from making &quot;fat&quot; pointers out of 
			</i><a href="#Generic_Doubly_Linked_Web.Node">Node</a> <i>and</i>
		<a href="#Generic_Doubly_Linked_Web.Web">Web</a><i>. This should actually be 
	Address'Size, but that would be illegal because Address'Size is not a static 
	expression in Ada. The type Integer_Address should have same size as Address on almost all 
	architectures. If it is not, change it to an explicit number. Remember that 
	the size is specified in bits.</i></p>
	</blockquote>
</blockquote>
<p>A list item is created by using the allocator <font color="#0000FF">new</font>. The obtained pointer is passed to 
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> (<a href="#Generic_Doubly_Linked_Web.Prepend">Prepend</a>) or 
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a> as appropriate. The 
procedure
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> is used for creating a new list. The list is specified by a pointer to its head. So it can be created like:</p>

<blockquote>
  <p><tt>&nbsp; Head : Web; <font color="#008000">-- Empty list</font><br>
	<font color="#0000FF">begin</font><br>
&nbsp; Append (Messages, Head, <font color="#0000FF">new</font> Object);</tt></p>

</blockquote>
<p>Now Head points to the newly allocated item in the list. Subsequent items can be created as:</p>
<blockquote>
	<p><tt>&nbsp; Append (Messages, Head, <font color="#0000FF">new</font> Object);</tt></p>
</blockquote>
<p>The first parameter of all list operations is the type of the list. If there were several types of lists, we could place the same item into different lists. For example:</p>

<blockquote>
  <p><tt><font color="#0000FF">type</font> Signal <font color="#0000FF">is<br>
&nbsp;&nbsp; new abstract </font>Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with private</font>;<br>
	<font color="#0000FF">type</font> Signal_List <font color="#0000FF">is</font> 
	(Alarm, Log);<br>
	<font color="#0000FF">type</font> Some_Ptr <font color="#0000FF">is access
	</font><i>Any</i>; <font color="#008000">-- The default storage pool</font><br>
	<font color="#0000FF">package</font> Signal_Lists <font color="#0000FF">is<br>
&nbsp;&nbsp; new </font>Generic_Doubly_Linked_Web<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Signal_List,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Signal'Class,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Some_Ptr'Storage_Pool<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
	...<br>
	Message := <font color="#0000FF">new</font> Error_Message;<font color="#008000"> -- Derived from Signal</font><br>
	Append (Alarm, Notifications_List, Message);<br>
	Append (Log,&nbsp;&nbsp; System_Trace_List,&nbsp; Message);</tt></p>

</blockquote>
<p>Both
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> or 
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a> are intended for placing newly allocated items or items removed from their lists before. To move an item from one list to another of the same type 
they take an additional parameter <b>Source</b> to specify the head of the list, the 
element is removed from. These procedures are equivalent to a call to
<a href="#Generic_Doubly_Linked_Web.Remove">Remove</a> with a subsequent
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> or 
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a> as required. The difference between&nbsp;
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> and
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a> is that for
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> the list head is specified and thus the list can 
be empty. For 
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a> the list head is not identified and the list cannot be empty. 
The design of these operations was chosen to prevent, when possible, dangling 
pointers and garbage. For this reason all operations that remove an item from a 
list refer to the list head. When appropriately used, the rest of the list 
should not become unreferenced. The deallocator of the storage pool used to keep 
the list items checks freed items for being unreferenced. When a freed item is 
still in a list, Program_Error is propagated out of Unchecked_Deallocation.</p>
<p>There is no special function to obtain the first element in the list because 
the list head is also the first element. So:</p>

<blockquote>
  <p><tt>Element := Node (Container);</tt></p>

</blockquote>
<p>would do the job.</p>
<p>The following list operations are defined:</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Append"></a>
	procedure </font>Append<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out </font>Web;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure inserts <b>Element</b> is at 
the end of <b>Container</b>. <b>Element</b> is either a newly 
allocated item or an item outside any lists of the type <b>Brand</b>. 
Constraint_Error is propagated when <b>Element</b> already is in a list. This 
includes <b>Container</b>. <b>Container</b> can be empty before a call to the 
procedure, in which case <b>Element</b> becomes the head of it. See also
<a href="#Generic_Doubly_Linked_Web.Prepend">Prepend</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Append_Moving"></a>
	procedure</font> Append<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> Web;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Web<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is an equivalent to 
<a href="#Generic_Doubly_Linked_Web.Remove">Remove</a> followed by
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> without the parameter <b>
Source</b>. It moves <b>Element</b> from
<b>Source</b> to <b>Container</b>. When <b>Source</b> and <b>
Container</b> is the same list <b>Container</b> parameter takes advantage. 
Constraint_Error is propagated when <b>Element</b> is <font color="#0000FF">null</font>. 
See also <a href="#Generic_Doubly_Linked_Web.Prepend_Moving">Prepend</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Delete">
	</a>procedure</font> Delete<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> Web;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : <font color="#0000FF">in out</font> Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure removes <b>Element</b> from <b>Container</b>. The item 
following <b>Element</b> becomes the new list head. The operation is void when
<b>Element</b> is <font color="#0000FF">null</font>. The 
parameter <b>Container</b> is ignored when <font color="#0000FF">null</font>. 
When <b>Element</b> after its removal does not belong to any list its target 
object is finalized, freed, and then <b>Element</b> is set to
<font color="#0000FF">null</font>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Erase">
	</a>procedure</font> Erase<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> Web<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure removes all elements from <b>Container</b>. When an element after its removal does not belong to any list its target 
object is finalized and freed.&nbsp; </p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Insert">
	</a>procedure</font> Insert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Position</b> : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp; : Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure inserts <b>Element</b> after the item specified by the parameter <b>Position</b>. <b>Element</b> may 
not be in any list. Constraint_Error is propagated otherwise or when <b>Element</b> 
is <font color="#0000FF">null</font>. Constraint_Error is also propagated when
<b>Position</b> is <font color="#0000FF">null</font> or not in a list of <b>
Brand</b> type.
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a> is similar to
<a href="#Generic_Doubly_Linked_Web.Append">Append</a>, with the difference that an 
arbitrary list item is used to indicate the insertion position. For this reason
<a href="#Generic_Doubly_Linked_Web.Append">Append</a> can deal with empty lists, 
while <a href="#Generic_Doubly_Linked_Web.Insert">Insert</a> requires at least 
one item in. To insert <b>Element</b> before <b>Position</b> use:</p>
<blockquote>
	<blockquote>
		<p><tt>Insert (Brand, Previous (Brand, Position), Element);&nbsp; </tt>
		</p>
	</blockquote>
	<p><tt><font color="#0000FF">
	<a name="Generic_Doubly_Linked_Web.Insert_Moving"></a>procedure</font> Insert<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
	<b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp;: List_Identification_Type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<b>Position </b>: Node;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<b>Element</b>&nbsp;&nbsp;: Node;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<b>Source</b>&nbsp;&nbsp;&nbsp;: <font color="#0000FF">in out</font> Web<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is an equivalent to 
<a href="#Generic_Doubly_Linked_Web.Remove">Remove</a> followed by
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a>. It moves <b>Element</b> from
<b>Source</b> to the list of <b>Position</b>. The parameter has the same meaning as in
<a href="#Generic_Doubly_Linked_Web.Insert">Insert</a>. When <b>Position</b> and <b>
Element</b> refer the same item, the procedure does nothing. Constraint_Error is propagated when 
<b>Element</b> or <b>Position</b> is <font color="#0000FF">null</font>. It is 
also propagated when <b>Position</b> is not in a list of <b>Brand</b> type.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Empty<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
	<b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	<b>Container</b> 
	: Web<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; 
	<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function return <font color="#1100000"><i>true</i></font> if <b>
Container </b>is <font color="#0000FF">null</font>. For containers of he type
		<a href="#Generic_Doubly_Linked_Web.Web">Web</a> emptiness is equivalent 
to being <font color="#0000FF">null</font>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Is_In"></a>
	function</font> Is_In<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Element</b> 
	: Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return</font> Boolean;</tt></p>
</blockquote>
<p>This function return <font color="#1100000"><i>false</i></font> if <b>Element</b> 
is <font color="#0000FF">null</font> or else is not in any list of <b>Brand</b> 
type. Where <a href="#Generic_Doubly_Linked_Web.Is_In">Is_In</a> returns 
<font color="#1100000"><i>false</i></font>
<a href="#Generic_Doubly_Linked_Web.Next">Next</a> and
<a href="#Generic_Doubly_Linked_Web.Previous">Previous</a> would raise 
Contraint_Error.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Is_In_any_list"></a>
	function</font> Is_In (<b>Element</b> 
	: Node) <font color="#0000FF">
	return</font> Boolean;</tt></p>
</blockquote>
<p>This function return <font color="#1100000"><i>false</i></font> if <b>Element</b> 
is <font color="#0000FF">null</font> or else is not in any list of any 
type.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Next"></a>
	function</font> Next<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Element</b> 
	: Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return</font> Node;<br>
	<font color="#0000FF">function</font> Next<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Container</b> 
	: Web<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return</font> Node;</tt></p>
</blockquote>
<p>These functions return item following either <b>Element</b> or the head of <b>
Container</b>. Constraint_Error is propagated in all cases when there is no next 
item. Note that when the element is in a list of <b>Brand</b> type, it always 
has a next element, maybe itself. The list is circular.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Prepend"></a>
	procedure </font>Prepend<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out </font>Web;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure inserts <b>Element</b> is in front of <b>Container</b>. <b>Element</b> is either a newly 
allocated item or an item outside any lists of the type <b>Brand</b>. 
Constraint_Error is propagated when <b>Element</b> already is in a list. This 
includes <b>Container</b>. <b>Container</b> can be empty before a call to the 
procedure, in which case <b>Element</b> becomes the head of it. See also
<a href="#Generic_Doubly_Linked_Web.Append">Append</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Generic_Doubly_Linked_Web.Prepend_Moving"></a>
	procedure</font> Prepend<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> Web;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Web<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is an equivalent to 
<a href="#Generic_Doubly_Linked_Web.Remove">Remove</a> followed by
<a href="#Generic_Doubly_Linked_Web.Prepend">Prepend</a> without the parameter <b>
Source</b>. It moves <b>Element</b> from
<b>Source</b> to the beginning of <b>Container</b>. When <b>Source</b> and <b>
Container</b> is the same list <b>Container</b> parameter takes advantage. 
Constraint_Error is propagated when <b>Element</b> is <font color="#0000FF">null</font>. 
The operation is void when <b>Container</b> and <b>Element</b> refer to the same 
item See also <a href="#Generic_Doubly_Linked_Web.Append_Moving">Append</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Previous">
	</a>function</font> Previous<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Element</b> 
	: Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return</font> Node;<br>
	<font color="#0000FF">function</font> Previous<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Container</b> 
	: Web<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return</font> Node;</tt></p>
</blockquote>
<p>These functions return item preceding either <b>Element</b> or the head of <b>
Container</b>. Constraint_Error is propagated in all cases when there is no 
previous item. When the element is in a list of <b>Brand</b> type, it always has 
a next element, maybe itself, because the list is circular.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Remove">
	</a>procedure</font> Remove<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> Web;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure removes <b>Element</b> from <b>Container</b>. The item 
following <b>Element</b> becomes the new list head. The operation is void when
<b>Element</b> is not in a list or <font color="#0000FF">null</font>. The 
parameter <b>Container</b> is ignored when <font color="#0000FF">null</font>. 
Unlikely to
	<a href="#Generic_Doubly_Linked_Web.Delete">Delete</a> <b>Element</b> is 
never freed.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Take">
	</a>procedure</font> Take<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Brand</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: List_Identification_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> Web;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure removes the first element from <b>Container</b>. The item 
following it becomes the new list head. The removed element is returned through 
the parameter <b>Element</b>. It is set to <font color="#0000FF">null</font> 
when <b>Container</b> is empty. When returned <b>Element</b> is not <font color="#0000FF">null</font> and 
not in any list (<a href="#Generic_Doubly_Linked_Web.Is_In_any_list">Is_In</a> (<b>Element</b>) = <font color="#1100000"><i>false</i></font>), 
then it becomes the caller's responsibility either to destroy <b>Element</b> or to 
return it back to a list.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Dope_Size <font color="#0000FF">
	return</font> Storage_Offset;</tt></p>
</blockquote>
<p>This informational function returns the number of storage elements the 
compiler places in front of an item. The value is estimated and is available only after first call to a list operation. Constraint_Error 
is propagated when the size is yet not determined.</p>
<p align="right">
  <a href="#8.1" name="8.1"></a><a href="#8"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#8.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<h3>8.1. Doubly-linked lists of networks (specialization)</h3>
<p><a name="Generic_Doubly_Linked_Web.Generic_List"></a>The generic child package
<a href="#Generic_Doubly_Linked_Web.Generic_List">Generic_Doubly_Linked_Web.Generic_List</a> provides 
a specialization of
<a href="#Generic_Doubly_Linked_Web">Generic_Doubly_Linked_Web</a> constrained 
to one type of lists:</p>

<blockquote>
  <p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type</font> Brand : List_Identification_Type;<font color="#0000FF"><br>
	package </font>Generic_Doubly_Linked_Web.Generic_List<font color="#0000FF"> is</font> ...</tt></p>

</blockquote>

<p>The formal parameter Brand specifies the type of the list. The package 
defines specialized types of list nodes and list heads corresponding to
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> and
<a href="#Generic_Doubly_Linked_Web.Web">Web</a>:</p>

<blockquote>
  <p><tt><font color="#0000FF">
	<a name="Generic_Doubly_Linked_Web.Generic_List.Item"></a>type </font>Item<font color="#0000FF"> 
	is new </font>Node;<font color="#0000FF"><br>
	<a name="Generic_Doubly_Linked_Web.Generic_List.List"></a>type </font>List<font color="#0000FF"> 
	is new </font>Web;</tt></p>

</blockquote>

<p>Items of the network can be allocated using either of these access types. The 
purpose of <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> and
<a href="#Generic_Doubly_Linked_Web.Generic_List.List">List</a> is specify which 
type links are involved in the specialized operations:</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Generic_List.Append"></a>
	procedure </font>Append (<b>Container</b> : <font color="#0000FF">in out </font>List; <b>
	Element</b> : Item);</tt></p>
</blockquote>
<p>This procedure is specialized version of
<a href="#Generic_Doubly_Linked_Web.Append">Append</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure </font>Append<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp;
	Container</b> : <font color="#0000FF">in out </font>List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Item;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure </font>Append<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp;
	Container</b> : <font color="#0000FF">in out </font>List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is specialized version of moving
<a href="#Generic_Doubly_Linked_Web.Append_Moving">Append</a>. The parameter <b>Element</b> can be of either <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
or
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> types.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Generic_List.Delete">
	</a>procedure</font> Delete (<b>Container</b> : <font color="#0000FF">in out</font> 
	List; <b>Element</b> : <font color="#0000FF">in out</font> Item);<font color="#0000FF"><br>
	procedure</font> Delete (<b>Container</b> : <font color="#0000FF">in out</font> 
	List; <b>Element </b>: <font color="#0000FF">in out</font> Node);</tt></p>
</blockquote>
<p>This is a specialized version of <a href="#Generic_Doubly_Linked_Web.Delete">Delete</a>. 
The parameter <b>Element</b> can be of either <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
or
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> types.</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Erase (<b>Container</b> : <font color="#0000FF">in out</font> 
	List);</tt></p>
</blockquote>
<p>This is specialized version of <a href="#Generic_Doubly_Linked_Web.Erase">
Erase</a>. It removes all elements from <b>Container</b>. When an element after its removal does not belong to any list its target 
object is finalized and freed.&nbsp; </p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Generic_List.Insert">
	</a>procedure</font> Insert (<b>Position</b> : Item; <b>
	Element</b>&nbsp;: Item);<font color="#0000FF"><br>
	procedure</font> Insert (<b>Position</b> : Node; <b>
	Element</b>&nbsp;: Item);</tt></p>
</blockquote>
<p>This is a specialized version of <a href="#Generic_Doubly_Linked_Web.Insert">Insert</a>. 
The parameter <b>Position</b> can be of either <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
or
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> types. The parameter <b>
Element</b> is only of <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
type, because otherwise it were impossible to resolve names overloading. Though <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
and
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> resemble base and derived 
tagged types, they are not.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Generic_List.Insert_Moving"></a>
	procedure</font> Insert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Position </b>: Item;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp;: Item;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp;: <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> Insert <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Position </b>: Item;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp;: Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp;: <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> Insert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Position </b>: Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp;: Item;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp;: <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> Insert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Position </b>: Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp;: Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp;: <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>These procedures are specialized versions of
moving <a href="#Generic_Doubly_Linked_Web.Insert_Moving">Insert</a>. The parameters <b>Position</b> and 
<b>Element</b> can be of any combination of <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
or
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> types.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_In (<b>Element</b> 
	: Item) <font color="#0000FF">
	return</font> Boolean;</tt></p>
</blockquote>
<p>These function return <font color="#1100000"><i>false</i></font> if <b>Element</b> 
is <font color="#0000FF">null</font> or else is not in any list of the Brand 
type.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Generic_List.Next"></a>
	function</font> Next(<b>Element</b> 
	: Item) <font color="#0000FF">
	return</font> Item;<br>
	<font color="#0000FF">function</font> Next(<b>Container</b> 
	: List) <font color="#0000FF">
	return</font> Item;</tt></p>
</blockquote>
<p>These are specialized versions of <a href="#Generic_Doubly_Linked_Web.Next">
Next</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Generic_Doubly_Linked_Web.Generic_List.Prepend"></a>
	procedure </font>Prepend (<b>Container</b> : <font color="#0000FF">in out </font>List; <b>
	Element</b> : Item);</tt></p>
</blockquote>
<p>This procedure is specialized version of
<a href="#Generic_Doubly_Linked_Web.Prepend">Prepend</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure </font>Prepend<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp;
	Container</b> : <font color="#0000FF">in out </font>List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Item;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure </font>Prepend<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp;
	Container</b> : <font color="#0000FF">in out </font>List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Source</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> List<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is specialized version of moving
<a href="#Generic_Doubly_Linked_Web.Prepend_Moving">Prepend</a>. The parameter <b>Element</b> can be of either <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
or
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> types.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Generic_List.Previous">
	</a>function</font> Previous (<b>Element</b> 
	: Item) <font color="#0000FF">
	return</font> Item;<br>
	<font color="#0000FF">function</font> Previous (<b>Container</b> 
	: List) <font color="#0000FF">
	return</font> Item;</tt></p>
</blockquote>
<p>These are specialized versions of
<a href="#Generic_Doubly_Linked_Web.Previous">Previous</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Doubly_Linked_Web.Generic_List.Remove">
	</a>procedure</font> Remove<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Item<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> Remove<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This is specialized version of <a href="#Generic_Doubly_Linked_Web.Remove">
Remove</a>. The parameter <b>Element</b> can be of either <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
or
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> types.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Generic_Doubly_Linked_Web.Generic_List.Take">
	</a>procedure</font> Take<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Item<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> Take<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>
	Container</b> : <font color="#0000FF">in out</font> List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Node<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This is a specialized version of <a href="#Generic_Doubly_Linked_Web.Take">
Take</a>. The parameter <b>Element</b> can be of either <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
or
<a href="#Generic_Doubly_Linked_Web.Node">Node</a> types.</p>
<p align="right">
<a name="8.2"></a><a href="#8.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#9"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<h3>8.2. Doubly-linked lists</h3>
<p><a name="Generic_Doubly_Linked"></a>The generic package
<a href="#Generic_Doubly_Linked">Generic_Doubly_Linked</a> provides 
plain double-linked lists of elements allocated in the standard storage pool. 
The package is provided to simplify use of
<a href="#Generic_Doubly_Linked_Web">Generic_Doubly_Linked_Web</a> for this 
case.</p>

<blockquote>
  <p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>List_Item_Type (&lt;&gt;)<font color="#0000FF"> is limited 
	private</font>;<br>
	<font color="#0000FF">package</font> Generic_Doubly_Linked
	<font color="#0000FF">is<br>
	</font> &nbsp;&nbsp; ...<font color="#0000FF"><br>
&nbsp;&nbsp; package </font>Doubly_Linked<font color="#0000FF"> is</font> ...</tt></p>

</blockquote>

<p>The typical use of the package is as follows:</p>

<blockquote>
  <p><tt><font color="#0000FF">type </font>My_Item <font color="#0000FF">is</font> 
	...;<font color="#0000FF"><br>
	package </font>My_Lists<font color="#0000FF"> is new </font>
	Generic_Doubly_Linked (My_Item);<font color="#0000FF"><br>
	use </font>My_Lists.Doubly_Linked;</tt></p>

</blockquote>

<p>The package Doubly_Linked is an instance of
<a href="#Generic_Doubly_Linked_Web.Generic_List">Generic_Doubly_Linked_Web.Generic_List</a>, 
which provides the types&nbsp; <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> and
<a href="#Generic_Doubly_Linked_Web.Generic_List.List">List</a> and operations 
on them (see <a href="#GNAT_bug">warning</a>).</p>
<h4>8.2.3 Doubly-linked list example</h4>
<p>The example represents an implementation of a simple scheduler of jobs. There 
is a pool of worker tasks and a queue of abstract jobs. The tasks take jobs from 
the queue, process them and then return them back to the queue. A doubly-linked 
list us used as the queue implementation. Jobs are tagged, and that the queue 
contains class-wide objects. The example is located in the <i>test_components</i> 
subdirectory.</p>File 
<i>test_linked_lists_scheduler.ads</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> 
  Ada.Finalization;<br>
<font color="#0000FF">with</font> Generic_Doubly_Linked;<br>
<br>
<font color="#0000FF">package</font> Test_Linked_Lists_Scheduler
<font color="#0000FF">is</font><br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Job -- Abstract piece of work<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">type</font> Job <font color="#0000FF">
is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract new </font>Ada.Finalization.Controlled
<font color="#0000FF">with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null record</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Do_It (Work :
<font color="#0000FF">in out</font> Job) <font color="#0000FF">is abstract</font>;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">package</font>&nbsp;Job_List&nbsp;<font color="#0000FF">&nbsp;is&nbsp;new</font>&nbsp;Generic_Doubly_Linked&nbsp;(Job'Class);<br>
&nbsp;&nbsp; <font color="#0000FF">use</font> Job_List.Doubly_Linked;</tt></TD>
  </TR>
</TABLE>
<p>The package Test_Linked_List_Scheduler declares an abstract type Job, which 
is a piece of work to be done. The abstract procedure Do_It is to overridden by 
a concrete job. It is called by a worker task to accomplish the job. The package 
Job_List instantiates
<a href="#Generic_Doubly_Linked">Generic_Doubly_Linked</a> with Job'Class as the 
parameter. The package Job_List.Doubly_Linked provides a doubly linked list of 
Job'Class objects. Note that the list elements are class-wide, i.e. it can 
contain any kind of jobs.</p>
<p>File <i>test_linked_lists_scheduler.ads (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Worker -- A task doing jobs<br>
&nbsp;&nbsp; --</font><br>
&nbsp;&nbsp; <font color="#0000FF">task type</font> Worker;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Submit -- A new job for processing<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Submit (Work : Item);<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp;&nbsp;--&nbsp;Shut_Down&nbsp;--&nbsp;Purge&nbsp;the&nbsp;jobs&nbsp;queue&nbsp;and&nbsp;stop&nbsp;workers<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Shut_Down;</tt></TD>
  </TR>
</TABLE>
<p>The type Worker is a task doing jobs. The procedure Submit is used to submit 
a job. It has the parameter of the type <a href="#Generic_Doubly_Linked_Web.Generic_List.Item">Item</a> 
which is an access to Job'Class. The procedure Shut_Down is used to purge the 
jobs queue and stop all workers.</p>
<p>File <i>test_linked_lists_scheduler.ads (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Print_Me -- A concrete job, prints some text<br>
&nbsp;&nbsp; --</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">type</font>&nbsp;Print_Me&nbsp;(Length&nbsp;:&nbsp;Natural)&nbsp;<font color="#0000FF">is&nbsp;new</font>&nbsp;Job&nbsp;<font color="#0000FF">with record</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text : String (<font color="#1100000">1</font>..Length);<br>
&nbsp;&nbsp; <font color="#0000FF">end record</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Do_It (Work :
<font color="#0000FF">in out</font> Print_Me);<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Have_To_Print (Text : String)
<font color="#0000FF">return</font> Item; <br>
<br>
<font color="#0000FF">end</font> Test_Linked_Lists_Scheduler;</tt></TD>
  </TR>
</TABLE>
<p>The type Print_Me is a concrete job. It prints a text on the screen.</p>File 
<i>test_linked_lists_scheduler.adb</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> Ada.Text_IO;&nbsp; 
<font color="#0000FF">use</font> Ada.Text_IO;<br>
<br>
<font color="#0000FF">package body </font>Test_Linked_Lists_Scheduler is<br>
<br>
&nbsp;&nbsp; Queue_Closed : <font color="#0000FF">exception</font>;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">protected</font> Waiting_Queue
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry</font>&nbsp;Get_For_Service&nbsp;(Work&nbsp;:&nbsp;<font color="#0000FF">out</font>&nbsp;Item);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">procedure</font> Shut_Down;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">procedure</font> Submit (Work : Item);<br>
&nbsp;&nbsp; <font color="#0000FF">private</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Queue&nbsp; : List;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Closed : Boolean;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Waiting_Queue;</tt></TD>
  </TR>
</TABLE>
<p>The protected object Waiting_Queue holds the list of jobs waiting for 
service. It has the entry point Get_For_Service called by a worker to get a new 
job to do. The exception Queue_Closed is used to notify a worker that it has to 
exit. The procedure Shut_Down closes the queue. The procedure Submit puts a new 
job into the queue.</p>File 
<i>test_linked_lists_scheduler.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">&nbsp;&nbsp; protected body 
</font>Waiting_Queue
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
entry</font> Get_For_Service (Work : <font color="#0000FF">out</font> Item)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Closed 
<font color="#0000FF">or else </font>Queue /= <font color="#0000FF">null is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if </font>Closed <font color="#0000FF">then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
raise </font>Queue_Closed;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Take&nbsp;(Queue,&nbsp;Work);&nbsp;<font color="#008000">--&nbsp;The&nbsp;first&nbsp;in&nbsp;the&nbsp;list</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font> Get_For_Service;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">procedure</font> Submit (Work : Item)<font color="#0000FF"> is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Append (Queue, Work); <font color="#008000">-- Add to the end</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Closed 
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Erase (Queue);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font> Submit;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">procedure</font> Shut_Down
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Closed := True;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Erase (Queue);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font> Shut_Down;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Waiting_Queue;</tt></TD>
  </TR>
</TABLE>
<p>The implementation of Waiting_Queue is straightforward. The procedure 
Get_For_Service uses <a href="#Generic_Doubly_Linked_Web.Generic_List.Take">Take</a> 
to extract the first job from the queue. Its barrier contains Queue /=
<font color="#0000FF">null</font>, which is non-empty queue test. The barrier is 
always true after a call to Shut_Down. In this case Queue_Closed is propagated 
out of Get_For_Service. The procedure Submit places a new Job into the queue.</p>File 
<i>test_linked_lists_scheduler.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">&nbsp;&nbsp; task body</font> Worker <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This : Item;<br>
&nbsp; <font color="#0000FF">&nbsp;begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Waiting_Queue.Get_For_Service (This);<br>
<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;Now&nbsp;we&nbsp;are&nbsp;holding&nbsp;This,&nbsp;so&nbsp;be&nbsp;careful&nbsp;with&nbsp;exceptions,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- the item must back to the queue in all cases<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This.Do_It;<br>
&nbsp;<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- Item has been serviced, return it back<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Waiting_Queue.Submit (This);<br>
<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when</font> Queue_Closed =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
exit</font>;<br>
<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
when others </font>=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Waiting_Queue.Submit (This);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Worker;</tt></TD>
  </TR>
</TABLE>
<p>The implementation of a worker task runs an infinite loop in which it takes a 
job from the queue using Get_For_Service and then calls Do_It for the job (note, 
Ada 2005 syntax). After that it submits the job back. When Queue_Closed is 
propagated out of Get_For_Service, the worker exits.</p>File 
<i>test_linked_lists_scheduler.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp;&nbsp;<font color="#0000FF">procedure</font>&nbsp;Submit&nbsp;(Work&nbsp;:&nbsp;Item)<font color="#0000FF">&nbsp;is<br>
&nbsp;&nbsp;
begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Waiting_Queue.Submit (Work);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Submit;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Shut_Down
<font color="#0000FF">is<br>
&nbsp;&nbsp;
begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Waiting_Queue.Shut_Down;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Shut_Down;</tt></TD>
  </TR>
</TABLE>
<p>The implementation of Submit and Shut_Down procedures call to the 
corresponding ones of the protected object.</p>File 
<i>test_linked_lists_scheduler.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">procedure </font> 
Do_It (Work : <font color="#0000FF">in out</font> Print_Me)
<font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp; </font> &nbsp;&nbsp; Put_Line (Work.Text);<font color="#0000FF"><br>
&nbsp;&nbsp; end </font> Do_It;<font color="#0000FF"><br>
<br>
&nbsp;&nbsp; function</font> Have_To_Print (Text : String) 
<font color="#0000FF">return</font> Item <font color="#0000FF">is<br>
&nbsp;&nbsp;
begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new</font> Print_Me'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Job<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">with</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Length =&gt; Text'Length,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Text&nbsp;&nbsp; =&gt; Text<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Have_To_Print;<br>
<br>
<font color="#0000FF">end</font> Test_Linked_Lists_Scheduler;</tt></TD>
  </TR>
</TABLE>
<p>The implementation of the Print_Me job. The procedure Do_It prints the text. 
The function Have_To_Print allocates a new job object.</p>File 
<i>test_linked_lists_scheduler_test.adb</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font>&nbsp;Test_Linked_Lists_Scheduler;&nbsp;&nbsp;<font color="#0000FF">use</font>&nbsp;Test_Linked_Lists_Scheduler;<br>
<br>
<font color="#0000FF">procedure</font> Test_Linked_Lists_Scheduler_Test
<font color="#0000FF">is</font><br>
&nbsp;&nbsp; W1 : Worker;<br>
&nbsp;&nbsp; W2 : Worker;<br>
&nbsp;&nbsp; W3 : Worker;<br>
&nbsp;&nbsp; W4 : Worker;<br>
&nbsp;&nbsp; W5 : Worker;<br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">The</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">quick</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">brown</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">fox</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">jumps</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">over</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">the</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">lazy</font>&quot;));<br>
&nbsp;&nbsp; Submit (Have_To_Print (&quot;<font color="#FF0000">dog</font>&quot;));<br>
&nbsp;&nbsp; <font color="#0000FF">delay</font> <font color="#1100000">10.0</font>;<br>
&nbsp;&nbsp; Shut_Down;<br>
<font color="#0000FF">end</font> Test_Linked_Lists_Scheduler_Test;</tt></TD>
  </TR>
</TABLE>
<p>The test program creates five worker tasks and submits 9 jobs. After 10 
seconds of processing it terminates.</p>
<p>&nbsp;</p>
<hr>
<p align="right">
  <A name="9"></A><a href="#8.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#9.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H2>9. Lock-free data structures</H2>
<P>Lock-free data structures provide shared access to their content without 
locking. For multi-core and other architectures of shared memory locking might 
be expensive compared to some extra overhead required for implementation of 
a lock-free access. So lock-free structures might appear more efficient. Another 
potential advantage of lock-free access is deadlock prevention. A sufficiently more complex use and less predictable behavior 
(mostly in the cases where a corresponding locking structure would block) count 
to the disadvantages of lock-free structures. The choice between lock-free and 
locking structure depends on each concrete case.</p>
<P>Here it is necessary to clarify what is understood under the term <i>
lock-free</i> access. Clearly no processor instruction can be executed in a 
lock-free manner. There is always some sort of synchronization involved which 
ultimately is resulted in a non instant execution time. Neither a bounded access 
time is meant here, because a lock-free access can be interrupted and preempted.</p>
<P>In the context of the programming language Ada we define as lock-free any 
operations that are not:</p>
<ol>
	<li><i>potentially blocking</i> as it is defined in the
	<a href="http://www.adaic.com/standards/05rm/html/RM-9-5-1.html"><i>Ada 
	Language Reference Manual</i> 9.5.1</a>;</li>
	<li>involving calls to <i>protected subprograms</i> (ibidem), including 
	protected functions, procedures and entries.</li>
</ol>
<P>From this definition follows that in particular accessing atomic objects is lock-free. For atomic 
objects see the <a href="http://www.adaic.com/standards/05rm/html/RM-C-6.html">
<i>Ada Language Reference Manual</i> C.6</a>.</p>
<p align="right">
  <A name="9.1"></A><a href="#9"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#9.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>9.1. FIFO</H3>
<H4>9.1.1. Lock-free FIFO of definite elements</H4>
<p><a name="Generic_FIFO"></a>The package <a href="#Generic_FIFO">Generic_FIFO</a> 
provides a lock-free first in, first out queue, which can be used between one publisher and 
one subscriber.</p>
<blockquote>
	<p><img border="0" src="fifo.gif" width="446" height="128"></p>
</blockquote>
<p>The package is generic:</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Element_Type <font color="#0000FF">is private</font>;<font color="#0000FF"><br>
	package </font>Generic_FIFO<font color="#0000FF"> is</font> ...</tt></p>
</blockquote>
<p>The type of FIFO is:</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>FIFO (Size : Positive)<font color="#0000FF"> 
	is<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The discriminant Size determines the maximal size of the queue. A queue can 
hold no more than Size - 1 elements. The following primitive operations are defined in the package:</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Delete (<b>Queue</b> :
	<font color="#0000FF">in out</font> FIFO; <b>Count</b> : Natural := 1);</tt></p>
</blockquote>
<p>This procedure removes <b>Count</b> elements from <b>
Queue</b>. When the queue contains <b>Count</b> or less elements, it becomes 
empty. The elements are removed from the same queue end
<a href="#Generic_FIFO.Get">Get</a> and <a href="#Generic_FIFO.Peek">Peek</a> 
access. Therefore it shall be called from the same task.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Get"></a>procedure</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : <font color="#0000FF">out</font> Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Empty</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This function takes one element out of <b>Queue</b>. When <b>Queue</b> is empty the 
output parameter <b>Empty</b> is set to <font color="#800000"><i>true</i></font> 
and <b>Element</b> is not changed. 
Otherwise <b>Element</b> is the element taken and <b>Empty</b> is set to
<font color="#800000"> <i>
false</i></font>.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Get (<b>Queue</b> :
	FIFO) <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>This is a variant of <a href="#Generic_FIFO.Get">Get</a> which raises Constraint_Error when <b>
Queue</b> is empty.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Empty (<b>Queue</b> : FIFO)
	<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Queue</b> 
is empty.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Full (<b>Queue</b> : FIFO)
	<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Queue</b> 
is full.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Is_Preserved"></a>function</font> 
	Is_Preserved (<b>Queue</b> : FIFO; <b>Element</b> : Element_Type)<br>
&nbsp;&nbsp;
	<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Element</b> 
has to be preserved in <b>Queue</b> 
by the procedure <a href="#Generic_FIFO.Purge">Purge</a>. This is the default 
behavior. The function can be overridden in order to change the behavior of
<a href="#Generic_FIFO.Purge">Purge</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Peek"></a>procedure</font> 
	Peek<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : <font color="#0000FF">out</font> Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Empty</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This function returns the element of <b>Queue</b>, a
<a href="#Generic_FIFO.Get">Get</a> operation would take. Unlikely to
<a href="#Generic_FIFO.Get">Get</a> it does not remove the element from <b>Queue</b>. When 
<b>Queue</b> is empty the 
output parameter <b>Empty</b> is set to <font color="#800000"><i>true</i></font> 
and <b>Element</b> is not changed. 
Otherwise <b>Element</b> is the element at the <b>Queue</b> beginning and <b>Empty</b> is set to <i>
<font color="#800000">false</font></i>.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Peek (<b>Queue</b> :
	FIFO) <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>This is a variant of <a href="#Generic_FIFO.Peek">Peek</a> which raises Constraint_Error when <b>
Queue</b> is empty.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Purge"></a>procedure</font> 
	Purge<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Queue</b>&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Purged</b> : <font color="#0000FF">out</font> Natural<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure removes all elements for which
<a href="#Generic_FIFO.Is_Preserved">Is_Preserved</a> returns <i>
<font color="#800000">false</font></i>. The parameter <b>Purged</b> is set to 
the number of elements removed from the <b>Queue</b>. The default implementation 
of <a href="#Generic_FIFO.Is_Preserved">Is_Preserved</a> returns
<font color="#800000"><i>true</i></font>, so it needs to be overridden to make
<a href="#Generic_FIFO.Purge">Purge</a> removing any element. Observe also that 
there is a potential race condition in <a href="#Generic_FIFO.Purge">Purge</a> 
when new elements are added concurrently. The newly added elements might be not 
removed. If it is essential to remove the race condition, the implementation of
<a href="#Generic_FIFO.Is_Preserved">Is_Preserved</a> must return <i>
<font color="#800000">false</font></i> for newly added elements.</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Full</b>&nbsp;&nbsp;&nbsp; 
	: <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure places <b>Element</b> into <b>Queue</b>. When Element is put,
<b>Full</b> is set to <font color="#800000"><i>false</i></font>. Otherwise it is 
set to <i><font color="#800000">true</font></i>.</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This is a variant of the procedure above which raises Constraint_Error when
<b>Queue</b> is full.</p>
<H4>9.1.2. Signaled FIFO</H4>
<p><a name="Generic_FIFO.Signaled_FIFO"></a>The child package
<a href="#Generic_FIFO.Signaled_FIFO">Generic_FIFO.Signaled_FIFO</a> 
provides FIFO with almost lock-free behavior. The implementation locks only if 
the operation has to block. That is, upon reading from an empty queue or else 
writing into a full queue. Otherwise it is lock-free.</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
	package </font>Generic_FIFO.Generic_Signaled <font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The type of Signaled_FIFO is:</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Signaled_FIFO<font color="#0000FF"> 
	is new </font>FIFO<font color="#0000FF"> with private;</font></tt></p>
</blockquote>
<p>The following operations are added or have an altered behavior:</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Signaled_FIFO.Cancel">
	</a>procedure</font> Cancel (<b>Queue</b> : <font color="#0000FF">in out
	</font>Signaled_FIFO);</tt></p>
</blockquote>
<p>This procedure releases all blocked tasks.
<a href="#Generic_FIFO.Signaled_FIFO.Get">Get</a> and
<a href="#Generic_FIFO.Signaled_FIFO.Peek">Peek</a> called for an empty queue, 
as well as <a href="#Generic_FIFO.Signaled_FIFO.Put">Put</a> called for a full 
queue are blocked. Their waiting is prematurely ended when
<a href="#Generic_FIFO.Signaled_FIFO.Cancel">Cancel</a> is called. In this case 
End_Error is propagated out the corresponding calls. Note that differently to
<a href="#Generic_FIFO.Signaled_FIFO.Get">Get</a>,
<a href="#Generic_FIFO.Signaled_FIFO.Peek">Peek</a> and
<a href="#Generic_FIFO.Signaled_FIFO.Put">Put</a>, this procedure can be called 
from any task.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Signaled_FIFO.Get"></a>
	function</font> Get (<b>Queue</b> : Signaled_FIFO) <font color="#0000FF">
	return</font> 
	Element_Type;<font color="#0000FF"><br>
	function</font> Get (<b>Queue</b> :
	Signaled_FIFO; <b>Timeout</b> : Duration)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>These functions block when <b>
Queue</b> is empty. If a timeout is specified, upon its expiration, 
Contraint_Error is propagated as it would for the parent type. End_Error is 
propagated when waiting was prematurely cancelled by a call to
<a href="#Generic_FIFO.Signaled_FIFO.Cancel">Cancel</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Signaled_FIFO.Peek"></a>
	function</font> Peek (<b>Queue</b> : Signaled_FIFO) <font color="#0000FF">
	return</font> 
	Element_Type;<font color="#0000FF"><br>
	function</font> Peek (<b>Queue</b> : Signaled_FIFO; <b>Timeout</b> : 
	Duration)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>These functions block when <b>Queue</b> is empty. If a timeout is specified, 
upon its expiration, Contraint_Error is propagated. End_Error is propagated when 
waiting was prematurely cancelled by a call to
<a href="#Generic_FIFO.Signaled_FIFO.Cancel">Cancel</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_FIFO.Signaled_FIFO.Put"></a>procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Timeout</b> : Duration<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>These procedures&nbsp;block when <b>Queue</b> is full. If a timeout is 
specified, upon its expiration, Contraint_Error is propagated. End_Error is 
propagated when waiting was prematurely cancelled by a call to
<a href="#Generic_FIFO.Signaled_FIFO.Cancel">Cancel</a>.</p>
<H4>9.1.2. Lock-free FIFO of indefinite elements</H4>
<p><a name="Generic_Indefinite_FIFO"></a>The package 
<a href="#Generic_Indefinite_FIFO">Generic_Indefinite_FIFO</a> 
provides a lock-free first in, first out queue, which can be used between one publisher and 
one subscriber. It is similar to <a href="#Generic_FIFO">Generic_FIFO</a> 
except that it can handle elements of indefinite types, such as unconstrained 
arrays or class-wide types. The package is generic:</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Element_Type (&lt;&gt;) <font color="#0000FF">is private</font>;<font color="#0000FF"><br>
	package </font>Generic_Indefinite_FIFO<font color="#0000FF"> is</font> ...</tt></p>
</blockquote>
<p>The type of FIFO is:</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>FIFO (Size : Storage_Count)<font color="#0000FF"> 
	is<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The discriminant Size determines the maximal size of the queue in storage 
elements. A queue can 
hold objects which total size in storage elements is no more than Size - 1. This 
is not the exact limit, which could be lower due to memory fragmentation. There 
can be no more than two fragments, except than small holes needed for alignment 
reasons. Note that because the element size is 
unknown in advance, it is impossible to determine whether the queue is full </p>
<p>The following primitive operations are defined in the package:</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Delete (<b>Queue</b> :
	<font color="#0000FF">in out</font> FIFO; <b>Count</b> : Natural := 1);</tt></p>
</blockquote>
<p>This procedure removes <b>Count</b> elements from <b>
Queue</b>. When the queue contains <b>Count</b> or less elements, it becomes 
empty. The elements are removed from the same queue end
<a href="#Generic_Indefinite_FIFO.Get">Get</a> and
<a href="#Generic_Indefinite_FIFO.Peek">Peek</a> access. Therefore it shall be 
called from the same task.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Indefinite_FIFO.Get"></a>function</font> Get (<b>Queue</b> :
	FIFO) <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>This function returns one element from <b>Queue</b>. The element is removed 
from the queue. Constraint_Error is propagated when the queue is empty.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Free_Space (<b>Queue</b> : 
	FIFO) <font color="#0000FF">return</font> Storage_Count;</tt></p>
</blockquote>
<p>This function returns the maximal available space in <b>Queue</b>. Note that 
the result greater than the element size does not yet guarantee a consequent
<a href="#Generic_Indefinite_FIFO.Put">Put</a> would not fail. The queue space 
can be fragmented up to two segments. Therefore only when the result is twice as 
required then <a href="#Generic_Indefinite_FIFO.Put">Put</a> will not fail.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Empty (<b>Queue</b> : FIFO)
	<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Queue</b> 
is empty.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Indefinite_FIFO.Peek"></a>function</font> Peek (<b>Queue</b> :
	FIFO) <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>This function is similar to <a href="#Generic_Indefinite_FIFO.Get">Get</a> 
except that it does not remove the element from <b>Queue</b>. Constraint_Error 
is propagated when the queue is empty.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Indefinite_FIFO.Put"></a>procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure put <b>Element</b> into <b>Queue</b>. Constraint_Error when
<b>Queue</b> does not have enough space for <b>Element</b>.</p>
<H4>9.1.2. Signaled FIFO</H4>
<p><a name="Generic_Indefinite_FIFO.Signaled_FIFO"></a>The child package
<a href="#Generic_Indefinite_FIFO.Signaled_FIFO">Generic_Indefinite_FIFO.Signaled_FIFO</a> 
provides FIFO with almost lock-free behavior. The implementation locks only if 
the operation has to block. That is, upon reading from an empty queue or else 
writing into a full queue. Otherwise it is lock-free.</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
	package </font>Generic_Indefinite_FIFO.Generic_Signaled <font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The type of Signaled_FIFO is:</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Signaled_FIFO<font color="#0000FF"> 
	is new </font>FIFO<font color="#0000FF"> with private;</font></tt></p>
</blockquote>
<p>The following operations are added or have an altered behavior:</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Indefinite_FIFO.Signaled_FIF.Cancel">
	</a>procedure</font> Cancel (<b>Queue</b> : <font color="#0000FF">in out
	</font>Signaled_FIFO);</tt></p>
</blockquote>
<p>This procedure releases all blocked tasks.
<a href="#Generic_Indefinite_FIFO.Signaled_FIFO.Get">Get</a> and
<a href="#Generic_Indefinite_FIFO.Signaled_FIFO.Peek">Peek</a> called for an empty queue, 
as well as <a href="#Generic_Indefinite_FIFO.Signaled_FIFO.Put">Put</a> called for a full 
queue are blocked. Their waiting is prematurely ended when
<a href="#Generic_Indefinite_FIFO.Signaled_FIF.Cancel">Cancel</a> is called. In this case 
End_Error is propagated out the corresponding calls. Note that differently to
<a href="#Generic_Indefinite_FIFO.Signaled_FIFO.Get">Get</a>,
<a href="#Generic_Indefinite_FIFO.Signaled_FIFO.Peek">Peek</a> and
<a href="#Generic_Indefinite_FIFO.Signaled_FIFO.Put">Put</a>, this procedure can be called 
from any task.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Indefinite_FIFO.Signaled_FIFO.Get"></a>
	function</font> Get (<b>Queue</b> : Signaled_FIFO) <font color="#0000FF">
	return</font> 
	Element_Type;<font color="#0000FF"><br>
	function</font> Get (<b>Queue</b> :
	Signaled_FIFO; <b>Timeout</b> : Duration)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>These functions block when <b>
Queue</b> is empty. If a timeout is specified, upon its expiration, 
Contraint_Error is propagated as it would for the parent type. End_Error is 
propagated when waiting was prematurely cancelled by a call to
<a href="#Generic_Indefinite_FIFO.Signaled_FIF.Cancel">Cancel</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Indefinite_FIFO.Signaled_FIFO.Peek"></a>
	function</font> Peek (<b>Queue</b> : Signaled_FIFO) <font color="#0000FF">
	return</font> 
	Element_Type;<font color="#0000FF"><br>
	function</font> Peek (<b>Queue</b> : Signaled_FIFO; <b>Timeout</b> : 
	Duration)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> 
	Element_Type;</tt></p>
</blockquote>
<p>These functions block when <b>Queue</b> is empty. If a timeout is specified, 
upon its expiration, Contraint_Error is propagated. End_Error is propagated when 
waiting was prematurely cancelled by a call to
<a href="#Generic_Indefinite_FIFO.Signaled_FIF.Cancel">Cancel</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Indefinite_FIFO.Signaled_FIFO.Put"></a>
	procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Queue</b>&nbsp;&nbsp; 
	: <font color="#0000FF">in out</font> FIFO;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Timeout</b> : Duration<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>These procedures blocks when <b>Queue</b> is full. If a timeout is 
specified, upon its expiration, Contraint_Error is propagated. End_Error is 
propagated when waiting was prematurely cancelled by a call to
<a href="#Generic_Indefinite_FIFO.Signaled_FIF.Cancel">Cancel</a>.</p>
<p align="right">
  <A name="9.2"></A><a href="#9.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#10"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>9.2. Blackboard</H3>
<p>Blackboard is a data structure of broadcasted messages. Publishers put 
their messages (elements) onto the blackboard. The blackboard elements remain accessible there for 
the subscribers until newly put elements override them. The elements order in 
the blackboard is first in, first out. Accessing the blackboard for read is 
lock-free. Additionally the blackboard provides mechanisms for elements 
identification and enumeration. When an element is put into the blackboard it 
receives a unique reference. The reference can be used to access the element so 
long it is in the blackboard. After element expiration a reference can still be 
used to determine this condition. References can be advanced to the next element or else to the first 
not yet expired element in the 
blackboard.</p>
<blockquote>
	<p><img border="0" src="blackboard.gif" width="325" height="147"></p>
</blockquote>
<H4>9.2.1. Single publisher blackboard</H4>
<p><a name="Generic_Blackboard"></a>The package <a href="#Generic_Blackboard">Generic_Blackboard</a> 
provides a blackboard safe to use with one publisher writing into it, and any 
number of subscribers accessing it only for read. The package is generic:</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Element_Type (&lt;&gt;) <font color="#0000FF">is private</font>;<font color="#0000FF"><br>
	package </font>Generic_Blackboard<font color="#0000FF"> is</font> ...</tt></p>
</blockquote>
<p>The generic parameter is the type of the elements in the blackboard.&nbsp; 
The elements are stored in the blackboard temporarily. Newly coming elements 
override the most elder ones. The elements can be indefinite, tagged and 
class-wide. However </p>
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD>
<i>Because the elements in the blackboard are destructed automatically in an 
implicit way, it is not allowed to use elements of controlled types as well as 
of any other types requiring non-null finalization.</i></TD>
  </TR>
</TABLE>
<p>The type of a blackboard is:</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Blackboard (Size : Storage_Count)
	<font color="#0000FF">is<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The discriminant Size determines the size of the blackboard in storage 
elements. The time an element survives in the blackboard depends on the 
blackboard size, the size of the elements and on how frequently elements are put 
into it. The elements in the blackboard are accessed through references which 
know if the destination is still valid:</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Reference<font color="#0000FF"> is 
	private</font>;</tt></p>
</blockquote>
<p>The following primitive operations are defined in the package: </p>
<blockquote>
	<p><tt><font color="#0000FF">function </font>First (<b>Storage</b> : 
	Blackboard) <font color="#0000FF">return</font> Reference;</tt></p>
</blockquote>
<p>This function returns a reference to the first element available in <b>
Storage</b>. Note that this function can return an invalid reference when used 
concurrently. It that case the caller should call it again, unless the 
result is greater than <b>Storage</b> according to &gt;. Together with
<a href="#Generic_Blackboard.Next">Next</a>, this function can be used to scan 
the elements of a blackboard.</p>
<blockquote>
	<p><tt><font color="#0000FF">function </font>Get (<b>Storage</b> : 
	Blackboard; <b>Pointer</b> : Reference)<br>
	<font color="#0000FF">&nbsp;&nbsp; return</font> Element_Type;</tt></p>
</blockquote>
<p>This function returns an element by reference. Constraint_Error is propagated 
when <b>Pointer</b> is not a valid reference. Note that any reference can become 
invalid when the blackboard is being written.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Valid (<b>Storage</b> : 
	Blackboard; <b>Pointer</b> : Reference)<font color="#0000FF"><br>
&nbsp;&nbsp; return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Pointer</b> 
is a valid reference in <b>Storage</b>. It is equivalent to
<font color="#0000FF">not</font> <b>Storage</b> &gt; <b>Pointer</b>
<font color="#0000FF">and not</font> <b>Storage</b> &lt; <b>Pointer</b>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Blackboard.Next"></a>procedure</font> 
	Next<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : 
	Blackboard;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Pointer</b> : <font color="#0000FF">in out</font> Reference;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Sequent</b> : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure advances the reference <b>Pointer</b> to the next element. 
When <b>Pointer</b> is valid and there is a next element then <b>Sequent</b> is 
set to <font color="#800000"><i>true</i></font> and <b>Pointer</b> will refer to 
that element. When <b>Pointer</b> refers to a lost element then it is set to the 
first available element and <b>Sequent</b> is set to <i><font color="#800000">
false</font></i>. When <b>Pointer</b> refers to a not yet available element, it 
is not changed and <b>Sequent</b> is set to <font color="#800000"><i>true</i></font>. 
The following code snippet illustrates how <a href="#Generic_Blackboard.Next">
Next</a> can be used to scan a blackboard:</p>
<blockquote>
	<p><tt>Data : 
	Blackboard;<br>
	&nbsp;&nbsp;
	...<br>
	<font color="#0000FF">task body </font>Scanner <font color="#0000FF">is</font><br>
&nbsp;&nbsp; Element : Reference;<br>
	&nbsp;&nbsp;
	Sequent : Boolean;<br>
	<font color="#0000FF">begin</font><br>
	&nbsp;&nbsp; Element := First (Data);<font color="#008000"> -- The first 
	element</font><font color="#0000FF"><br>
	&nbsp;&nbsp; loop<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not </font>(Element &gt; Data)<font color="#0000FF"> 
	then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>... 
	Get (Data, Element) ...<font color="#008000"> -- Use element</font><font color="#0000FF"><br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when </font>Constraint_Error =&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<font color="#008000"> -- The element is lost</font><font color="#0000FF"><br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</font>;<font color="#0000FF"><br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>Next (Data, Element, Sequent);<font color="#0000FF"><br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if not </font>Sequent<font color="#0000FF"> then<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font>...<font color="#008000"> -- Some elements were lost</font><font color="#0000FF"><br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</font>;<font color="#0000FF"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay</font><font color="#800000"> 
	0.010</font>;<font color="#008000">&nbsp; -- Wait for new elements to come</font><font color="#0000FF"><br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end if</font>;<font color="#0000FF"><br>
	&nbsp;&nbsp; end loop</font>;<br>
	<font color="#0000FF">end </font>Scanner;</tt></p>
</blockquote>
<p>Note that lost elements can be detected by the scanner. This is the best what 
a scanner could have, because blackboard is a lock-free structure and it cannot 
block the publisher writing into it</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Next<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> : 
	Blackboard;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Pointer</b> : <font color="#0000FF">in out</font> Reference;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Sequent</b> : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure advances the reference <b>Pointer</b> to the next element. 
When <b>Pointer</b> is valid and there is a next element then <b>Sequent</b> is 
set to <font color="#800000"><i>true</i></font> and <b>Pointer</b> will refer to 
that element. When <b>Pointer</b> refers to a lost element then it is set to the 
first available element and <b>Sequent</b> is set to <i><font color="#800000">
false</font></i>. When <b>Pointer</b> refers to a not yet available </p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Generic_Blackboard.Put"></a>procedure</font> 
	Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
	<font color="#0000FF">in out</font> Blackboard;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Pointer</b> : <font color="#0000FF">out</font> Reference<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#0000FF"><br>
	procedure</font> 
	Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Storage</b> :
	<font color="#0000FF">in out</font> Blackboard;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
	Element</b> : Element_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure puts <b>Element</b> into <b>Storage</b> and returns a 
reference to it, when the parameter <b>Pointer</b> is used. The operation overrides the most outdated items in the 
blackboard making references to them invalid. Storage_Error is propagated when
<b>Element</b> is too large to fit into <b>Storage</b> even if it alone there. 
The procedure is the only one which shall be used from one task or else 
exclusively.</p>
<blockquote>
	<p><tt><font color="#0000FF">function </font>Upper (<b>Storage</b> : 
	Blackboard) <font color="#0000FF">return</font> Reference;</tt></p>
</blockquote>
<p>This function returns the least upper bound of <b>Storage</b>. That is the 
reference to the element which will be put next into.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">&lt;</font>&quot; 
	(<b>Storage</b> : Blackboard; <b>Pointer</b> : Reference)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">&gt;</font>&quot; (<b>Storage</b> 
	: Blackboard; <b>Pointer</b> : Reference)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">&lt;</font>&quot; (<b>Pointer</b> 
	: Reference; <b>Storage</b> : Blackboard)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">&gt;</font>&quot; (<b>Pointer</b> 
	: Reference; <b>Storage</b> : Blackboard)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>These functions provide reference validity checks. <b>Storage</b> &lt; <b>
Pointer</b>, when <b>Pointer</b> refers to an element not yet written into the 
blackboard. The procedure <a href="#Generic_Blackboard.Next">
Next</a> returns such reference when it reaches the end of a blackboard.<b> 
Storage</b> &gt; <b>Pointer</b>, when <b>Pointer</b> refers to a lost element, which 
is already overridden by newer elements. When neither <b>Storage</b> &lt; <b>
Pointer </b>nor<b> Storage</b> &gt; <b>Pointer</b>, then <b>Pointer</b> is refers 
to an accessible (valid) element in <b>Storage</b>. In other words comparisons 
are made in the sense of intervals, when the blackboard is considered as a 
consequent range of contained elements. Because the blackboard elements are 
written in FIFO order, the following statement is 
true:</p>
<blockquote>
	<p>Let S<sub>1</sub>, S<sub>2</sub> be the states of a blackboard S at the times
	<i>t</i><sub>1</sub>&le;<i>t</i><sub>2</sub>. P<sub>1</sub>, P<sub>2</sub> 
	be the states of a reference P to the same blackboard element at the 
	corresponding times, then</p>
	<p>&nbsp;&nbsp;&nbsp; S<sub>1</sub>&gt;P<sub>1</sub> =&gt; S<sub>2</sub>&gt;P<sub>2<br>
	</sub>&nbsp;&nbsp;&nbsp; S<sub>2</sub>&lt;P<sub>2</sub> =&gt; S<sub>1</sub>&lt;P<sub>1</sub></p>
</blockquote>
<blockquote>
	<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">&lt;</font>&quot;&nbsp; 
	(<b>Left</b>, <b>Right</b> : Reference) <font color="#0000FF">return</font> 
	Boolean;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">&gt;</font>&quot;&nbsp; 
	(<b>Left</b>, <b>Right</b> : Reference) <font color="#0000FF">return</font> 
	Boolean;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">&lt;=</font>&quot; (<b>Left</b>,
	<b>Right</b> : Reference) <font color="#0000FF">return</font> Boolean;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">&gt;=</font>&quot; (<b>Left</b>,
	<b>Right</b> : Reference) <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>References are directly comparable even if not valid. Elements put later onto 
the blackboard have greater references.</p>
<blockquote>
	<p><tt>First_Reference : <font color="#0000FF"> constant</font> Reference;</tt></p>
</blockquote>
<p>This value is of a reference to the first blackboard element.</p>
<H4>9.2.2. Multiple publishers blackboard</H4>
<p><a name="Generic_Blackboard.Generic_Task_Safe"></a>The child package
<a href="#Generic_Blackboard.Generic_Task_Safe">Generic_Blackboard.Generic_Task_Safe</a> provides a 
blackboard, which is safe to use with any number of publishers:</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
	package </font>Generic_Blackboard.Generic_Task_Safe<font color="#0000FF"> is</font> ...</tt></p>
</blockquote>
<p>The package provides a derived blackboard type: </p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Shared_Blackboard<font color="#0000FF"> 
	is new </font>Blackboard<font color="#0000FF"> with private</font>;</tt></p>
</blockquote>
<p>This type overrides the procedure <a href="#Generic_Blackboard.Put">Put</a> 
with an implementation that uses a protected subprogram in order to write the 
blackboard in a task safe way.</p>
<hr>
<p align="right">
  <A name="10"></A><a href="#9.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#10.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H2>10. Locking synchronization primitives</H2>
<p><a name="Synchronization"></a>The package <a href="#Synchronization">Synchronization</a> is a parent package 
of the child packages providing various locking synchronization primitives. The 
package defines:</p>
<blockquote>
	<p><tt>Ownership_Error : <font color="#0000FF">exception</font>;</tt></p>
</blockquote>
<p align="right">
  <A name="10.1"></A><a href="#10"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#10.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>10.1. Notes on programming with protected objects</H3>
<p>Here it is appropriate to discuss some techniques used in Ada for task 
synchronization. There exist two major mechanisms of synchronization in Ada:</p>
<ul>
	<li><i>rendezvous</i></li>
	<li><i>protected objects</i></li>
</ul>
<p>Rendezvous is an synchronous call to an entry of a task. As such it cannot be 
reused unless the task types have multiple instances. It is also considered 
heavy-weight because it often requires context switching. However, rendezvous 
and protected objects should not be considered competing. There exist problems 
more natural to solve with rendezvous than with protected objects, and the inverse.</p>
<p>A protected object has a state and three types of operations to handle its 
state:</p>
<ul>
	<li><i>protected function</i> can safely access the state, but cannot change 
	it, at least officially;</li>
	<li><i>protected procedure</i> can safely change the protected object state;</li>
	<li><i>entry</i> can do anything and also can be queued to.</li>
</ul>
<p>The difference between <i>protected procedures</i> and <i>entries</i> is in 
the queue. When a protected procedure is called that never blocks the caller 
task. When an entry is called that potentially blocks.</p>
<blockquote>
	<p><i>Non-blocking</i> does not imply any specific time constraint. In fact 
	a non-blocking call to a protected object may result in some delay. It is 
	also possible that the task doing it would in effect loose the processor. 
	Non-blocking only means that the waiting time does not depend on either the 
	program logic or its inputs. So it is considered &quot;instant&quot; from the program 
	point of view. Blocking means that the program logic can become aware of the 
	delay caused by the call. For example, I/O is considered blocking. The 
	program shall be prepared to deal with blocking. This is one reason why <i>
	entries</i> and <i>procedures</i> are distinct in protected objects.</p>
</blockquote>
<p>When an entry call blocks the caller task spends its time in the queue of the 
entry. Each entry also has a barrier, a condition which opens or closes the 
entry. When an entry is open, a task calling to the entry can be unblocked in 
order to execute the entry body. When the entry is closed, the task is blocked 
and stays in the entry queue. The barrier depends on the protected object state. 
Though it is possible to refer to non-local variables from the barrier, that 
would be useless because the barriers are re-evaluated only when the protected 
object state is &quot;officially&quot; changed. And this happens only when a protected 
procedure or an entry body is executed.</p>
<p>So the actual parameters and global variables cannot be used in the barriers. 
That is quite limiting. Fortunately, there exists a technique to circumvent this 
constraint. The technique is based on the <i>requeue</i> 
statement (see <a href="http://www.adaic.com/standards/05rm/html/RM-9-5-4.html"> <i>Ada 
Language Reference Manual</i> 9.5.4</a>), which is one the most 
powerful constructs of the Ada concurrency model. A task 
queued to a protected object entry can be re-queued to another entry under the 
condition that the parameter profile is same or else that the new entry does not 
have any parameters. Requeue is used in the &quot;lounge&quot; pattern discussed below.</p>
<p>Let us consider creating a shared counter. A counter can be incremented. It 
can be awaited for reaching some definite value. The interface of such a counter 
might look as follows:</p>
<blockquote>
	<p><tt><font color="#0000FF">protected type </font>Counter<font color="#0000FF"> 
	is<br>
&nbsp;&nbsp; entry</font> Wait (Goal : Natural); <font color="#008000">-- Wait for Goal 
	&gt;= Value</font><br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#008000">-- Increment counter</font><br>
	<font color="#0000FF">private<br>
	</font>&nbsp;&nbsp; Value : Natural := <font color="#800000">0</font>;&nbsp;&nbsp;&nbsp;
	<font color="#008000">&nbsp;&nbsp;&nbsp; -- The current counter state<br>
	</font><font color="#0000FF">end </font>Counter;</tt></p>
</blockquote>
<p>The procedure Count increments the counter value by 1. The entry Wait is used 
in order to wait for a state when Goal is greater than or equal to the counter 
value. This condition cannot be specified as the barrier of Wait. The solution 
of the problem is to add a private family of entry points Lounge:</p>
<blockquote>
	<p><tt><font color="#0000FF">protected type </font>Counter<font color="#0000FF"> 
	is<br>
&nbsp;&nbsp; entry</font> Wait (Goal : Natural);&nbsp;&nbsp; <font color="#008000">
	-- Wait for Goal &gt;= Value</font><br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#008000">-- Increment counter</font><br>
	<font color="#0000FF">private<br>
&nbsp;&nbsp; entry</font> Lounge (Boolean) (Goal : Natural);
	<font color="#008000">-- Callers are waiting here</font><br>
&nbsp;&nbsp; Value&nbsp;&nbsp; : Natural := <font color="#800000">0</font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- The 
	current counter state<br>
	</font>&nbsp;&nbsp; Current : Boolean := False;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#008000">&nbsp;-- The current update state</font><br>
	<font color="#0000FF">end </font>Counter;</tt></p>
</blockquote>
<p>The implementation of Wait has the 
barrier true (no waiting). It checks if the condition is met and otherwise 
re-queues to the entry Lounge, where the caller task will actually wait for the 
condition to meet.</p>
<blockquote>
	<p><tt><font color="#0000FF">entry</font> Wait (Goal : 
	Natural) <font color="#0000FF">when </font>True<font color="#0000FF"> is<br>begin<br>&nbsp;&nbsp; if
	</font>Goal &gt;= Value<font color="#0000FF"> then </font>
	<font color="#008000">-- Enter actual waiting if not 
	met<br></font><font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requeue
	</font>Lounge (<font color="#0000FF">not </font>Current)<font color="#0000FF"> with abort</font>;<font color="#0000FF"><br>&nbsp;&nbsp; end if</font>;<br>
	<font color="#0000FF">end</font> Wait;</tt></p>
</blockquote>
<p>The barrier of Lounge is informally &quot;object's state has 
changed.&quot; This also cannot be spelt using the object's state alone. But it can 
be done using entry families. So the entry Lounge is split into two. In the 
declaration of it has <tt>(Boolean)</tt> following the entry name, which means, there 
exists Lounge (True) and Lounge (False). The object itself is in two states 
reflected by the variable Current. When Current is <i><font color="#800000">true</font></i>, 
Lounge (True) is open and Lounge (False) is closed. When Current is <i>
<font color="#800000">false</font></i>, they change places. The procedure Count 
increments the counter and then toggles Current. This causes tasks queued to a 
Lounge to execute the body and releases those of them the counter state reached Goal. 
Others are requeued back to the opposite Lounge entry: </p>
<blockquote>
	<p><tt><font color="#0000FF">entry</font> Lounge (<font color="#0000FF">for</font> Toggle
	<font color="#0000FF">use</font> Boolean) (Goal : 
	Natural)<br>
&nbsp; <font color="#0000FF">&nbsp;when </font>Toggle = 
	Current<font color="#0000FF"> is<br>
	begin<br>
	&nbsp;&nbsp; if </font>Goal &gt;= Value<font color="#0000FF"> 
	then&nbsp;&nbsp; </font><font color="#008000">-- Continue waiting if not met<br>
	</font><font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requeue </font>Lounge (<font color="#0000FF">not
	</font>Current)<font color="#0000FF"> 
	with abort</font>;<font color="#0000FF"><br>
	&nbsp;&nbsp; end if</font>;<br>
	<font color="#0000FF">end</font> Lounge;</tt></p>
</blockquote>
<p>The procedure Count increments Value and switches lounges:</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Count<font color="#0000FF"> is<br>begin<br>&nbsp;&nbsp;
	</font>Value&nbsp;&nbsp; := Value +
	<font color="#800000">1</font>; <font color="#008000">&nbsp; -- Increment 
	counter<br></font><font color="#0000FF">&nbsp; </font>&nbsp;Current 
	:= <font color="#0000FF">not</font> Current; <font color="#008000">-- Pulse 
	state change</font><br><font color="#0000FF">end</font> Count;</tt></p>
</blockquote>
<p>Here a careful reader could observe that this solution has a race condition, 
when Count toggles Current, there is no guarantee that all tasks from the 
corresponding Lounge's queue will execute the Lounge's body before next 
increment. In order to ensure that, a 
final step has to be done:</p>
<blockquote>
	<p><tt><font color="#0000FF">protected type </font>Counter<font color="#0000FF"> 
	is<br>
&nbsp;&nbsp; entry</font> Wait (Goal : 
	Natural); <font color="#008000">-- Wait for Goal &gt;= Value</font><br>
&nbsp;&nbsp; <font color="#0000FF">entry</font> Count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#008000">&nbsp; -- Increment counter</font><br>
	<font color="#0000FF">private<br>
&nbsp;&nbsp; entry</font> Lounge (Boolean) (Goal : Natural);
	<font color="#008000">-- Callers are waiting here</font><br>
&nbsp;&nbsp; Value&nbsp;&nbsp; : Natural := <font color="#800000">0</font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- The 
	current counter state<br>
	</font>&nbsp;&nbsp; Current : Boolean := False;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<font color="#008000">&nbsp;-- The current update state</font><br>
	<font color="#0000FF">end </font>Counter;</tt></p>
</blockquote>
<p>Here Count becomes an entry. This allows us to lock it when the queue of a 
Lounge from the previous notification step is not yet empty.</p>
<blockquote>
	<p><tt><font color="#0000FF">entry</font> Count <font color="#0000FF">when</font> 
	Lounge (Current)'Count =
	<font color="#800000">0</font> <font color="#0000FF">is<br>
	begin<br>
	&nbsp;&nbsp; </font>Value&nbsp;&nbsp; := Value +
	<font color="#800000">1</font>; <font color="#008000">&nbsp; -- Increment 
	counter<br>
	</font><font color="#0000FF">&nbsp; </font>&nbsp;Current 
	:= <font color="#0000FF">not</font> Current; <font color="#008000">-- Pulse 
	state change</font><br>
	<font color="#0000FF">end</font> Count;</tt></p>
</blockquote>
<p>Though Count is now an entry it does not really block.</p>
<p>The &quot;lounge&quot; pattern is considerably universal. In fact, the implementations 
of the most of the synchronization primitives described below are based on this 
pattern.</p>
<p align="right">
  <A name="10.2"></A><a href="#10.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#10.3"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>10.2. Events</H3>
<p><a name="Events"></a>An event is a synchronization object with a state, that 
can be changed 
and awaited for. As a synchronization primitive event is very low-level, and 
thus, is exposed to various 
problems from race condition to deadlocking. For this reason they should be used 
with a great care.</p>
<H4>10.2.1. Simple event</H4>
<p><a name="Synchronization.Events"></a>The package
<a href="#Synchronization.Events">Synchronization.Events</a> provides an 
implementation of a simple event. An event can be signaled, reset, and awaited 
for a definite state. Note that if the events need to be used in a combination 
the package
<a href="#Synchronization.Generic_Events_Array">
Synchronization.Generic_Events_Array</a> should be used instead. The event is 
signaled and reset manually, which can be a source of race condition when 
signaling is close followed by resetting. Such events represent a special case
<i>pulse events</i>. See the package
<a href="#Synchronization.Pulse_Events">Synchronization.Pulse_Events</a> which 
provides a race condition safe implementation of.</p>
<blockquote>
	<p><tt><font color="#0000FF">protected type </font>Event<font color="#0000FF"> 
	is </font>...</tt></p>
</blockquote>
<p>This is the type of the protected object implementing an event. The following 
subprograms and entries are provided:</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Signaled
	<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if the event 
is signaled.</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Reset;</tt></p>
</blockquote>
<p>This procedure sets the event into the non-signaled state. It releases all 
tasks queued to the entry <a href="#Synchronization.Events.Wait_For_Reset">Wait_For_Reset</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF">procedure</font> Signal;</tt></p>
</blockquote>
<p>This procedure signals the event. It releases all tasks queued to the entry
<a href="#Synchronization.Events.Wait">Wait</a>.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Events.Wait"></a>entry</font> 
	Wait;</tt></p>
</blockquote>
<p>This entry blocks until the event is signaled.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Events.Wait_For_Reset"></a>
	entry</font> Wait_For_Reset;</tt></p>
</blockquote>
<p>This entry blocks until the event is signaled.</p>
<H4>10.2.2. Pulse event</H4>
<p><a name="Synchronization.Pulse_Events"></a>The package
<a href="#Synchronization.Pulse_Events">Synchronization.Pulse_Events</a>&nbsp;provides 
an implementation of pulse events. A pulse events is signaled for a short, 
actually indivisible, period 
of time. It is reset automatically immediately after the last task awaiting the 
event is released. The implementation provided by this package is free of race 
conditions. That is, even if a task, released by the event, seized the processor 
before releasing other tasks, and then entered another wait for the same event, 
that would not release this task again. It will be blocked until a next 
pulsation of the event. The implementation also ensures that 
all tasks entering waiting before event pulsation are released before any 
consequent 
pulsation. The following diagram illustrates the constraints satisfied by 
the implementation in order to prevent race conditions:</p>
<blockquote>
	<p><img border="0" src="pulse_event.gif" width="518" height="173"></p>
</blockquote>
<p>As the diagram shows both pulsing and waiting are postponed until the end of 
releasing already blocked tasks. Any task entering waiting stay blocked while 
other tasks are released.</p>
<blockquote>
	<p><tt><font color="#0000FF">protected type </font>Pulse_Event<font color="#0000FF"> 
	is </font>...</tt></p>
</blockquote>
<p>This is the type of the protected object implementing a pulse event. The 
following subprograms and entries are provided:</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Pulse_Events.Pulse">
	</a>entry</font> Pulse;</tt></p>
</blockquote>
<p>This entry release all tasks waiting for the event. Note that though this is 
an entry, it does not block for any considerable time. When accepted, it releases 
all tasks queued to the entry <a href="#Synchronization.Pulse_Events.Wait">Wait</a> before 
any next <a href="#Synchronization.Pulse_Events.Pulse">Pulse</a> takes effect.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Pulse_Events.Wait">
	</a>entry</font> Wait;</tt></p>
</blockquote>
<p>This entry waits for event pulsing by
<a href="#Synchronization.Pulse_Events.Pulse">Pulse</a>.</p>
<H4>10.2.3. Events pulsing a value</H4>
<p><a name="Synchronization.Generic_Pulse_Events"></a>The package
<a href="#Synchronization.Generic_Pulse_Events">Synchronization.Generic_Pulse_Events</a>&nbsp;is 
a generic variant of
<a href="#Synchronization.Pulse_Events">Synchronization.Pulse_Events</a> which 
additionally distributes a value when an event is pulsed. The package is 
generic:</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Event_Value<font color="#0000FF"> is private</font>;<font color="#0000FF"><br>
	package </font>Synchronization.Generic_Pulse_Events<font color="#0000FF"> is </font>...</tt></p>
</blockquote>
<p>The formal generic parameter is the type of the values distributed when the 
event is pulsed.</p>
<blockquote>
	<p><tt><font color="#0000FF">protected type </font>Pulse_Event<font color="#0000FF"> 
	is </font>...</tt></p>
</blockquote>
<p>This is the type of the protected object implementing a pulse event. The 
following subprograms and entries are provided:</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Generic_Pulse_Events.Pulse">
	</a>entry</font> Pulse (<b>Value</b> : Event_Value);</tt></p>
</blockquote>
<p>This entry release all tasks waiting for the event and propagates <b>Value</b> 
to each of them. Note that though this is 
an entry, it does not block for any considerable time. When accepted, it releases 
all tasks queued to the entry <a href="#Synchronization.Generic_Pulse_Events.Wait">Wait</a> 
passing <b>Value</b> to all of them. Any consequent
<a href="#Synchronization.Generic_Pulse_Events.Pulse">Pulse</a> is blocked until 
end of releasing the tasks.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Generic_Pulse_Events.Wait">
	</a>entry</font> Wait (<b>Value</b> : <font color="#0000FF">out</font> Event_Value);</tt></p>
</blockquote>
<p>This entry waits for event pulsing by
<a href="#Synchronization.Generic_Pulse_Events.Pulse">Pulse</a>. The parameter 
Value is the value specified in the call to
<a href="#Synchronization.Generic_Pulse_Events.Pulse">Pulse</a>.</p>
<H4>10.2.4. Arrays of events</H4>
<p><a name="Synchronization.Generic_Events_Array"></a>The package
<a href="#Synchronization.Generic_Events_Array">
Synchronization.Generic_Events_Array</a> provides arrays of events. The 
objective of the design is to allow waiting for any combination of the events. The 
events from the array can be signaled, reset and awaited for. The implementation 
represented here is free of race conditions, when the state of the events is 
being changed. In this case it guarantees that all tasks awaiting for the state 
are released before any consequent state change. Another common class of race 
conditions is eliminated by providing atomic signal-then-wait 
operations. For instance a set of tasks may synchronize themselves at dedicated 
points by signaling an event and then awaiting for all events signaled. If tasks later reset 
their events, that would constitute a race condition, because a 
task might reset its event before other tasks queued for all events set. The 
following figure illustrates the case:</p>
<blockquote>
	<p><img border="0" src="events_array_deadlock.gif"></p>
</blockquote>
<p>In this example the deadlock of the task <i>B</i> is caused a premature resetting the event
<i>A</i>. An 
atomic signaling and waiting breaks the deadlock.</p>
<p>The package is generic</p>
<blockquote>
	<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Event_Type<font color="#0000FF"> is</font> (&lt;&gt;);<font color="#0000FF"><br>
	package </font>Synchronization.Generic_Events_Array<font color="#0000FF"> is</font> ...</tt></p>
</blockquote>
<p>The formal parameter is the index type of the events array. The package 
defines the following supplementary types: </p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Events_State<font color="#0000FF"> 
	is array </font>(Event_Type)<font color="#0000FF"> of</font> Boolean;</tt></p>
</blockquote>
<p>Objects of this type describe the state of an events array. For each event 
Event_State contains <font color="#800000"><i>true</i></font> if the event is 
signaled. The following set-theoretic operations are defined additionally to the 
standard operations of Boolean arrays in order to ease composition of arrays:</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot; 
	(<b>Left</b>, <b>Right</b> : Event_Type) <font color="#0000FF">return</font> 
	Events_State;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot; (<b>Left</b> 
	: Events_State; <b>Right</b> : Event_Type) <font color="#0000FF">&nbsp; 
	return</font> Events_State;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot; (<b>Left</b> 
	: Event_Type; <b>&nbsp; Right</b> : Events_State) <font color="#0000FF">
	return</font> Events_State;</tt></p>
</blockquote>
<p>These functions compose a set when one parameter specifies an event.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">not</font>&quot; 
	(<b>Left</b> : Event_Type) <font color="#0000FF">return</font> Events_State;</tt></p>
</blockquote>
<p>This function creates a complement set of a singleton event.</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Abstract_Condition<font color="#0000FF"> 
	is abstract<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Controlled<font color="#0000FF"> with 
	null record</font>;</tt></p>
</blockquote>
<p>This type represents an abstract condition to wait for. The entries of the 
events array awaits for instances of the types derived from this base type. The 
derived type shall override the abstract primitive operation Satisfied. 
User-defined conditions can be created by deriving from this type.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Satisfied<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Condition</b> : 
	Abstract_Condition;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>State</b>&nbsp;&nbsp;&nbsp;&nbsp; 
	: Events_State<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
	return </font>Boolean<font color="#0000FF"> is abstract</font>;</tt></p>
</blockquote>
<p>This function is used to check if the condition is satisfied. The parameter
<b>State</b> is the current state of the events array. Note that the function is 
called in the course of a protected action. That means, that it shall neither 
block, nor invoke any other protected actions. Further if it accesses shared 
non-local data, the user shall warranty that these data are either atomic or 
else are never accessed outside the protected actions of Events_Array.</p>
<p>The package provides some frequently used conditions:</p>
<blockquote>
	<p><tt>Always_Signaled : <font color="#0000FF">constant</font> 
	Abstract_Condition'Class;<br>
	<a name="Synchronization.Generic_Events_Array.All_Signaled"></a>All_Signaled&nbsp;&nbsp;&nbsp; : <font color="#0000FF">constant</font> 
	Abstract_Condition'Class;<br>
	Any_Signaled&nbsp;&nbsp;&nbsp; : <font color="#0000FF">constant</font> 
	Abstract_Condition'Class;<br>
	No_Signaled&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">constant</font> 
	Abstract_Condition'Class;</tt></p>
</blockquote>
<p>The conditions:</p>
<ul>
	<li><i>Always_Signaled</i> is always satisfied,</li>
	<li><i>All_Singaled</i> 
is satisfied when all events are signaled;</li>
	<li><i>Any_Signaled</i> is satisfied when at 
least one event is signaled;</li>
	<li><i>No_Signaled</i> is satisfied when no events signaled.</li>
</ul>
<p>Further conditions are returned by:</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Signaled (<b>Event</b> : 
	Event_Type) <font color="#0000FF">return</font> Event_Signaled;</tt></p>
</blockquote>
<p>This function returns a condition satisfied when <b>Event</b> is 
signaled.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Reset (<b>Event</b> : 
	Event_Type) <font color="#0000FF">return</font> Event_Reset;</tt></p>
</blockquote>
<p>This function returns a condition satisfied when <b>Event</b> is not 
signaled.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Events_Array.Events_Array"></a>protected 
	type </font>Events_Array <font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>Protected objects of this type represent arrays of events. Initially all 
events in the array are non-signaled. The following operations and entry points 
are defined for <a href="#Synchronization.Generic_Events_Array.Events_Array">
Events_Array</a>:</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Get_State <font color="#0000FF">
	return</font> Events_State;</tt></p>
</blockquote>
<p>This function returns the state of the array. The result is an array which 
for each event contains <i><font color="#800000">true</font></i> if the event is 
signaled.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Signaled (<b>Event</b> : 
	Event_Type)<font color="#0000FF"> return</font> Events_State;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Event</b> 
is signaled.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Events_Array.Reset"></a>entry</font> Reset<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Events</b>&nbsp;&nbsp;&nbsp; : 
	Events_State;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Condition</b> : 
	Abstract_Condition'Class := Always_Signaled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
	<font color="#0000FF">entry</font> Reset<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Event</b>&nbsp;&nbsp;&nbsp;&nbsp; : 
	Event_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Condition</b> : 
	Abstract_Condition'Class := Always_Signaled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>These entries reset an event or a number of events to the non-signaled 
state. When the first parameter specifies an event, then the event is set to the 
non-signaled state. When the parameter is an array, then each event for which 
the array contains <i><font color="#800000">true</font></i> is reset to the 
non-signaled state. The parameter <b>Condition</b> is the condition to wait for 
immediately after resetting the events. The default value is Always_Signaled, 
i.e. <a href="#Synchronization.Generic_Events_Array.Reset">Reset</a> returns 
after changing the events without waiting. Entering waiting, if any, is 
indivisible from resetting the events.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Events_Array.Signal"></a>entry</font> 
	Signal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Events</b>&nbsp;&nbsp;&nbsp; : 
	Events_State;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Condition</b> : 
	Abstract_Condition'Class := Always_Signaled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
	<font color="#0000FF">entry</font> Signal<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Event</b>&nbsp;&nbsp;&nbsp;&nbsp; : 
	Event_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Condition</b> : 
	Abstract_Condition'Class := Always_Signaled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>These entries signal an event or a number of events. When the first parameter 
is an event, then the event is signaled. When the parameter is an array, then 
each event for which the array contains <i><font color="#800000">true</font></i> 
is signaled. The parameter <b>Condition</b> is the condition to wait for 
immediately after signaled the events. The default value is Always_Signaled, 
i.e. <a href="#Synchronization.Generic_Events_Array.Signal">Signal</a> returns 
after changing the events without waiting. Entering waiting, if any, is 
indivisible from signaling the events.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Events_Array.Set"></a>entry</font> Set<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>State</b>&nbsp;&nbsp;&nbsp;&nbsp; : 
	Events_State;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Condition</b> : 
	Abstract_Condition'Class := Always_Signaled<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This entry sets all events according to the value of <b>State</b>. The parameter 
<b>Condition</b> specifies the condition to wait for, immediately after setting the events. The default value is Always_Signaled, i.e. 
<a href="#Synchronization.Generic_Events_Array.Set">Set</a> returns after changing the events without waiting. 
Entering waiting, if any, is indivisible from setting the events.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	entry</font> Wait (<b>Condition</b> : 
	Abstract_Condition'Class);</tt></p>
</blockquote>
<p>This entries waits for <b>Condition</b>. See also <a href="#Synchronization.Generic_Events_Array.Signal">Signal</a>, <a href="#Synchronization.Generic_Events_Array.Reset">Reset</a> 
and 
<a href="#Synchronization.Generic_Events_Array.Set">Set</a> entries which also 
are capable of waiting for a certain condition.</p>
<H4>10.2.5. Sample. Synchronization at a checkpoint</H4>
<p><a name="Checkpoint_synchronization"></a>The following example illustrates use of the package 
for checkpoint synchronization problem: The problem arise when several tasks perform some jobs and need to be synchronized when all jobs 
are completed. A job completion is signaled by an event. A task completing its 
job signals the 
event, waits for other events signaled and then resets the event. This procedure 
is exposed to race conditions and deadlocks.</p>File <i>
test_synchronization_events_array.ads</i>:<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> 
Synchronization.Generic_Events_Array;<br>
<br>
<font color="#0000FF">package</font> Test_Synchronization_Events_Array<font color="#0000FF"> 
is<br>
&nbsp;&nbsp; type </font>Worker_ID <font color="#0000FF">is</font> (A, B, C);<br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Events_Arrays
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;</font>Synchronization.Generic_Events_Array&nbsp;(Worker_ID);<br>
<font color="#0000FF">end</font> Test_Synchronization_Events_Array;</tt></TD>
  </TR>
</TABLE>
<p>This package instantiates
<a href="#Synchronization.Generic_Events_Array">
Synchronization.Generic_Events_Array</a>, which is necessary to do at the 
library level in Ada 95. In Ada 2005 it can be instantiated in nested scopes.</p>File 
<i>test_synchronization_events.adb</i> (<i>part of</i>)
:<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; ...<br>
<font color="#0000FF">with</font>&nbsp;Ada.Numerics.Float_Random;&nbsp;&nbsp;<font color="#0000FF">use</font>&nbsp;Ada.Numerics.Float_Random;<br>
<font color="#0000FF">with</font> Ada.Text_IO;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font> Ada.Text_IO;<br>
<br>
<font color="#0000FF">with</font> Test_Synchronization_Events_Array;<br>
<font color="#0000FF">use</font>&nbsp; Test_Synchronization_Events_Array;<br>
<font color="#0000FF">use</font>&nbsp; Events_Arrays;<br>
&nbsp;&nbsp; ...<br>
Worker_State : Events_Array;<br>
<br>
<font color="#0000FF">task type </font>Worker (ID : Worker_ID);<br>
<font color="#0000FF">task body</font> Worker <font color="#0000FF">is</font><br>
&nbsp;&nbsp; Dice : Generator;<br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp; Reset (Dice);<br>
&nbsp;&nbsp; <font color="#0000FF">for</font> Index <font color="#0000FF">in</font>
<font color="#800000">1</font>..<font color="#800000">10</font>
<font color="#0000FF">loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put_Line<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Worker_ID'Image (ID)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; &quot;<font color="#FF0000"> doing things</font>&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; Integer'Image (Index)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">delay</font> Duration 
(Random (Dice) * <font color="#800000">0.100</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Worker_State.Signal (ID, All_Signaled);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Worker_State.Reset (ID);<br>
&nbsp;&nbsp; <font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp; Put_Line (Worker_ID'Image (ID) &amp; &quot;<font color="#FF0000"> finished</font>&quot;);<br>
<font color="#0000FF">end</font> Worker;<br>
<br>
T1 : Worker (A);<br>
T2 : Worker (B);<br>
T3 : Worker (C);</tt></TD>
  </TR>
</TABLE>
<p>Here three tasks perform some piece of work. The work is simulated by waiting 
for a random period of time. At the end of each cycle a worker sets its event in 
the array of the events Worker_State. Then it waits for other workers. This 
action is 
performed atomically by:</p>
<blockquote>
	<p><tt>Worker_State.Signal (ID, All_Signaled);</tt></p>
</blockquote>
<p>Here ID is the worker/event identifier and 
<a href="#Synchronization.Generic_Events_Array.All_Signaled">All_Signaled</a> is a condition 
satisfied when all events are set. After this the worker resets its event</p>
<blockquote>
	<p><tt>Worker_State.Reset (ID);</tt></p>
</blockquote>
<p>and 
starts a new iteration of the cycle.</p>
<p align="right">
  <A name="10.3"></A><a href="#10.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>10.3. Mutexes</H3>
<p><a name="Mutexes"></a><i>Mutex</i> stands for <b>Mut</b>ual <b>Ex</b>clusion. 
It is a synchronization object used to prevent concurrent access to a resource. 
A more general but rarely used in practice concept is <i>semaphore</i> introduced by Edsger Dijkstra. 
Technically mutex is a semaphore with the count <i>k</i>=1. The count 1 means 
that only one task can own the mutex at a time. Mutexes are exposed to deadlocks 
when a task attempts to seize more than one mutex. It is enough to have two tasks and two 
mutexes in order to be able to construct a deadlock. Yet another problem is 
resource starvation caused by a 
premature termination of a task owning the mutex, for example, upon exception 
propagation.</p>
<H4>10.3.1. Reentrant mutex</H4>
<p><a name="Synchronization.Mutexes"></a>The package
<a href="#Synchronization.Mutexes">Synchronization.Mutexes</a> provides an 
implementation of mutexes, free of one particular problem, when a mutex 
is repetitively seized by the same task. The implementation avoids deadlock by 
allowing a task to seize the mutex more than once.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Mutexes.Mutex"></a>protected 
	type </font>Mutex <font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>Protected objects of this type represent mutexes. The following operations and entry points 
are defined for <a href="#Synchronization.Mutexes.Mutex">Mutex</a>:</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Get_Owner <font color="#0000FF">
	return</font> Task_ID;</tt></p>
</blockquote>
<p>This function returns the identification of the task owning the mutex. See 
the standard package Ada.Task_Identification for further information.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Mutexes.Grab"></a>
	procedure</font> Grab;</tt></p>
</blockquote>
<p>This procedure seizes the mutex if it is not owned by another task. <a href="#Synchronization.Mutexes.Is_Mine">Is_Mine</a> can be used afterwards in order to verify if the mutex 
was indeed seized. When the mutex was seized it shall be released by a 
call to <a href="#Synchronization.Mutexes.Release">Release</a>. For example:</p>
<blockquote>
	<p><tt>&nbsp;&nbsp; Resource : Mutex; <font color="#008000">&nbsp;&nbsp; -- A resource<br>
&nbsp;&nbsp; </font>...<br>
	<font color="#0000FF">begin<br>
	</font>&nbsp;&nbsp; ...<br>&nbsp;&nbsp; Resource.Grab; <font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Try to seize it without 
		blocking</font><br><font color="#0000FF">&nbsp;&nbsp; if</font> Resource.Is_Mine 
	<font color="#0000FF">then</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
	<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		-- Use the resource safely</font><br>&nbsp;&nbsp;
&nbsp;&nbsp; Resource.Release; <font color="#008000">-- Note, it has to be 
		released</font><br><font color="#0000FF">&nbsp;&nbsp; end if</font>;</tt></p>
</blockquote>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Mutexes.Is_Mine"></a>
	function</font> Is_Mine <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if the mutex is 
owned by the caller task.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Owned <font color="#0000FF">
	return</font> Boolean;</tt></p>
</blockquote>
<p>This function return <i><font color="#800000">true</font></i> if the mutex is 
owned by a task.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Mutexes.Release"></a>
	procedure</font> Release;</tt></p>
</blockquote>
<p>This procedure releases the mutex previously seized by
<a href="#Synchronization.Mutexes.Grab">Grab</a> or 
<a href="#Synchronization.Mutexes.Seize">Seize</a>. Note that each call 
to <a href="#Synchronization.Mutexes.Seize">Seize</a> and each call to 
<a href="#Synchronization.Mutexes.Grab">Grab</a> that seized the mutex shall be matched by a call 
to <a href="#Synchronization.Mutexes.Release">Release</a>. Ownership_Error is 
propagated when the mutex is not owned by the caller task.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Mutexes.Seize"></a>
	entry</font> Seize;</tt></p>
</blockquote>
<p>This entry is used to seize the mutex. It blocks until the mutex becomes 
free. It does not block if the mutex is already owned by the caller task. Each call 
to <a href="#Synchronization.Mutexes.Seize">Seize</a> shall be matched by a call 
to <a href="#Synchronization.Mutexes.Release">Release</a>.</p>
<p>The package also defines:</p>
<blockquote>
	<p><tt><font color="#0000FF">type</font> Holder (Resource :
	<font color="#0000FF">access</font> Mutex) <font color="#0000FF">is<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>This is a helper type used to ensure that each
<a href="#Synchronization.Mutexes.Seize">Seize</a> is matched by a <a href="#Synchronization.Mutexes.Release">Release</a> 
even if an exception is propagated. It is used as follows:</p>
<blockquote>
	<p><tt>&nbsp;&nbsp; Resource : <font color="#0000FF">aliased</font> Mutex; 
	<font color="#008000">-- A resource<br>
&nbsp;&nbsp; </font>...<br>
	<font color="#0000FF">begin<br>
	</font>&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; <font color="#0000FF">declare</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	Lock : Holder (Resource'Access);<font color="#008000"> -- Seize the resource</font><br>
	<font color="#0000FF">&nbsp;&nbsp; begin</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<font color="#008000">&nbsp; -- 
	Enjoy exclusive access</font><br><font color="#0000FF">&nbsp;&nbsp; end</font>;&nbsp;
	<font color="#008000">&nbsp; -- Release the resource</font></tt></p>
</blockquote>
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD>
<i>It is strongly recommended to use a Holder object in order to access a mutex 
even if that might cause some overhead. The reason is that asynchronous 
transfer of control (Language Reference Manual </i><a href="http://www.adaic.com/standards/05rm/html/RM-9-7-4.html">9.7.4</a>)<i>) 
from a task owning a mutex might leave the mutex seized. A Holder object 
warranties mutex release. In general one should 
avoid asynchronous transfer of control.</i></TD>
  </TR>
</TABLE>
<H4>10.3.2. Arrays of mutexes</H4>
<p><a name="Synchronization.Generic_Mutexes_Array"></a>The package
<a href="#Synchronization.Generic_Mutexes_Array">Synchronization.Generic_Mutexes_Array</a> provides an 
implementation of arrays of mutexes. Arrays of mutexes are deadlock free. The 
deadlock is prevented by numerous measures:</p>
<ul>
	<li>Multiple mutexes are seized atomically. When a task knows in advance the 
	mutexes it needs, it can greedily seize all of them. This operation is 
	atomic which prevent deadlock. Note that greedy seizing mutexes may under 
	certain conditions result in an uneven use of resources;</li>
	<li>Mutexes are ordered and the order is enforced upon seizing. If a task 
	tries to seize a mutex it does not own, when it already owns another mutex with a greater position 
	number, the exception Ownership_Error is propagated. This behavior is 
	independent on whether the offending mutex is actually free to seize;</li>
	<li>Mutexes can be seized when already owned by the task.</li>
</ul>
<p>The package is generic:</p>
<blockquote>
	<p><tt><font color="#0000FF">
	generic<br>
&nbsp;&nbsp; type </font>Mutex_Type<font color="#0000FF">
	is</font> (&lt;&gt;);<font color="#0000FF"><br>
	package </font>Synchronization.Generic_Mutexes_Array<font color="#0000FF">
	is</font> ...</tt></p>
</blockquote>
<p>The formal parameter is the index type of the mutexes array. The package 
defines the following supplementary types:</p>
<blockquote>
	<p><tt><font color="#0000FF">type </font>Mutexes_Set<font color="#0000FF"> 
	is array </font>(Mutex_Type)<font color="#0000FF"> of</font> Boolean;</tt></p>
</blockquote>
<p>This is a set of mutexes. For each mutex event <tt>Mutexes_Set<font color="#0000FF"> </font></tt>contains <font color="#800000"><i>true</i></font> if the 
mutex is in the set. The following set-theoretic operations are defined 
additionally to the standard operations of Boolean arrays in order to ease 
composition of arrays:</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot; 
	(<b>Left</b>, <b>Right</b> : Mutex_Type) <font color="#0000FF">return</font> 
	Mutexes_Set;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot; (<b>Left</b> 
	: Mutexes_Set; <b>Right</b> : Mutex_Type)
	<font color="#0000FF">&nbsp; return</font> Mutexes_Set;<br>
	<font color="#0000FF">function</font> &quot;<font color="#FF0000">or</font>&quot; (<b>Left</b> 
	: Mutex_Type;<b>&nbsp; Right</b> : Mutexes_Set) <font color="#0000FF">
	return</font> Mutexes_Set;</tt></p>
</blockquote>
<p>These functions compose a set when one parameter specifies an event.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">not</font>&quot; 
	(<b>Left</b> : Mutex_Type) <font color="#0000FF">return</font> Mutexes_Set;</tt></p>
</blockquote>
<p>This function creates a complement set of a singleton event.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Mutexes_Array.Mutexes_Array"></a>protected 
	type </font>Mutexes_Array<font color="#0000FF">
	is</font> ...</tt></p>
</blockquote>
<p>Protected objects of this type represent arrays of mutexes. The following operations and entry points 
are defined for <a href="#Synchronization.Generic_Mutexes_Array.Mutexes_Array">
Mutexes_Array</a>:</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Get_Owner (<b>Mutex</b> : 
	Mutex_Type) <font color="#0000FF">return</font> Task_ID;</tt></p>
</blockquote>
<p>This function returns the identification of the task owning <b>Mutex</b>. See 
the standard package Ada.Task_Identification for further information.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Mutexes_Array.Grab"></a>procedure</font> 
	Grab (<b>Mutex</b> : Mutex_Type);<br>
	<font color="#0000FF">procedure</font> Grab (<b>Mutex</b> : Mutex_Type; <b>
	Success</b> : <font color="#0000FF">out</font> Boolean);</tt></p>
</blockquote>
<p>This procedures seize <b>Mutex</b> if it is not already owned by another 
task. <a href="#Synchronization.Generic_Mutexes_Array.Is_Mine">Is_Mine</a> can be used after
<a href="#Synchronization.Generic_Mutexes_Array.Grab">Grab</a> in order to verify if the mutex 
was indeed seized. When the mutex was seized is shall be released later by a 
call to <a href="#Synchronization.Generic_Mutexes_Array.Release">Release</a> or
<a href="#Synchronization.Generic_Mutexes_Array.Release_All">Release_All</a> 
with the same mutex specified. For example:</p>
<blockquote>
	<p><tt>&nbsp;&nbsp; Resource : Mutexes_Array; <font color="#008000">-- Resources<br>
&nbsp;&nbsp; </font>...<br>
	<font color="#0000FF">begin<br>
	</font>&nbsp;&nbsp; ...<br>&nbsp;&nbsp; Resource.Grab (Mutex); <font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Try to seize it without 
		blocking</font><br><font color="#0000FF">&nbsp;&nbsp; if</font> Resource.Is_Mine 
	(Mutex) 
	<font color="#0000FF">then</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
	<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Use the resource safely</font><br>&nbsp;&nbsp;
&nbsp;&nbsp; Resource.Release (Mutex); <font color="#008000">-- Note, it has to be 
		released</font><br><font color="#0000FF">&nbsp;&nbsp; end if</font>;</tt></p>
</blockquote>
<p>The variant with the output parameter <b>Success</b> sets the parameter to <i>
<font color="#800000">true</font></i> if the mutex was seized or to <i>
<font color="#800000">false</font></i> otherwise. When <b>Mutex</b> is to be 
seized and has the position less than one of a mutex already owned by the caller 
task, Ownership_Error is propagated.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Mutexes_Array.Grab_All"></a>procedure</font> 
	Grab_All (<b>Mutexes</b> : 
	Mutexes_Set; <b>Success</b> : <font color="#0000FF">out</font> Boolean);</tt></p>
</blockquote>
<p>This procedures seizes all <b>Mutexes</b>. If at least one mutex from <b>Mutexes
</b>is not already owned by another task the procedure does nothing and <b>
Success</b> is set to <font color="#800000"><i>false</i></font>. When mutexes 
are seized <b>Success</b> is set to <font color="#800000"><i>true</i></font>. 
Each mutex seized by 
<a href="#Synchronization.Generic_Mutexes_Array.Grab_All">Grab_All</a> 
has to be released by a matching call to <a href="#Synchronization.Generic_Mutexes_Array.Release">Release</a> 
or
<a href="#Synchronization.Generic_Mutexes_Array.Release_All">Release_All</a>. When <b>Mutexes</b> contains a mutex to be seized such that its position less 
than one of a mutex already owned by the caller task, yet not appearing in <b>
Mutexes</b>, then Ownership_Error is propagated.&nbsp; In this case the 
operation has no side effect on the mutexes array.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Generic_Mutexes_Array.Is_Mine"></a>function</font> Is_Mine 
	(<b>Mutex</b>&nbsp;&nbsp; : Mutex_Type) <font color="#0000FF">&nbsp;return</font> Boolean;<br>
	<font color="#0000FF">function</font> Is_Mine (<b>Mutexes</b> : Mutexes_Set) <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Mutex</b> is 
owned by the caller. The variant with a set returns <i><font color="#800000">
true</font></i> if all mutexes from the set are owned by the caller.</p>
<blockquote>
	<p><tt><font color="#0000FF">function</font> Is_Owned (<b>Mutex</b> : Mutex_Type) <font color="#0000FF">
	return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#800000">true</font></i> if <b>Mutex</b> is 
owned by a task.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Generic_Mutexes_Array.Release"></a>
	procedure</font> Release (<b>Mutex</b> : Mutex_Type);</tt></p>
</blockquote>
<p>This procedure releases <b>Mutex</b> previously seized by
<a href="#Synchronization.Generic_Mutexes_Array.Grab">Grab</a>, 
<a href="#Synchronization.Generic_Mutexes_Array.Grab_All">Grab_All</a>, 
<a href="#Synchronization.Generic_Mutexes_Array.Seize">Seize</a> or 
<a href="#Synchronization.Generic_Mutexes_Array.Seize_All">Seize_All</a>. For 
each mutex the number of seizures shall match the number of releasing. Ownership_Error is 
propagated when <b>Mutex</b> is not owned by the caller.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Mutexes_Array.Release_All"></a>
	procedure</font> Release_All (<b>Mutexes</b> : Mutexes_Set);</tt></p>
</blockquote>
<p>This procedure releases all mutexes from <b>Mutexes</b> previously seized by
<a href="#Synchronization.Generic_Mutexes_Array.Grab">Grab</a>, 
<a href="#Synchronization.Generic_Mutexes_Array.Grab_All">Grab_All</a>, 
<a href="#Synchronization.Generic_Mutexes_Array.Seize">Seize</a> or 
<a href="#Synchronization.Generic_Mutexes_Array.Seize_All">Seize_All</a>. For 
each mutex the number of seizures shall match the number of releasing. Ownership_Error is 
propagated when at least one mutex is not owned by the caller. The procedure 
might release some of the mutexes before propagating the exception.</p>
<blockquote>
	<p><tt><font color="#0000FF"><a name="Synchronization.Generic_Mutexes_Array.Seize"></a>
	entry</font> Seize (<b>Mutex</b> : Mutex_Type);</tt></p>
</blockquote>
<p>This entry is used to seize <b>Mutex</b>. It blocks until the mutex becomes 
free. It does not block if the mutex is already owned by the caller. Each call 
to <a href="#Synchronization.Generic_Mutexes_Array.Seize">Seize</a> shall be matched by a call 
to <a href="#Synchronization.Generic_Mutexes_Array.Release">Release</a> or
<a href="#Synchronization.Generic_Mutexes_Array.Release_All">Release_All</a> 
with the same mutex specified. When <b>Mutex</b> has the position less than one of a mutex already owned by the caller 
task, Ownership_Error is propagated.</p>
<blockquote>
	<p><tt><font color="#0000FF">
	<a name="Synchronization.Generic_Mutexes_Array.Seize_All"></a>
	entry</font> Seize_All (<b>Mutexes</b> : Mutexes_Set);</tt></p>
</blockquote>
<p>This entry is used to seize all mutexes from <b>Mutex</b>. It blocks until the mutexes become 
available. It does not block if all mutexes are already owned by the caller. For 
each mutex specified in a call 
to <a href="#Synchronization.Generic_Mutexes_Array.Seize_All">Seize_All</a> 
there shall be a matching call&nbsp; 
to <a href="#Synchronization.Generic_Mutexes_Array.Release">Release</a> or
<a href="#Synchronization.Generic_Mutexes_Array.Release_All">Release_All</a>. When <b>Mutexes</b> contains a mutex with the position less 
than one of a mutex already owned by the caller task, yet not appearing in <b>
Mutexes</b>, then Ownership_Error is propagated. In this case the operation has 
no side effect on the mutexes array.</p>
<p>The package also defines two helper types:</p>
<blockquote>
	<p><tt><font color="#0000FF">type</font> Set_Holder<br>
&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Resource</b> : <font color="#0000FF">access</font> 
	Mutexes_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Seize</b>&nbsp;&nbsp;&nbsp; :
	<font color="#0000FF">access</font> Mutexes_Set<br>
&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is new </font>Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>This is a helper type used to ensure that each
<a href="#Synchronization.Generic_Mutexes_Array.Seize_All">Seize_All</a> is matched by a 
<a href="#Synchronization.Generic_Mutexes_Array.Release_All">Release_All</a> 
even if an exception is propagated. It is used as follows:</p>
<blockquote>
	<p><tt>&nbsp;&nbsp; Resources : <font color="#0000FF">aliased</font> Mutexes_Array; 
	<font color="#008000">-- Resources<br>
&nbsp;&nbsp; </font>...<br>
	<font color="#0000FF">begin<br>
	</font>&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; <font color="#0000FF">declare<br>
	</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mutexes : <font color="#0000FF">
	aliased</font> Mutexes_Set := ...; <font color="#008000">-- The resources we 
	need here</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	Lock&nbsp;&nbsp;&nbsp; : Set_Holder (Resource'Access, Mutexes'Access);<font color="#008000"> -- Seize 
	them<br>
	</font>
	<font color="#0000FF">&nbsp;&nbsp; begin</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<font color="#008000">&nbsp; -- 
	Enjoy exclusive access</font><br><font color="#0000FF">&nbsp;&nbsp; end</font>;&nbsp;
	<font color="#008000">&nbsp; -- Release the resources</font></tt></p>
</blockquote>
<blockquote>
	<p><tt><font color="#0000FF">type</font> Singleton_Holder<br>
&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Resource</b> : <font color="#0000FF">access</font> 
	Mutexes_Array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Seize</b>&nbsp;&nbsp;&nbsp; : 
	Mutex_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is new </font>Ada.Finalization.Limited_Controlled
	<font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>This is a helper type used to ensure that each
<a href="#Synchronization.Generic_Mutexes_Array.Seize">Seize</a> is matched by a <a href="#Synchronization.Generic_Mutexes_Array.Release">Release</a>  
even if an exception is propagated. It is used as follows:</p>
<blockquote>
	<p><tt>&nbsp;&nbsp; Resources : <font color="#0000FF">aliased</font> Mutexes_Array; 
	<font color="#008000">-- Resources<br>
&nbsp;&nbsp; </font>...<br>
	<font color="#0000FF">begin<br>
	</font>&nbsp;&nbsp; ...<br>
&nbsp;&nbsp; <font color="#0000FF">declare<br>
	</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	Lock : Singleton_Holder (Resource'Access, Mutex);<font color="#008000"> -- Seize 
	Mutex<br>
	</font>
	<font color="#0000FF">&nbsp;&nbsp; begin</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<font color="#008000">&nbsp; -- 
	Enjoy exclusive access</font><br><font color="#0000FF">&nbsp;&nbsp; end</font>;&nbsp;
	<font color="#008000">&nbsp; -- Release the resources</font></tt></p>
</blockquote>
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD>
<i>It is strongly recommended to use a Holder object in order to access a mutex 
even if that might cause some overhead. The reason is that asynchronous 
transfer of control (Language Reference Manual </i><a href="http://www.adaic.com/standards/05rm/html/RM-9-7-4.html">9.7.4</a>)<i>) 
from a task owning a mutex might leave the mutex seized. A Holder object 
warranties mutex release. In general one should 
avoid asynchronous transfer of control.</i></TD>
  </TR>
</TABLE>
<H4>10.3.3. Sample. Dining philosophers</H4>
<p><a name="Dining_philosophers"></a>The following example illustrates use of mutexes array. It represents a 
solution of the <i>Dining Philosophers</i> problem. The problem is exposed when 
P<sub><i>i</i></sub> processes are competing for R<i><sub>i </sub></i>resources,
<i>i</i>=1..<i>N</i>, accessing more than one resource at a time. Philosophers 
are tasks. Each philosopher spends some random time thinking. Then he enters 
the dining room and takes his seat at the round table. In order to start to eat 
he seizes two forks, one on the left and another on the right of him. A 
philosopher waits for forks to become free if other philosophers use them. He 
puts both forks down and leaves the room when finished. The cycle repeats so 
long the philosopher lives. A deadlock occurs when, all philosophers seize a 
fork on their left. When the cutlery is implemented as an array of mutexes, 
where each fork is a mutex, no deadlock is possible, which solves the problem:</p>
<p>File <i>test_dining_philosophers_forks.ads</i>:
<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> 
Synchronization.Generic_Mutexes_Array;<br>
<br>
<font color="#0000FF">package</font> Test_Dining_Philosophers_Forks
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;type&nbsp;</font>Philosopher&nbsp;<font color="#0000FF">is</font>&nbsp;(Aristotle,&nbsp;Kant,&nbsp;Spinoza,&nbsp;Marx,&nbsp;Russel);<br>
<font color="#0000FF">&nbsp;&nbsp;
package</font> Forks <font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new</font> Synchronization.Generic_Mutexes_Array (Philosopher);<br>
<font color="#0000FF">end</font> Test_Dining_Philosophers_Forks;</tt></TD>
  </TR>
</TABLE>
<p>This package instantiates
<a href="#Synchronization.Generic_Mutexes_Array">Synchronization.Generic_Mutexes_Array</a>, which is necessary to do at the 
library level in Ada 95. In Ada 2005 it can be instantiated in nested scopes. 
The type Philosopher identifies the philosophers as well as the the fork on the 
right of the corresponding philosopher's seat.</p>File 
<i>test_dining_philosophers.adb</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> Ada.Exceptions;
<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use</font> Ada.Exceptions;<br>
<font color="#0000FF">with</font> Ada.Numerics.Float_Random;
<font color="#0000FF">&nbsp;use</font> Ada.Numerics.Float_Random;<br>
<font color="#0000FF">with</font> Ada.Text_IO; <font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use</font> Ada.Text_IO;<br>
<br>
<font color="#0000FF">with</font> Test_Dining_Philosophers_Forks;<br>
<font color="#0000FF">use</font>&nbsp; Test_Dining_Philosophers_Forks;<br>
<br>
<font color="#0000FF">procedure</font> Test_Dining_Philosophers
<font color="#0000FF">is<br>
&nbsp;&nbsp;
use </font>Test_Dining_Philosophers_Forks.Forks;<br>
<br>
&nbsp;&nbsp;&nbsp;Forks&nbsp;:&nbsp;<font color="#0000FF">aliased</font>&nbsp;Mutexes_Array;<font color="#008000">&nbsp;--&nbsp;Forks&nbsp;for&nbsp;hungry&nbsp;philosophers</font><br>
<font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Left_Of -- The fork left to the given one<br>
&nbsp;&nbsp;
--<br>
</font>&nbsp;&nbsp; <font color="#0000FF">function</font> Left_Of (Fork : Philosopher) 
<font color="#0000FF">return</font> Philosopher <font color="#0000FF">is<br>
&nbsp;&nbsp;
begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if </font>Fork = Philosopher'First <font color="#0000FF">then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return</font> Philosopher'Last;<br>
&nbsp;<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;
else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return </font>Philosopher'Pred (Fork);<br>
&nbsp;&nbsp;&nbsp; <font color="#0000FF">&nbsp;
end if</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Left_Of;<br>
<font color="#008000">&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- Person -- A task running some philosopher<br>
&nbsp;&nbsp;
--<br>
&nbsp;&nbsp;
-- ID - The philosopher ID<br>
&nbsp;&nbsp;
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">task type</font> Person (ID : Philosopher);<br>
&nbsp;&nbsp; <font color="#0000FF">task body</font> Person <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Cutlery : <font color="#0000FF">aliased</font> Mutexes_Set := ID 
<font color="#0000FF">or</font> Left_Of (ID);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Dice&nbsp;&nbsp;&nbsp; : Generator;<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Reset (Dice);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">for</font> Life_Cycle
<font color="#0000FF">in</font> <font color="#800000">1</font>..<font color="#800000">50</font>
<font color="#0000FF">loop</font><br>
&nbsp;<font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-- In his life a philosopher eats 50 times<br>
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Put_Line (Philosopher'Image (ID) &amp; &quot;<font color="#FF0000"> is thinking</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">delay</font> Duration (Random (Dice) * 0.100);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Put_Line (Philosopher'Image (ID) &amp; &quot;<font color="#FF0000"> is hungry</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">declare</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Lock : Set_Holder (Forks'Access, Cutlery'Access);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Put_Line (Philosopher'Image (ID) &amp; &quot;<font color="#FF0000"> is eating</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">delay</font> Duration (Random (Dice) *
<font color="#800000">0.100</font>);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Put_Line (Philosopher'Image (ID) &amp; &quot;<font color="#FF0000"> is leaving</font>&quot;);<br>
&nbsp;&nbsp; <font color="#0000FF">exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
when</font> Error: <font color="#0000FF">others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Put_Line<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Philosopher'Image (ID)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&nbsp; &quot; <font color="#FF0000">caused</font> &quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;&nbsp; Exception_Information (Error)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Person;<br>
<br>
&nbsp;&nbsp;
T1 : Person (Aristotle); <font color="#008000">-- Start philosophers</font><br>
&nbsp;&nbsp;
T2 : Person (Kant);<br>
&nbsp;&nbsp;
T3 : Person (Spinoza);<br>
&nbsp;&nbsp;
T4 : Person (Marx);<br>
&nbsp;&nbsp;
T5 : Person (Russel);<br>
<font color="#0000FF">begin<br>
&nbsp;&nbsp;
null</font>; <font color="#008000">-- Nothing to do in the main task, just sit and behold</font><br>
<font color="#0000FF">end</font> Test_Dining_Philosophers;</tt></TD>
  </TR>
</TABLE>
<p>In this implementation a philosopher seizes his forks using
<a href="#Synchronization.Generic_Mutexes_Array.Seize_All">Seize_All</a>. 
Because this is an indivisible operation it cannot deadlock.</p>
<hr>
<p align="right">
  <A name="11"></A><a href="#10.3"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><A
      href="#11.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H2>11. Parsers</H2>
<P><a name="Parsers_etc"></a>Parsers can be used for  syntax analysis of infix expressions,
i.e. ones containing infix 
(dyadic), prefix and postfix operators, brackets, function calls, array indices 
etc. The approach presented does not require any grammar put down to generate scanner and 
analyzer. Nor any code generation steps are required. An object-oriented 
approach is used instead. The lexical procedures are dispatching, so that  implementations may be provided through overriding them. Parsers can be used both for 
immediate one-pass code interpretation and for  parsing tree building. Parser 
automatically detects the expression end allowing its easy integration. Operator 
precedence is expressed in a native way by setting priorities controlling 
association with the operands. Associations with the left  and right side 
operands are controlled independently. Commutative operators and their inverses
can be optimized when necessary. Especial attention is paid to error handling 
allowing generating very precise error messages and source code references. Samples 
from a small console calculator to a complete parsing tree generator for Ada 95
expressions illustrate examples of use.</p>
<P>The parsing method used is an extended
variant of an algorithm of infix to postfix notation conversion. I do not know who was 
its author. Already in 1975 T. Pratt in <i>Programming Languages, design and 
implementation</i> mentioned it as well known. The algorithm makes possible parsing and
interpreting infix expressions in one pass without returns. The following figure 
drafts out the idea and its implementation.</P>
<img border="0" src="lexer.jpg" width="420" height="277" alt="parser"><p>
<u><b>Quick reference</b></u>:</p>
<ul>
<li><a href="#Parsers.Generic_Operation">Operations</a>, the data structures 
used to bind recognized operations with the operands;</li>
<li><a href="#Parsers.Generic_Argument">Arguments</a>, the operation operands;</li>
<li><a href="#Parsers.Generic_Source">Sources</a>, to access 
the source code and maintain scan cursors;</li>
<li><a href="#Parsers.Generic_Token">Tokens</a>, the lexical token 
tables, controlling table driven lexers;</li>
<li><a href="#Parsers.Generic_Lexer">Lexers</a>,  to scan the 
source and call lexical subprograms as source lexemes get recognized.</li>
</ul>
<p align="right">
  <A name="11.1"></A><A href="#11"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></A><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.1. Example first, a small calculator</H3>
<p><a name="console_calculator"></a>In this paragraph I present an implementation of 
a small primitive floating 
point calculator. The calculator supports operations <tt>+</tt>, <tt>-</tt>, <tt>
*</tt>, <tt>/</tt>, <tt>**</tt>, brackets <tt>()</tt> and unary operators <tt>+</tt>,
<tt>-</tt>, <tt>abs</tt>.</p>
File <i>calculator.ads</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> 
  Parsers.String_Source; <font color="#0000FF">&nbsp;use</font> 
  Parsers.String_Source;<br>
<font color="#0000FF">with</font>   Parsers.Generic_Lexer.Blanks;<br>
<font color="#0000FF">with</font>   Parsers.Generic_Token.Segmented_Lexer;<br>
<font color="#0000FF">with</font>   Tables.Names;<br>
<br>
<font color="#0000FF">package</font> Calculator <font color="#0000FF">is</font><br>
<font color="#008000">--<br>
-- Calculate -- A primitive floating-point calculator<br>
--<br>
--&nbsp;&nbsp;&nbsp; Formula - To be evaluated<br>
--<br>
-- Returns :<br>
--<br>
--&nbsp;&nbsp;&nbsp; The result of Formula<br>
--<br>
-- Exceptions :<br>
--<br>
--&nbsp;&nbsp;&nbsp; Syntax_Error&nbsp; - Any syntax error<br>
--&nbsp;&nbsp;&nbsp; Numeric_Error - Any numeric error<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Calculate (Formula : String)
<font color="#0000FF">return</font> Float;<br>
<br>
<font color="#0000FF">private</font><br>
<font color="#008000">--<br>
-- Operations -- All the operations supported<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Operations <font color="#0000FF">
is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Add, Sub, Mul, Div, Pow,&nbsp;&nbsp;&nbsp;
<font color="#008000">-- Infix operators</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Abs_Value, Plus, 
Minus,&nbsp;&nbsp;&nbsp;&nbsp; <font color="#008000">-- Prefix operators</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left_Bracket, 
Right_Bracket <font color="#008000">-- Brackets</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<font color="#"><br>
<font color="#008000">--<br>
-- &quot;and&quot; -- Checks operation associations, always True (Ok)<br>
--</font></font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> &quot;<font color="#FF0000">and</font>&quot; 
(Left, Right : Operations) <font color="#0000FF">return</font> Boolean;<br>
<font color="#008000">--<br>
-- Is_Commutative -- No commutative operations, always False<br>
--</font><br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font>&nbsp;Is_Commutative&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;Operations)&nbsp;<font color="#0000FF">return</font>&nbsp;Boolean;<br>
<font color="#008000">--<br>
-- Is_Inverse -- No commutative operations, always False<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Is_Inverse (Operation : 
Operations) <font color="#0000FF">return</font> Boolean;<br>
<font color="#008000">--<br>
-- Group_Inverse -- No commutative operations, never called<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Group_Inverse (Operation : 
Operations) <font color="#0000FF">return</font> Operations;<br>
<font color="#008000">--<br>
-- Priorities -- The levels of association<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Priorities <font color="#0000FF">
is mod </font><font color="#1100000">10</font>;<br>
<font color="#008000">--<br>
-- Tokens -- The lexical tokens<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Tokens <font color="#0000FF">
is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new</font> Parsers.Generic_Token<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Operation_Type =&gt; 
Operations,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Argument_Type&nbsp; =&gt; Float,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Priority_Type&nbsp; =&gt; Priorities,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sources&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
=&gt; Code<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp; <font color="#0000FF">use</font> Tokens;<br>
<font color="#008000">--<br>
-- Check_Spelling -- Of a name, no checks<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Check_Spelling (Name : 
String);<br>
<font color="#008000">--<br>
-- Check_Matched -- Check if no broken keyword matched<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Check_Matched (Source : 
String; Pointer : Integer)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean;<br>
<font color="#008000">--<br>
-- Token_Tables -- Case-insensitive tables of tokens<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Token_Tables
<font color="#0000FF">is new </font>Tokens.Vocabulary.Names;<br>
<font color="#008000">--<br>
-- The tables of prefix, infix and postfix operations<br>
--</font><br>
&nbsp;&nbsp; Prefixes&nbsp; : <font color="#0000FF">aliased</font> 
  Token_Tables.Dictionary;<br>
&nbsp;&nbsp; Infixes&nbsp;&nbsp; : <font color="#0000FF">aliased</font> 
  Token_Tables.Dictionary;<br>
&nbsp;&nbsp; Postfixes : <font color="#0000FF">aliased</font> 
  Token_Tables.Dictionary;<br>
<font color="#008000">--<br>
-- Lexers -- Table driven lexers<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Lexers <font color="#0000FF">
is new</font>   Tokens.Segmented_Lexer;<br>
<font color="#008000">--<br>
-- Blank_Skipping_Lexers -- Ones that skip blanks<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Blank_Skipping_Lexers
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new</font> 
Lexers.Token_Lexer.Implementation.Blanks (Lexers.Lexer);<br>
<font color="#008000">--<br>
-- Expression -- The lexer using our tables<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Expression <font color="#0000FF">
is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new</font> Blank_Skipping_Lexers.Lexer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Prefixes&nbsp; =&gt;
  Prefixes'Access,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Infixes&nbsp;&nbsp; 
=&gt; Infixes'Access,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Postfixes =&gt; Postfixes'Access<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">with null record</font>;<br>
<font color="#008000">--<br>
-- Call -- Evaluates an operator <br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Call<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Context&nbsp;&nbsp; : <font color="#0000FF">access</font> Expression;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Operation : Tokens.Operation_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Tokens.Arguments.Frame<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">return</font>   Tokens.Argument_Token;<br>
<font color="#008000">--<br>
-- Enclose -- Evaluates an expression in brackets<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Enclose<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Context : <font color="#0000FF">access</font> Expression;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Left&nbsp;&nbsp;&nbsp; : Tokens.Operation_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Right&nbsp;&nbsp; : Tokens.Operation_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
List&nbsp;&nbsp;&nbsp; : Tokens.Arguments.Frame<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">return</font>   Tokens.Argument_Token;<br>
<font color="#008000">--<br>
-- Get_Operand -- Recognizes an operand (float number)<br>
--</font><br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Get_Operand<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Context&nbsp; : <font color="#0000FF">in out</font> Expression;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Code&nbsp;&nbsp;&nbsp;&nbsp; : in out Source;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Argument : <font color="#0000FF">out</font>   Tokens.Argument_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  Got_It&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
<font color="#0000FF">end</font> Calculator;</tt></TD>
  </TR>
</TABLE>
<p>The package Calculator defines the function Calculate that takes a string
argument and returns the result of the expression in the string. In the
private part of the package, first the set of supported operations is defined, that is the 
enumeration type Operations. Then the following functions are defined on Operations 
to be used in generic instantiations:</p>
<ul>
<li>&quot;<font color="#FF0000">and</font>&quot; to figure out whether two operations can 
be associated. In our case it always returns <font color="#1100000"><i>true</i></font>;</li>
<li>Is_Commutative checking whether a commutative operator optimization is 
required. It has little sense to optimize something for an interpreter, so this 
function also returns <i><font color="#1100000">true</font></i>;</li>
<li>Is_Inverse checking whether an operator is an inverse of another commutative 
operator. It is always <font color="#1100000"><i>false</i></font>;</li>
<li>Group_Inverse returning a commutative group inversion operator, this one 
will never be called.</li>
</ul>
<p>Next the package defines the type Priority used for operation association 
levels. That can be any type with &quot;<font color="#FF0000">&lt;</font>&quot; order 
defined. The types Operations and Priority are used to instantiate the package
<a href="#Parsers.Generic_Token">Parsers.Generic_Token</a>. The instance Tokens 
provides base types describing expression lexical tokens. That is the table type 
used to keep the legal names of the operations defined by the type Operations. 
The tables obtained are case sensitive. It is not exactly what is needed, 
because the expression should be case-insensitive. For this reason, the child 
table package <a href="tables.htm#Tables.Names">Tables.Names</a> is 
instantiated. To do this first, there should be defined two additional 
subroutines:</p>
<ul>
<li>Check_Spelling, the procedure checking names placed into a table, it does 
nothing it our case for no checks required;</li>
<li>Check_Matches, the function checking that no broken name matched. Because 
the expression may contain operators named as <tt>abs</tt>. It is necessary to 
prevent it from being matched in the cases like <tt>abs1.2</tt>. For this 
Check_Matched observes the last character of a matched name and the character 
following it, to ensure that they are not both alphanumeric.</li>
</ul>
<p> <a href="tables.htm#Tables.Names">Tables.Names</a> is instantiated as:</p>
<blockquote>
<p><tt> <font color="#0000FF">package</font> Token_Tables
<font color="#0000FF">is new </font>Tokens.Vocabulary.Names;</tt></p>
</blockquote>
<p>Next three tables from obtained Token_Tables are declared. They are:</p>
<ul>
<li>The table of prefix operations. It will contain tokens describing unary 
operators <tt>+</tt>, <tt>-</tt>, <tt>abs</tt> and the bracket <tt>(</tt>;</li>
<li>The table of infix operations to contain <tt>+</tt>, <tt>-</tt>, <tt>*</tt>,
<tt>/</tt>, <tt>**</tt>;</li>
<li>The table of postfix operation to contain the right bracket <tt>)</tt>.</li>
</ul>
<p>The final step is to create table-driven lexers using the tables we have. For 
this the package <a href="#Parsers.Generic_Token.Segmented_Lexer">
Parsers.Generic_Token.Segmented_Lexer</a> is instantiated under the name Lexers. 
The instance Lexers has the type Lexer which can be used to parse expressions. 
This type is abstract because it has some abstract operations to implement. The 
first operation is <a href="#Parsers.Generic_Lexer.Get_Blank">Get_Blank</a> used 
to skip blanks in the expression. The package
<a href="#Parsers.Generic_Lexer.Blanks">Parsers.Generic_Lexer.Blanks</a> 
provides an implementation that skips spaces, tabs etc. To use it
<a href="#Parsers.Generic_Lexer.Blanks">Parsers.Generic_Lexer.Blanks</a> is 
instantiated as Blank_Skipping_Lexers. The obtained type Lexer is then extended 
to set the type discriminants to the corresponding tables. The resulting type 
Expression is still abstract, but has only three things to define:</p>
<ul>
<li><a href="#Parsers.Generic_Lexer.Call">Call</a>, the function to evaluate operators;</li>
<li><a href="#Parsers.Generic_Lexer.Enclose">Enclose</a>, the function to evaluate brackets;</li>
<li><a href="#Parsers.Generic_Lexer.Get_Operand">Get_Operand</a>, the procedure to get an operand from source. For the calculator 
it is a number.</li>
</ul>
<p>The implementation of the package is straightforward:</p>
File <i>calculator.adb</i>:<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> 
  Ada.Characters.Handling;&nbsp; <font color="#0000FF">use</font> 
  Ada.Characters.Handling;<br>
<font color="#0000FF">with</font>  Ada.Exceptions;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font>  Ada.Exceptions;<br>
<font color="#0000FF">with</font>  Ada.IO_Exceptions;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font>  Ada.IO_Exceptions;<br>
<font color="#0000FF">with</font>  Strings_Edit;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font>  Strings_Edit;<br>
<font color="#0000FF">with</font>  Strings_Edit.Floats;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font>  Strings_Edit.Floats;<br>
<br>
<font color="#0000FF">with</font>  Ada.Numerics.Elementary_Functions;<br>
<font color="#0000FF">use</font>&nbsp; Ada.Numerics.Elementary_Functions;<br>
<br>
<font color="#0000FF">package body</font> Calculator <font color="#0000FF">is</font>
<br>
<br>
<font color="#0000FF">&nbsp;&nbsp; function</font> &quot;<font color="#FF0000">and</font>&quot; 
(Left, Right : Operations) <font color="#0000FF">return</font> Boolean<font color="#0000FF"> 
is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return </font>True;<br>
<font color="#0000FF">&nbsp;&nbsp; end</font> &quot;<font color="#FF0000">and</font>&quot;;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font>&nbsp;Is_Commutative&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;Operations)&nbsp;<font color="#0000FF">return</font>&nbsp;Boolean&nbsp;<font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return </font>False;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font>  Is_Commutative;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Is_Inverse (Operation : 
Operations) <font color="#0000FF">return</font> Boolean <font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return </font>False;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font>  Is_Inverse;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Group_Inverse (Operation : 
Operations) <font color="#0000FF">return</font> Operations<font color="#0000FF"> 
is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</font> Minus;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font>  Group_Inverse;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Check_Spelling (Name : 
String)<font color="#0000FF"> is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Check_Spelling;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Check_Matched (Source : 
String; Pointer : Integer)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <font color="#0000FF">not</font> 
Is_Alphanumeric (Source (Pointer))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">or else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not </font>Is_Alphanumeric 
(Source (Pointer - 1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Check_Matched;</tt></TD>
  </TR>
</TABLE>
<p>The function Check_Matched receives the string being parsed and the index of 
the first character following the matched name (lexeme). It checks that no 
broken names be matched.</p>
File <i>calculator.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">function</font>
Call<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Context&nbsp;&nbsp; : <font color="#0000FF">access</font> Expression;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Operation : Tokens.Operation_Token;<brnbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Tokens.Arguments.Frame<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">return</font> Tokens.Argument_Token <font color="#0000FF">
is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result : Float;<br>
&nbsp;&nbsp; <font color="#0000FF">begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case</font> Operation.Operation
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when</font> Abs_Value =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := abs 
List (List'First).Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Add =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := 
List (List'First).Value + List (List'Last).Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Sub =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := 
List (List'First).Value - List (List'Last).Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Mul =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := 
List (List'First).Value * List (List'Last).Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Div =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := 
List (List'First).Value / List (List'Last).Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Pow =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result :=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp&nbsp;(log&nbsp;(List&nbsp;(List'First).Value)&nbsp;*&nbsp;List&nbsp;(List'Last).Value);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Plus =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := 
List (List'First).Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Minus =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := 
-List (List'First).Value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when 
others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">raise</font> Program_Error;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end case</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Result'Valid
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> 
(Result, Operation.Location &amp; Link (List));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Raise_Exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Numeric_Error'Identity,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; &quot;<font color="#FF0000">Numeric 
error in </font>&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; 
Operations'Image (Operation.Operation)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; &quot;<font color="#FF0000"> 
at </font>&quot; &amp; Image (Operation.Location)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when </font>Program_Error =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">raise</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Raise_Exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Constraint_Error'Identity,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; &quot;<font color="#FF0000">Numeric 
error in </font>&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; 
Operations'Image (Operation.Operation)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; &quot;<font color="#FF0000"> 
at </font>&quot; &amp; Image (Operation.Location)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; );<br>
&nbsp;&nbsp; <font color="#0000FF">end </font>Call;</tt></TD>
  </TR>
</TABLE>
<p><a href="#Parsers.Generic_Lexer.Call">Call</a> implements operators. The parameter Operation identifies what for 
operator. The parameter List contains the operands. Each operand has value (the 
Value field) and location in the source (the Location field). When evaluated 
operator also returns a value and location. The new location is evaluated from 
the locations of the operands (function <a href="#Parsers.Generic_Token.Link">
Link</a>) and the operator.</p>
File <i>calculator.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">function</font> 
Enclose<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Context : <font color="#0000FF">access</font> Expression;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Tokens.Operation_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Right&nbsp;&nbsp; : Tokens.Operation_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
List&nbsp;&nbsp;&nbsp; : Tokens.Arguments.Frame<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">return</font> Tokens.Argument_Token <font color="#0000FF">
is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; List (List'First).Value,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left.Location &amp; Right.Location<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Enclose;</tt></TD>
  </TR>
</TABLE>
<p><a href="#Parsers.Generic_Lexer.Enclose">Enclose</a> implements brackets. Order brackets <tt>()</tt> just return the operand.</p>
File <i>calculator.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; <font color="#0000FF">procedure</font> 
Get_Operand<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Context&nbsp; : <font color="#0000FF">in out</font> Expression;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Code&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Source;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Argument : <font color="#0000FF">out</font> Tokens.Argument_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Got_It&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp; : String
<font color="#0000FF">renames</font> Get_Line (Code);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer : Integer := Get_Pointer (Code);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp; : Float;<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get (Line, Pointer, Value);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set_Pointer (Code, Pointer);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Argument := (Value, Link (Code));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Got_It&nbsp;&nbsp; := True;<br>
&nbsp;&nbsp; <font color="#0000FF">exception</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> End_Error =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Got_It := False;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Constraint_Error =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set_Pointer (Code, Pointer);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Raise_Exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Numeric_Error'Identity,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;<font color="#FF0000">Too</font>&nbsp;<font color="#FF0000">large</font>&nbsp;<font color="#FF0000">number</font>&nbsp;<font color="#FF0000">at</font>&nbsp;&quot;&nbsp;&amp;&nbsp;Image&nbsp;(Link&nbsp;(Code))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ); <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Data_Error =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set_Pointer (Code, Pointer);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Raise_Exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Parsers.Syntax_Error'Identity,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;<font color="#FF0000">Wrong 
number at </font>&quot; &amp; Image (Link (Code))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ); <br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Get_Operand;</tt></TD>
  </TR>
</TABLE>
<p>The procedure <a href="#Parsers.Generic_Lexer.Get_Operand">Get_Operand</a> gets the operand in the source. It uses
<a href="#Parsers.Generic_Source.Get_Line">Get_Line</a> to access the current 
source line. <a href="#Parsers.Generic_Source.Get_Pointer">Get_Pointer</a> 
returns where it should start. The procedure Get from
<a href="strings_edit.htm#Float_Edit">Strings_Edit.Floats</a> is 
used to get a floating-point number. The
<a href="#Parsers.Generic_Source.Set_Pointer">Set_Pointer</a> advances the 
source cursor to the position next to the number. The function
<a href="#Parsers.Generic_Source.Link">Link</a> is used to get the location of 
the number matched.</p>
File <i>calculator.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#C0D8D6"><tt>&nbsp;&nbsp; Reckoner : Expression;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font>&nbsp;Calculate&nbsp;(Formula&nbsp;:&nbsp;String)&nbsp;<font color="#0000FF">return</font>&nbsp;Float&nbsp;<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Copy&nbsp;&nbsp; : <font color="#0000FF">aliased</font> 
String := Formula;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp; : Source (Copy'Access);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result : Tokens.Argument_Token;<br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lexers.Parse (Reckoner, Code, Result);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Get_Pointer 
(Code) &lt;= Copy'Last <font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Raise_Exception<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Parsers.Syntax_Error'Identity,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; &quot;<font color="#FF0000">Unrecognized 
'</font>&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; Copy 
(Get_Pointer (Code)..Copy'Last)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&nbsp; &quot;<font color="#FF0000">'</font>&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Result.Value;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Calculate;</tt></TD>
  </TR>
</TABLE>
<p>The procedure Calculate implements the calculator. It just calls
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> to interpret Formula and the 
checks that the whole string was matched.</p>
File <i>calculator.adb (continuation)</i>:
<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;Add_Operator&nbsp;(Prefixes,&nbsp;&quot;<font color="#FF0000">abs</font>&quot;,&nbsp;Abs_Value,&nbsp;<font color="#1100000">8</font>,&nbsp;<font color="#1100000">7</font>);<br>
&nbsp;&nbsp; Add_Operator (Prefixes, &quot;<font color="#FF0000">+</font>&quot;,&nbsp;&nbsp; 
Plus,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#1100000">8</font>,
<font color="#1100000">7</font>);<br>
&nbsp;&nbsp; Add_Operator (Prefixes, &quot;<font color="#FF0000">-</font>&quot;,&nbsp;&nbsp; 
Minus,&nbsp;&nbsp;&nbsp;&nbsp; <font color="#1100000">8</font>,
<font color="#1100000">7</font>);<br>
&nbsp;&nbsp; Add_Bracket&nbsp; (Prefixes, &quot;<font color="#FF0000">(</font>&quot;,&nbsp;&nbsp; 
Left_Bracket);<br>
<br>
&nbsp;&nbsp; Add_Operator (Infixes, &quot;<font color="#FF0000">+</font>&quot;,&nbsp; Add,
<font color="#1100000">1</font>, <font color="#1100000">2</font>);<br>
&nbsp;&nbsp; Add_Operator (Infixes, &quot;<font color="#FF0000">-</font>&quot;,&nbsp; Sub,
<font color="#1100000">1</font>, <font color="#1100000">3</font>);<br>
&nbsp;&nbsp; Add_Operator (Infixes, &quot;<font color="#FF0000">*</font>&quot;,&nbsp; Mul,
<font color="#1100000">3</font>, <font color="#1100000">4</font>);<br>
&nbsp;&nbsp; Add_Operator (Infixes, &quot;<font color="#FF0000">/</font>&quot;,&nbsp; Div,
<font color="#1100000">3</font>, <font color="#1100000">4</font>);<br>
&nbsp;&nbsp; Add_Operator (Infixes, &quot;<font color="#FF0000">**</font>&quot;, Pow,
<font color="#1100000">9</font>, <font color="#1100000">5</font>);<br>
<br>
&nbsp;&nbsp; Add_Bracket&nbsp; (Postfixes, &quot;<font color="#FF0000">)</font>&quot;, 
Right_Bracket); <br>
<font color="#0000FF">end</font> Calculator;</tt></TD>
  </TR>
</TABLE>
<p>Finally upon package elaboration the tables have to be filled in.
<a href="#Parsers.Generic_Token.Add_Operator">Add_Operator</a> is used to add an 
operator. The operator priorities are chosen to satisfy usual association rules.
<a href="#Parsers.Generic_Token.Add_Bracket">Add_Bracket</a> is used to add 
brackets.</p>
<p>A program using the calculator may look as follows:</p>
File <i>console_calculator.adb</i>:
<TABLE border="1" cellpadding="15" cellspacing="0"><TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> Ada.Exceptions;
<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use</font> Ada.Exceptions;<br>
<font color="#0000FF">with</font> Ada.Text_IO; <font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
use</font> Ada.Text_IO;<br>
<font color="#0000FF">with</font> Strings_Edit.Floats;&nbsp;
<font color="#0000FF">use</font> Strings_Edit.Floats;<br>
<font color="#0000FF">with</font> Calculator;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">use</font> Calculator;<br>
<font color="#0000FF">with</font> Parsers;<br>
<br>
<font color="#0000FF">procedure</font> Console_Calculator <font color="#0000FF">
is</font> <br>
&nbsp;&nbsp; Text : String (<font color="#1100000">1</font>..<font color="#1100000">120</font>);<br>
&nbsp;&nbsp; Last : Integer;<br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp; Put_Line (&quot;<font color="#FF0000">Enter an expression to calculate 
and hit &lt;enter&gt;</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;Put_Line&nbsp;(&quot;<font color="#FF0000">The</font>&nbsp;<font color="#FF0000">operations</font>&nbsp;<font color="#FF0000">supported</font>&nbsp;<font color="#FF0000">are</font>&nbsp;<font color="#FF0000">+,</font>&nbsp;<font color="#FF0000">-,</font>&nbsp;<font color="#FF0000">/,</font>&nbsp;<font color="#FF0000">*,</font>&nbsp;<font color="#FF0000">**,</font>&nbsp;<font color="#FF0000">abs,</font>&nbsp;<font color="#FF0000">()</font>&quot;);<br>
&nbsp;&nbsp; Put_Line (&quot;<font color="#FF0000">&nbsp;&nbsp; (to exit enter an 
empty string)</font>&quot;);<br>
&nbsp;&nbsp; <font color="#0000FF">loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (&quot;<font color="#FF0000">&gt;</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get_Line (Text, Last);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">exit when </font>Last &lt; 
Text'First;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put_Line (&quot;<font color="#FF0000">=</font>&quot; 
&amp; Image (Calculate (Text (<font color="#1100000">1</font>..Last))));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">exception</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Error : Numeric_Error | Parsers.Syntax_Error =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put_Line (Exception_Message 
(Error));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end loop</font>; <br>
<font color="#0000FF">exception</font><br>
&nbsp;&nbsp; <font color="#0000FF">when</font> Error : <font color="#0000FF">
others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put (&quot;<font color="#FF0000">Error :</font>&quot;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Put_Line (Exception_Information (Error));<br>
<font color="#0000FF">end</font> Console_Calculator;</tt></TD>
  </TR>
</TABLE>
<p align="right">
  <A name="11.2"></A><a href="#11.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.3"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.2. Basic considerations</H3>
<p>An expression is a sequence of symbols involving operations applied to
operands. In programming languages expression is a formula used to compute a 
value. In most general way any expression has the following syntax:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td><tt>&lt;expression&gt;</tt></td>
<td>&nbsp;</td>
<td><tt>::=</tt></td>
<td>&nbsp;</td>
<td><tt>&lt;<font color="#008000">prefix</font>&gt;</tt></td>
<td>&nbsp;</td>
<td><tt>&lt;operand&gt;</tt></td>
<td>&nbsp;</td>
<td><tt>&lt;<font color="#000080">postfix</font>&gt;</tt></td>
<td>&nbsp;</td>
<td><tt>[</tt></td>
<td>&nbsp;</td>
<td><tt>&lt;<font color="#1100000">infix</font>&gt;</tt></td>
<td>&nbsp;</td>
<td><tt>&lt;expression&gt;</tt></td>
<td>&nbsp;</td>
<td><tt>]</tt></td>
</tr>
</table>
</blockquote>
<p>Here <font color="#008000"> <tt>&lt;prefix&gt;</tt></font> denotes any list of prefix operations,
<font color="#000080"> <tt>&lt;postfix&gt;</tt></font>
does any list of postfix operations, <font color="#1100000"> <tt>&lt;infix&gt;</tt></font> is always exactly one 
infix operation.</p>
<blockquote>
<p>For example in the following C++ expression: </p>
<blockquote>
<p><tt><font color="#008000">!</font> f <font color="#1100000">(</font> 3 
<font color="#1100000">+</font> x<font color="#000080">++&nbsp;)</font></tt></p>
</blockquote>
<p>Operands here are <tt>f</tt>,  <tt>3</tt> and  <tt>x</tt>. Prefix operation 
is <tt><font color="#008000">!</font></tt> (logical not). Postfix operations are
<font color="#000080"> <tt>++</tt></font> 
(post-increment) and right bracket <font color="#000080"><tt>)</tt></font>. Infix operations 
are the operator <font color="#1100000"> <tt>
+</tt></font> and the left bracket <font color="#1100000"><tt>(</tt></font>.</p>
</blockquote>
<p>The above syntax defines three kinds of operations depending of the context 
they may appear. We will use different colors to highlight the operation context.</p>
<ul>
<li><i><font color="#008000">Prefix operations</font></i> appear before an 
operand. There could be any number of prefix operations before an operand in the 
<i>prefix</i> context;</li>
<li><i><font color="#000080">Postfix operations</font></i> appear after an operand. There could be any number of 
postfix operations in a <i>postfix</i> context;</li>
<li><i><font color="#1100000">Infix operations</font></i> separate operands surrounded by prefix and postfix 
operations. In the <i>infix</i> context there can be only one infix operation.</li>
</ul>
<H4>11.2.1. Types of lexical tokens</H4>
<p><a name="lexical_token_classes"></a>The operations are further subdivided into operators, delimiters 
(like
brackets), commas and ligatures, and reserved keywords used as modifiers.</p>
<p><u><b><a name="operator"></a>Operators</b></u>:</p>
<ul>
<li><font color="#008000"><i>Unary prefix operators</i></font> appear before the argument. Examples are
    unary plus and minus (<tt>+</tt>, 
    <tt>-</tt>), pre-increment and decrement in C++, <font color="#0000FF"><tt>abs</tt></font> 
in Ada. There can be any number of prefix operators applied to an argument. The 
order the prefix operators are applied to the argument is determined by the 
operators' priorities.</li>
<li><font color="#1100000"><i>Binary infix operators</i></font> bind two arguments. An infix operator is 
placed between the arguments.
    <tt>+</tt>, 
    <tt>-</tt>, 
    <tt>*</tt>, 
    <tt>/</tt> are examples of infix operators. The order of the infix operators 
cannot be changed, but their evaluation order can and depends on their 
priorities. Infix operators can be implied. For example, the multiplication
  operator is implied in mathematical formulas.</li>
<li><font color="#000080"><i>Unary postfix operators</i></font> appear after the argument. Post-increment and decrement in C++ 
are postfix operators. There can be any number of postfix operators applied to 
an argument. The order the operators are applied in to the argument is determined 
by their priorities.</li>
</ul>
<p><u><b><a name="brackets"></a>Brackets, commas, ligatures</b></u>:</p>
<ul>
<li><font color="#008000"><i>Left order and aggregate brackets</i></font> occur in the prefix context, i.e. before 
the first 
argument. The last argument is bound by a right bracket. In Ada for both order 
and aggregate brackets <tt>(</tt> is used. 
In C++ it is <tt>(</tt> and <tt>{</tt>. There could be any number of left 
brackets before an argument. The order of left brackets cannot be changed.</li>
<li><font color="#1100000"><i>Left index brackets</i> </font>occur in the infix context, i.e. they 
separate arguments as infix operator do. The index brackets are ones used to 
specify the actual parameter list of a function or the array indices, like <tt>(</tt> 
does in <tt>f(2,5)</tt>. The order of left brackets cannot be changed. In C++ 
there are two of them <tt>(</tt> and <tt>[</tt>, used for function calls and 
array indices correspondingly.</li>
<li><font color="#1100000"><i>Commas</i></font> are used in the infix context to separate arguments 
in a list put in brackets. 
Commas cannot appear outside brackets. The order of commas cannot be changed. 
(In C++ the comma operator is not a comma, but a binary infix operator.)</li>
<li><font color="#1100000"><i><a name="semicolons"></a>Semicolons</i></font> are 
much like commas. They are used in the infix context to separate <a href="#sublists">sublists</a> of 
arguments. The order of semicolons cannot be changed. Grouping arguments in 
sublists depends on the semicolons' priorities. In Ada <font color="#0000FF">
<tt>with</tt></font> in an extension aggregate is a semicolon.</li>
<li><font color="#1100000"><i><a name="ligature"></a>Ligatures</i></font> are commas acting as infix operators. They appear in the 
infix context and only in brackets. The arguments separated by ligatures are 
bound into one argument. The order of ligatures cannot be changed. An example of a ligature is <tt>=&gt;</tt> 
used for named associations in Ada, like in</li>
</ul>
<blockquote>
<blockquote>
<p> <tt>Foo <font color="#1100000">(</font>Left<font color="#1100000">=&gt;</font>X, Right<font color="#1100000">=&gt;</font>Y<font color="#000080">)</font>;</tt></p>
</blockquote>
</blockquote>
<ul>
<li><font color="#000080"><i>Right brackets</i></font> follow the last argument in the brackets. There 
could be any number of right brackets after an argument. The order of the 
brackets cannot be changed.</li>
</ul>
<p><a name="sublists"></a>Argument sublists are quite common in mathematical notation. 
For example a hypergeometric function:</p>
<blockquote>
<p> <tt>F <font color="#1100000">(</font><i>x<sub>1</sub></i><font color="#1100000">,</font>
<i>x<sub>2</sub></i><font color="#1100000">,</font> <i>x<sub>3</sub></i><font color="#1100000">;</font>
<i>y<sub>1</sub></i><font color="#1100000">,</font> <i>y<sub>2</sub></i><font color="#1100000">,</font>
<i>y<sub>3</sub></i> <font color="#1100000">|</font> <i>z</i><font color="#000080">)</font></tt></p>
</blockquote>
<p>Here <tt><font color="#1100000">;</font></tt> and <tt><font color="#1100000">|</font></tt> 
are semicolons separating sublists of the argument list.&nbsp;If <tt>
<font color="#1100000">;</font></tt> has higher priority than <tt>
<font color="#1100000">|</font></tt> the above means:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td align="center" colspan="16"> <tt><font color="#1100000">(</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px; border-right-style:solid; border-right-width:1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px; border-left-style:solid; border-left-width:1px">&nbsp;</td>
<td align="center" style="border-right-style: none; border-right-width: medium; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: none; border-left-width: medium; border-right-style:none; border-right-width:medium; border-top-style:solid; border-top-width:1px; border-bottom-style:none; border-bottom-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: none; border-left-width: medium; border-right-style:none; border-right-width:medium; border-top-style:solid; border-top-width:1px; border-bottom-style:none; border-bottom-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: none; border-left-width: medium; border-right-style:none; border-right-width:medium; border-top-style:solid; border-top-width:1px; border-bottom-style:none; border-bottom-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: none; border-left-width: medium; border-right-style:none; border-right-width:medium; border-top-style:solid; border-top-width:1px; border-bottom-style:none; border-bottom-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: none; border-left-width: medium; border-top-style:solid; border-top-width:1px; border-bottom-style:none; border-bottom-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="3">&nbsp;</td>
<td align="center" style="border-bottom-style: solid; border-bottom-width: 1px" colspan="6"> <tt>
<font color="#1100000">(|</font></tt></td>
<td align="center" style="border-style:none; border-width:medium; "> &nbsp;</td>
<td align="center" style="border-style:none; border-width:medium; "> &nbsp;</td>
<td align="center" style="border-style:none; border-width:medium; "> &nbsp;</td>
<td align="center" style="border-style:none; border-width:medium; " colspan="2"> 
<tt><font color="#1100000">|</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: none; border-top-width: medium">&nbsp;</td>
<td align="center" style="border-top-style: none; border-top-width: medium">&nbsp;</td>
<td align="center" style="border-top-style: none; border-top-width: medium">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: none; border-top-width: medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="6"> <font color="#1100000"> <tt>(;</tt></font></td>
<td style="border-right-style: none; border-right-width: medium" align="center" colspan="6"> 
<font color="#1100000"> <tt>;|</tt></font></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: solid; border-right-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px" align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;F&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;<i>x<sub>1</sub></i>&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;<i>x<sub>2</sub></i>&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;<i>x<sub>3</sub></i>&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;<i>y<sub>1</sub></i><sub>&nbsp;</sub></tt></td>
<td colspan="2" align="center"> <tt>&nbsp;<i>y<sub>2</sub></i>&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;<i>y<sub>3</sub></i>&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;<i>z</i>&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p> Argument lists and sublists are always bound by two operations, the left and
the right one. There are three kinds of semicolons:</p>
<ul>
<li>A <i>separator</i> closes the sublist on the left and starts another one. These are <tt><font color="#1100000">;</font></tt> and <tt><font color="#1100000">|</font></tt> 
in the example above;</li>
<li>A <i>close-semicolon </i>closes the sublist on the left;</li>
<li>An <i>open-semicolon</i> starts a new sublist. An example of this semicolon is Ada's
<font color="#0000FF"><tt>with</tt></font>:</li>
</ul>
<blockquote>
<p> <tt>(A, B <font color="#0000FF">with</font> C, D <font color="#0000FF">with</font> 
E)</tt></p>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td align="center" colspan="10"> <tt><font color="#008000">(</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2">&nbsp;</td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="6"> <tt> <font color="#1100000">
with</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt> <font color="#1100000">with</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" colspan="2"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td align="center" colspan="2"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td align="center" colspan="2"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
<td align="center" colspan="2"> <tt>&nbsp;&nbsp;D&nbsp;&nbsp;</tt></td>
<td align="center" colspan="2"> <tt>&nbsp;&nbsp;E&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p><u><b><a name="modifier"></a>Modifiers</b></u>:</p>
<ul>
<li><i>Operation modifiers</i> are used to change the operation they follow. Operation modifiers can be 
used to implement multi-words operations, such as <font color="#0000FF"><tt>and 
then</tt></font> in Ada. First <font color="#0000FF"><tt>and </tt></font>is 
recognized, when <font color="#0000FF"><tt>then</tt></font> follows, it changes <font color="#0000FF"><tt>
and</tt></font> to <font color="#0000FF"><tt>and then</tt></font>.</li>
<li><i>Argument modifiers</i> are used to modify the operand they follow. For example, in Ada, <tt>
<font color="#0000FF">record</font></tt> can be an argument modifier used 
to recognize <tt><font color="#0000FF">null record</font></tt> in an expression.</li>
</ul>
<p>The modifiers can be used to stop expression parsing at reserved 
keywords. Thus in Ada the same <font color="#0000FF"><tt>then</tt></font> when does not 
follow <tt><font color="#0000FF">and</font></tt>, manifests the 
expression end in an if-statement.</p>
<H4>11.2.2. Priorities and association</H4>
<p><a name="operation_association"></a>Association of the operators with the operands is usually controlled by the
precedence level (the operator priority) and special rules for the case when the 
priorities are same. Here I propose a simpler and more general model. All 
operators have two priorities to control association with the operands on either 
side. So the left priority controls left-side association. Both unary and binary operators have the priorities. 
Binary infix operators normally have left and right priorities near to each 
other. To have left to right operand association the left priority should be 
slightly lower than the right one. The following example illustrates the process 
of operand association for <tt>A<b><font color="#1100000">+</font></b>B<b><font color="#1100000">*</font></b>C<b><font color="#1100000">+</font></b>D<b><font color="#1100000">+</font></b>E</tt>:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td> <tt>A <b><font color="#1100000">+</font></b> B <b><font color="#1100000">*</font></b>
C <b><font color="#1100000">+</font></b> D <b><font color="#1100000">+</font></b>
E =</tt></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" colspan="2"><font color="#1100000"> <tt><b>+</b></tt></font></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span>
B <span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span>
C <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
D <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
E =</tt></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
B</tt>&#8594;<tt><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span> 
C <span style="background-color: #C0D8D6"><sub>
1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
D <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
E =</tt></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" colspan="2"><font color="#1100000"> <tt><b>+</b></tt></font></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
B</tt>&#8594;<tt><b><font color="#1100000">*</font></b></tt>&#8592;<tt>C <span style="background-color: #C0D8D6"><sub>
1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
D <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
E =</tt></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt>A</tt>&#8594;<tt><b><font color="#1100000">+</font></b></tt>&#8592;<tt>(B<b><font color="#1100000">*</font></b>C) <span style="background-color: #C0D8D6"><sub>
1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
D <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
E =</tt></td>
<td align="center" colspan="6"><font color="#1100000"> <tt><b>+</b></tt></font></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt>(A<b><font color="#1100000">+</font></b>(B<b><font color="#1100000">*</font></b>C))</tt>&#8594;<tt><b><font color="#1100000">+</font></b></tt>&#8592;<tt>D <span style="background-color: #C0D8D6"><sub>
1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
E =</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>((A<b><font color="#1100000">+</font></b>(B<b><font color="#1100000">*</font></b>C))<b><font color="#1100000">+</font></b>D)</tt>&#8594;<tt><b><font color="#1100000">+</font></b></tt>&#8592;<tt>E 
=</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="4">
<font color="#1100000"><b> <tt>*</tt></b></font></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>((A<b><font color="#1100000">+</font></b>(B<b><font color="#1100000">*</font></b>C))<b><font color="#1100000">+</font></b>D)<b><font color="#1100000">+</font></b>E</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium">&nbsp;</td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;D&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;E&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>Normally, the left priority of a prefix operator is higher
than the right one and both are higher than the priorities of the infix 
operators so:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td> <tt>A <b><font color="#1100000">-</font></b> <font color="#008000">++</font> <font color="#008000">-- </font>B <b><font color="#1100000">+</font></b>
C =</tt></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-bottom-style: solid; border-bottom-width: 1px">&nbsp;</td>
<td align="center" style="border-bottom-style: solid; border-bottom-width: 1px"> <tt><font color="#1100000">+</font></tt></td>
<td align="center" style="border-bottom-style: solid; border-bottom-width: 1px">&nbsp;</td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> <span style="background-color: #C0D8D6"><sub>
10</sub></span><font color="#008000">++</font><span style="background-color: #C0D8D6"><sub>9</sub></span> <span style="background-color: #C0D8D6"><sub>
10</sub></span><font color="#008000">--</font><span style="background-color: #C0D8D6"><sub>9</sub></span> 
B <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span>
C =</tt></td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span></tt>&#8594;<tt><font color="#008000">++</font><span style="background-color: #C0D8D6"><sub>9</sub></span></tt>&#8594;<tt><font color="#008000">--</font></tt>&#8592;<tt>B <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center" colspan="4"> <tt><b><font color="#1100000">-</font></b></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span></tt>&#8594;<tt><font color="#008000">++</font></tt>&#8592;<tt>(<font color="#008000">--</font>B) <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>A</tt>&#8594;<tt><b><font color="#1100000">-</font></b></tt>&#8592;<tt>(<font color="#008000">++</font>(<font color="#008000">--</font>B)) <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt><font color="#008000">++</font></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>(A<b><font color="#1100000">-</font></b>(<font color="#008000">++</font>(<font color="#008000">--</font>B)))</tt>&#8594;<tt><b><font color="#1100000">+</font></b></tt>&#8592;<tt>C 
=</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt><font color="#008000">--</font></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>(A<b><font color="#1100000">-</font></b>(<font color="#008000">++</font>(<font color="#008000">--</font>B)))<b><font color="#1100000">+</font></b>C 
=</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> &nbsp;</td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>There
might be exceptions from this rule as in the case of the
exponentiation operator, where it is useful to have the left priority of
<tt>**</tt> higher than the right priority of the unary minus and the right
priority of 
<tt>**</tt> lower than left priority of the unary
minus so, that <tt>-A**-B</tt> become:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td> <tt> <font color="#008000">-</font> A <b><font color="#1100000">**</font></b> <font color="#008000">-</font>
B =</tt></td>
<td align="center" colspan="4"> <tt><font color="#008000">-</font></tt></td>
</tr>
<tr>
<td> <tt> <span style="background-color: #C0D8D6"><sub>
8</sub></span><font color="#008000">-</font><span style="background-color: #C0D8D6"><sub>7</sub></span> A <span style="background-color: #C0D8D6"><sub>
9</sub></span><b><font color="#1100000">**</font></b><span style="background-color: #C0D8D6"><sub>5</sub></span> <span style="background-color: #C0D8D6"><sub>
8</sub></span><font color="#008000">-</font><span style="background-color: #C0D8D6"><sub>7</sub></span> 
B =</tt></td>
<td align="center" colspan="4"> <tt><b><font color="#1100000">**</font></b></tt></td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt> <span style="background-color: #C0D8D6"><sub>
8</sub></span><font color="#008000">-</font><span style="background-color: #C0D8D6"><sub>7</sub></span> A</tt>&#8594;<tt><b><font color="#1100000">**</font></b><span style="background-color: #C0D8D6"><sub>5</sub></span></tt>&#8594;<tt><font color="#008000">-</font></tt>&#8594;<tt>B 
=</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt> <span style="background-color: #C0D8D6"><sub>
8</sub></span><font color="#008000">-</font><span style="background-color: #C0D8D6"><sub>7</sub></span> A</tt>&#8594;<tt><b><font color="#1100000">**</font></b></tt>&#8592;<tt>(<font color="#008000">-</font>B)=</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt><font color="#008000">-</font></tt></td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt> <font color="#008000">-</font></tt>&#8592;<tt>(A<b><font color="#1100000">**</font></b>(<font color="#008000">-</font>B))=</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt> <font color="#008000">-</font>(A<b><font color="#1100000">**</font></b>(<font color="#008000">-</font>B))</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>The priorities of the postfix operators should be selected so that the left 
priority be very high, but lower than the right priorities of the
prefix operators. The right priority should be slightly lower than
the left one, but higher than the right priorities of the infix
operators. Under these conditions:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td> <tt>A <b><font color="#1100000">-</font></b> <font color="#008000">++</font> 
B <font color="#000080">++</font> <font color="#000080">--</font> <b><font color="#1100000">-</font></b> 
C =</tt></td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-bottom-style: solid; border-bottom-width: 1px" colspan="3"> <tt><font color="#1100000">
-</font></tt></td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> <span style="background-color: #C0D8D6"><sub>
10</sub></span><font color="#008000">++</font><span style="background-color: #C0D8D6"><sub>9</sub></span> 
B <span style="background-color: #C0D8D6"><sub>
7</sub></span><font color="#000080">++</font><span style="background-color: #C0D8D6"><sub>8</sub></span> <span style="background-color: #C0D8D6"><sub>
7</sub></span><font color="#000080">--</font><span style="background-color: #C0D8D6"><sub>8</sub></span> <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span></tt>&#8594;<tt><font color="#008000">++</font></tt>&#8592;<tt>B <span style="background-color: #C0D8D6"><sub>
7</sub></span><font color="#000080">++</font><span style="background-color: #C0D8D6"><sub>8</sub></span> <span style="background-color: #C0D8D6"><sub>
7</sub></span><font color="#000080">--</font><span style="background-color: #C0D8D6"><sub>8</sub></span> <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center" colspan="4"> <tt><font color="#1100000">-</font></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
(<font color="#008000">++</font>B)</tt>&#8594;<tt><font color="#000080">++</font></tt>&#8592;<tt><span style="background-color: #C0D8D6"><sub>7</sub></span><font color="#000080">--</font><span style="background-color: #C0D8D6"><sub>8</sub></span> <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>A <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
((<font color="#008000">++</font>B)<font color="#000080">++</font>)</tt>&#8594;<tt><font color="#000080">--</font></tt>&#8592;<tt><span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt><font color="#000080">--</font></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>A</tt>&#8594;<tt><b><font color="#1100000">-</font></b>((<font color="#008000">++</font>B)<font color="#000080">++</font>)<font color="#000080">--</font>) <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">-</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt><font color="#000080">++</font></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>(A<b><font color="#1100000">-</font></b>((<font color="#008000">++</font>B)<font color="#000080">++</font>)<font color="#000080">--</font>))</tt>&#8594;<tt><b><font color="#1100000">-</font></b></tt>&#8592;<tt>C 
=</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt><font color="#008000">++</font></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt>(A<b><font color="#1100000">-</font></b>((<font color="#008000">++</font>B)<font color="#000080">++</font>)<font color="#000080">--</font>))<b><font color="#1100000">-</font></b>C</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> &nbsp;</td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>The order of evaluation of the unary operations can be changed by setting 
appropriate priorities. In extreme cases it could involve infix operators as 
well:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td> <tt>A <b><font color="#1100000">*</font></b> <font color="#008000">?</font> 
B <font color="#000080">@</font> <b><font color="#1100000">*</font></b> 
C =</tt></td>
<td align="center" style="border-right-style: none; border-right-width: medium" colspan="6"> <tt><font color="#000080">@</font></tt></td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span> <span style="background-color: #C0D8D6"><sub>
1</sub></span><font color="#008000">?</font><span style="background-color: #C0D8D6"><sub>2</sub></span> 
B <span style="background-color: #C0D8D6"><sub>
2</sub></span><font color="#000080">@</font><span style="background-color: #C0D8D6"><sub>1</sub></span> <span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: none; border-right-width: medium" colspan="6"> <tt><b><font color="#1100000">*</font></b></tt></td>
</tr>
<tr>
<td> <tt>A <span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span></tt>&#8592;<tt><span style="background-color: #C0D8D6"><sub>1</sub></span><font color="#008000">?</font><span style="background-color: #C0D8D6"><sub>2</sub></span> 
B <span style="background-color: #C0D8D6"><sub>
2</sub></span><font color="#000080">@</font><span style="background-color: #C0D8D6"><sub>1</sub></span> <span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: none; border-right-width: medium"> &nbsp;</td>
<td align="center"> &nbsp;</td>
<td align="center" style="border-right-style: none; border-right-width: medium; border-left-style:solid; border-left-width:1px; border-top-style:solid; border-top-width:1px"> &nbsp;</td>
<td align="center" style="border-right-style: none; border-right-width: medium; border-top-style:solid; border-top-width:1px"> &nbsp;</td>
<td align="center" style="border-top-style:solid; border-top-width:1px"> &nbsp;</td>
<td align="center" style="border-right-style: none; border-right-width: medium; border-left-style:solid; border-left-width:1px"> &nbsp;</td>
</tr>
<tr>
<td> <tt><font color="#008000">?</font><span style="background-color: #C0D8D6"><sub>2</sub></span> A</tt>&#8594;<tt><b><font color="#1100000">*</font></b></tt>&#8592;<tt>B <span style="background-color: #C0D8D6"><sub>
2</sub></span><font color="#000080">@</font><span style="background-color: #C0D8D6"><sub>1</sub></span> <span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: none; border-right-width: medium"> &nbsp;</td>
<td align="center" style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium" colspan="2"> <tt><font color="#008000">?</font></tt></td>
<td align="center" style="border-top-style: none; border-top-width: medium; border-left-style:none; border-left-width:medium"> &nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: none; border-top-width: medium"> &nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px"> &nbsp;</td>
</tr>
<tr>
<td> <tt><font color="#008000">?</font></tt>&#8592;<tt>(A<b><font color="#1100000">*</font></b>B) <span style="background-color: #C0D8D6"><sub>
2</sub></span><font color="#000080">@</font><span style="background-color: #C0D8D6"><sub>1</sub></span> <span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: none; border-right-width: medium" colspan="4"> <tt><b><font color="#1100000">*</font></b></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px"> &nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px"> &nbsp;</td>
</tr>
<tr>
<td> <tt>(<font color="#008000">?</font>(A<b><font color="#1100000">*</font></b>B)) <span style="background-color: #C0D8D6"><sub>
2</sub></span><font color="#000080">@</font><span style="background-color: #C0D8D6"><sub>1</sub></span></tt>&#8594;<tt><span style="background-color: #C0D8D6"><sub>3</sub></span><b><font color="#1100000">*</font></b><span style="background-color: #C0D8D6"><sub>4</sub></span> 
C =</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px"> &nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px"> &nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px"> &nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px"> &nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px"> &nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px"> &nbsp;</td>
</tr>
<tr>
<td> <tt>(<font color="#008000">?</font>(A<b><font color="#1100000">*</font></b>B))</tt>&#8594;<tt><b><font color="#1100000">*</font></b></tt>&#8592;<tt>C <span style="background-color: #C0D8D6"><sub>2</sub></span><font color="#000080">@</font> 
=</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
</tr>
<tr>
<td> <tt>((<font color="#008000">?</font>(A<b><font color="#1100000">*</font></b>B))<b><font color="#1100000">*</font></b>C)</tt>&#8594;<tt><font color="#000080">@</font> 
=</tt></td>
<td colspan="2" align="center"> &nbsp;</td>
<td colspan="2" align="center"> &nbsp;</td>
<td colspan="2" align="center"> &nbsp;</td>
</tr>
<tr>
<td> <tt>((<font color="#008000">?</font>(A<b><font color="#1100000">*</font></b>B))<b><font color="#1100000">*</font></b>C)<font color="#000080">@</font></tt></td>
<td colspan="2" align="center"> &nbsp;</td>
<td colspan="2" align="center"> &nbsp;</td>
<td colspan="2" align="center"> &nbsp;</td>
</tr>
</table>
</blockquote>
<p><a name="left_bracket_priority"></a>Association of a left index or function
call bracket with the operand on the left is 
controlled by the left priority of the bracket. This priority is usually high 
 
because otherwise:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td> <tt> A <b><font color="#1100000">**</font></b> B (C, D + E) =</tt></td>
<td align="center" colspan="10"> <tt> <font color="#1100000">(</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td> <tt> A <span style="background-color: #C0D8D6"><sub>
9</sub></span><b><font color="#1100000">**</font></b><span style="background-color: #C0D8D6"><sub>5</sub></span> 
B <sub><span style="background-color: #C0D8D6">4</span></sub><font color="#1100000">(
</font>C<font color="#1100000">,</font> D <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
E<font color="#000080">)</font> =</tt></td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td> <tt> A</tt>&#8594;<tt><b><font color="#1100000">**</font></b></tt>&#8592;<tt>B <sub><span style="background-color: #C0D8D6">4</span></sub><font color="#1100000">(
</font>C<font color="#1100000">,</font> D <span style="background-color: #C0D8D6"><sub>1</sub></span><b><font color="#1100000">+</font></b><span style="background-color: #C0D8D6"><sub>2</sub></span> 
E<font color="#000080">)</font> =</tt></td>
<td colspan="4" align="center"> <tt> <b><font color="#1100000">**</font></b></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="4"> <tt> <b><font color="#1100000">+</font></b></tt></td>
</tr>
<tr>
<td style="border-right-style: none; border-right-width: medium"> <tt> (A<b><font color="#1100000">**</font></b>B)</tt>&#8594;<tt><font color="#1100000">(
</font>C<font color="#1100000">,</font> D</tt>&#8594;<tt><b><font color="#1100000">+</font></b></tt>&#8592;<tt>E<font color="#000080">)</font> 
=</tt></td>
<td style="border-right-style: solid; border-right-width: 1px; border-left-style:none; border-left-width:medium" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px" align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td> <tt> <font color="#000080">()(</font>A<b><font color="#1100000">**</font></b>B<font color="#1100000">,
</font>C<font color="#1100000">,</font> D<b><font color="#1100000">+</font></b>E)</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;D&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;E&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>Here <tt>&quot;()&quot;</tt> denotes indexing or function call. Normally most 
of infix operators have lower priorities, with exception of component extraction 
which usually has a higher priority. Left index brackets have no right priority.</p>
<p>The aggregate, order 
left brackets, commas and ligatures have no association priorities. The 
following table summarizes the rules of choosing the operation priorities:</p>
<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Operation</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Left</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Right</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Comment</b></font></TD>
  </TR>
  <TR>
    <TD valign="top">Unary prefix operators</TD>
    <TD valign="top">High</TD>
    <TD valign="top">High, but slightly lower than the left one</TD>
    <TD valign="top">Right to left evaluation order. Normally unary operators 
    have higher priorities than binary operators. However, in Ada we find that:<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
    <tr>
    <td align="center" colspan="4">
    <p align="left"> <tt>
    <font color="#008000">-</font>A<font color="#1100000">*</font>B =</tt></p></td>
    </tr>
    <tr>
    <td align="center" colspan="4"> <tt>
    <font color="#008000">-</font></tt></td>
    </tr>
    <tr>
    <td align="center" colspan="4"> <tt>
    <font color="#1100000">*</font></tt></td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    </tr>
    <tr>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
    </tr>
    </table>
    </TD>
  </TR>
  <TR>
    <TD valign="top">Unary postfix operators</TD>
    <TD valign="top">High</TD>
    <TD valign="top">Higher than the left one</TD>
    <TD valign="top">Usually both priorities are lower than ones of the prefix 
    operators, so that prefix ones would be evaluated first, and the postfix 
    ones next and left to right</TD>
  </TR>
  <tr>
    <TD valign="top">Normal infix operators</TD>
    <TD valign="top">Moderate</TD>
    <TD valign="top">Slightly lower than the left one</TD>
    <TD valign="top">Left to right evaluation order. Operators like component 
    extraction&nbsp; <tt>A<font color="#1100000">.</font>B</tt> should have both priorities very 
    high.</TD>
  </tr>
  <TR>
    <TD valign="top">Assignment operator</TD>
    <TD valign="top">High</TD>
    <TD valign="top">Low</TD>
    <TD valign="top">This ensures that<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
    <tr>
    <td align="center" colspan="8">
    <p align="left"> <tt>A<font color="#1100000"> + </font>B<font color="#1100000">
    := </font>C<font color="#1100000"> + </font>D =</tt></p></td>
    </tr>
    <tr>
    <td align="center" colspan="8"> <tt><font color="#1100000">+</font></tt></td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" colspan="6"> <tt><font color="#1100000">:=</font></tt></td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center">&nbsp;</td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td colspan="4" align="center"> <tt><font color="#1100000">+</font></tt></td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td style="border-right-style: solid; border-right-width: 1px" align="center">&nbsp;</td>
    <td style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
    <td style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
    <td style="border-left-style: solid; border-left-width: 1px" align="center">&nbsp;</td>
    </tr>
    <tr>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;D&nbsp;&nbsp;</tt></td>
    </tr>
    </table>
    </TD>
  </TR>
  <TR>
    <TD valign="top">Left index brackets</TD>
    <TD valign="top">Very high</TD>
    <TD valign="top" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD valign="top">Array indices and function usually have higher priority 
    than most of infix operations, but not all of them::
    <table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
    <tr>
    <td align="center" colspan="6">
    <p align="left">
    <tt>A<font color="#1100000">+</font>B<font color="#1100000">(</font>C<font color="#000080">) </font>=</tt></p></td>
    <td align="center" colspan="6">
    <p align="left">
    <tt>A<font color="#1100000">.</font>B<font color="#1100000">(</font>C<font color="#000080">) </font>=</tt></p></td>
    </tr>
    <tr>
    <td align="center" colspan="6"> <tt><font color="#1100000">+</font></tt></td>
    <td align="center" colspan="6"> <tt>()</tt></td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" colspan="4"> <tt>()</tt></td>
    <td align="center" colspan="4"> <tt><font color="#1100000">.</font></tt></td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    </tr>
    <tr>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    <td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
    <td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
    </tr>
    <tr>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
    <td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
    <td align="center" colspan="2"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
    <td align="center" colspan="2"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
    <td align="center" colspan="2"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
    </tr>
    </table>
    </TD>
  </TR>
  </TABLE>
<p>Another case of association is represented by sublist semicolons. The
semicolons also have an
association priority with the arguments in the list. Although semicolon
association priorities do not interact with the operators' ones:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td align="center" colspan="16">
<p align="left"><tt><font color="#008000">(</font>A <b><font color="#1100000">+</font></b> 
B <font color="#1100000">:</font> C<font color="#1100000">,</font> D
<font color="#1100000">|</font> E <font color="#1100000">:</font> F<font color="#1100000">,</font> 
G <font color="#1100000">|</font> H<font color="#000080">)</font></tt></p></td>
</tr>
<tr>
<td align="center" colspan="16"><tt><font color="#008000">(</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" colspan="8"><tt><font color="#008000">(</font><font color="#1100000">|</font></tt></td>
<td align="center" colspan="6"><tt><font color="#1100000">||</font></tt></td>
<td align="center" colspan="2"><tt><font color="#1100000">|</font><font color="#000080">)</font></tt></td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" colspan="4"><tt><font color="#008000">(</font><font color="#1100000">:</font></tt></td>
<td align="center" colspan="4"><tt><font color="#1100000">:|</font></tt></td>
<td align="center" colspan="2"><tt><font color="#1100000">|:</font></tt></td>
<td align="center" colspan="4"><tt><font color="#1100000">:|</font></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td colspan="4" align="center"><tt><b><font color="#1100000">+</font></b></tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td style="border-right-style: solid; border-right-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px" align="center">&nbsp;</td>
<td style="border-left-style: solid; border-left-width: 1px" align="center">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-right-style: none; border-right-width: medium">&nbsp;</td>
<td align="center" style="border-left-style: none; border-left-width: medium">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;D&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;E&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;F&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;G&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"><tt>&nbsp;&nbsp;H&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>In this example the colon separator has higher priority than one of bar
separator.</p>
<H4>11.2.3. Association checks</H4>
<p><a name="association_checks"></a>Sometimes operations cannot be arbitrarily
associated with each other. There are three cases where operation compatibility 
can be checked:</p>
<ul>
<li><a href="#operator">Operators</a>. Two operators cannot be associated when 
they may not share an operand. Usually it is the binary infix operators for 
which one may wish to limit association. An example can be found in Ada, where:</li>
</ul>
<blockquote>
<blockquote>
<p> <tt>A&nbsp;<font color="#0000FF">and</font>&nbsp;B&nbsp;<font color="#0000FF">or</font>&nbsp;C</tt></p>
</blockquote>
<p>is illegal. Here the infix operators &quot;<font color="#FF0000">and</font>&quot; and &quot;<font color="#FF0000">or</font>&quot; 
are incompatible. Order brackets should be used to make it legal. For instance:</p>
<blockquote>
<p> <tt>A&nbsp;<font color="#0000FF">and</font>&nbsp;(B&nbsp;<font color="#0000FF">or</font>&nbsp;C)</tt></p>
</blockquote>
<p>Unary operators also can be checked. In Ada both</p>
<blockquote>
<p> <tt><font color="#008000">+</font> <font color="#008000">-</font> A&nbsp; </tt>
and&nbsp;&nbsp; <tt>A<font color="#1100000">**</font><font color="#008000">+</font>2</tt></p>
</blockquote>
<p>are illegal (see 
<a href="http://www.adaic.com/standards/05rm/html/RM-4-4.html"> <i>Ada Language Reference 
Manual</i> 4.4</a>). When 
association checks are used for unary operators it is important to define 
association incompatibility relation transitive. I.e. if an operator <i>x</i> 
cannot be associated with operator <i>y</i>, but can be with <i>z</i>, then <i>y
</i>cannot be associated with <i>z</i>. Otherwise some association error may 
remain undetected.</p>
</blockquote>
<ul>
<li><a href="#brackets">Brackets, commas and ligatures</a>. Commas, ligatures 
and right brackets can be checked against the corresponding left brackets. For 
instance in</li>
</ul>
<blockquote>
<blockquote>
<p><tt>( A&nbsp;+&nbsp;B&nbsp;]</tt></p>
</blockquote>
<p>The right square bracket is incompatible with the left round bracket.</p>
</blockquote>
<ul>
<li>Mixed case. The left index bracket can be checked both against an operator 
on the left and the commas, ligatures and right brackets on the right.</li>
</ul>
<H4>11.2.3. Commutative operators</H4>
<p><a name="commutative_operators"></a>A commutative  operation is one which result does not depend on the
argument order. For example, numeric addition is commutative because <i>a</i>+<i>b</i>&nbsp;=&nbsp;<i>b</i>+<i>a</i>. 
When&nbsp;the result does not depend on the operands order, an expression can be optimized by choosing a preferable order among many possible. The preferable order, could be one evaluating the constants and invariants first. For example: 1+<i>a</i>+2&nbsp;=&nbsp;(1+2)+<i>a</i>&nbsp;=&nbsp;3+<i>a</i>. Optimization may 
also take advantage of an inverse operation of a commutative group: 1+<i>a</i>-4&nbsp;=&nbsp;1+<i>a</i>+(-4)&nbsp;=&nbsp;(1+(-4))+<i>a</i>&nbsp;=&nbsp;-3+<i>a</i>. 
Here addition is the operation of a commutative group. Subtraction is the 
inverse operation. Unary minus is defined as 0-<i>x</i>, where 0 is the group's 
zero element. To support optimizations of this kind the commutative operations 
and their inverses can be parsed so that multiple appearances of binary 
operators will be replaced by an equivalent multiple-operand operation. For 
example:</p>
<blockquote>
<p> <tt>A <b><font color="#1100000">+</font></b> B <font color="#1100000"><b>-</b></font> 
C <b><font color="#1100000">+</font></b> D <b><font color="#1100000">+</font></b> 
E</tt></p>
</blockquote>
<p>can result in:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td align="center" colspan="10"> <tt>+</tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" colspan="2"> <tt>-</tt></td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;D&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;E&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>Similarly:</p>
<blockquote>
<p> <tt>A <font color="#1100000"><b>-</b></font> B <font color="#1100000"><b>-</b></font> 
C <b><font color="#1100000">+</font></b> D <b><font color="#1100000">+</font></b> 
E</tt></p>
</blockquote>
<p>can be parsed as:</p>
<blockquote>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse">
<tr>
<td align="center" colspan="10"> <tt>-</tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px; border-top-style: solid; border-top-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: none; border-right-width: medium" colspan="2"> <tt>
-</tt></td>
<td align="center" style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium" colspan="2"> <tt>
-</tt></td>
</tr>
<tr>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
<td align="center" style="border-right-style: solid; border-right-width: 1px">&nbsp;</td>
<td align="center" style="border-left-style: solid; border-left-width: 1px">&nbsp;</td>
</tr>
<tr>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;A&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;B&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;C&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;D&nbsp;&nbsp;</tt></td>
<td colspan="2" align="center"> <tt>&nbsp;&nbsp;E&nbsp;&nbsp;</tt></td>
</tr>
</table>
</blockquote>
<p>Note that the original order can be always restored when the inverse unary 
operation is prevented from being specified explicitly. For this one can have two different unary minus 
operations one for explicit use and another used implicitly as the group
inverse. So that later if a semantic analysis of the operands involved showed that they
in fact were not 
commutative, then the corresponding optimizations could be omitted and the 
original order applied.</p>
<p>The following table summarizes the most frequently used commutative groups:</p>
<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Operators</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Group's operation</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Its inverse</b></font></TD>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Inverse unary operation</b></font></TD>
  </TR>
  <TR>
    <TD valign="top"><tt>+</tt>, <tt>-</tt></TD>
    <TD valign="top">addition</TD>
    <TD valign="top">subtraction</TD>
    <TD valign="top">Unary minus: 0-<i>x</i></TD>
  </TR>
  <TR>
    <TD valign="top"><tt>*</tt>, <tt>/</tt></TD>
    <TD valign="top">multiplication</TD>
    <TD valign="top">division</TD>
    <TD valign="top">1/<i>x</i></TD>
  </TR>
  </TABLE>
<p>The  operations that are commutative, but usually have no inverse are: logical 
and bitwise <i>and</i>, <i>or</i>, <i>xor</i>; numerical <i>min</i>, <i>max</i>. 
Alternatives separator <tt>|</tt> in Ada is also commutative.</p>
<p>Commutative optimization can be also useful for non-commutative operations. 
Often it makes sense to make the component selector <tt>.</tt> commutative to 
simplify parsing tree.</p>
<p align="right">
  <A name="11.3"></A><a href="#11.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.4"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.3. The base package</H3>
<p><a name="Parsers"></a>The package <a href="#Parsers">Parsers</a> is the 
parent package of all others. It defines:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Token_Class <font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp; </font>&nbsp;(&nbsp; Operator,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bracket,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comma,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ligature,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Index,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sublist_Close,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sublist_Separator,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sublist_Open,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Postmodifier,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Premodifier<br>
&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This type enumerates the <a href="#lexical_token_classes">classes</a> of
operations. It also defines the subtypes of the sublist separators (<a href="#semicolons">semicolons</a>) 
and modifiers:</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Semicolon_Class"></a>subtype</font> 
Semicolon_Class <font color="#0000FF">is</font> Token_Class<br>
&nbsp;&nbsp; <font color="#0000FF">range</font> Sublist_Close..Sublist_Open;<br>
<font color="#0000FF">subtype</font> Modifier_Class <font color="#0000FF">is</font> 
Token_Class<br>
&nbsp;&nbsp; <font color="#0000FF">range</font> Postmodifier..Premodifier;</tt></p>
</blockquote>
<p>Further the package defines the exceptions:</p>
<blockquote>
<p><tt>Syntax_Error : <font color="#0000FF">exception</font>;</tt></p>
</blockquote>
<p>The exception Syntax_Error is used by lexers. Usually it has information attached containing 
the error description and location.</p>
<blockquote>
<p><tt>Association_Error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
<font color="#0000FF">exception</font>;<br>
Missing_Right_Bracket&nbsp;&nbsp;&nbsp; : <font color="#0000FF">exception</font>;<br>
Unexpected_Comma&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
<font color="#0000FF">exception</font>;<br>
Unexpected_Right_Bracket : <font color="#0000FF">exception</font>;<br>
Wrong_Comma_Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
<font color="#0000FF">exception</font>;<br>
Wrong_Right_Bracket_Type : <font color="#0000FF">exception</font>;</tt></p>
</blockquote>
<p>These exceptions are used when dealing with <a href="#operation_stack">
operation stacks</a>. They are low-level ones, and normally never propagate 
out of a lexer unhandled.</p>
<p align="right">
  <A name="11.4"></A><a href="#11.3"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.5"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.4. Sources</H3>
<p><a name="Parsers.Generic_Source"></a>The parser can scan different kinds of
sources from plain strings to text files. The generic package
<a href="#Parsers.Generic_Source">Parsers.Generic_Source</a> specifies the 
abstract interface of a source:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Source_Type (&lt;&gt;)<font color="#0000FF"> is limited 
private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Line_Ptr_Type<font color="#0000FF"> 
is access constant </font>String;<br>
&nbsp;&nbsp; <font color="#0000FF">type </font>Location_Type<font color="#0000FF"> 
is private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> Get_Line (Code : 
Source_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> String
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure </font>Get_Line<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(&nbsp; Code&nbsp;&nbsp;&nbsp; : Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Line&nbsp;&nbsp;&nbsp; : <font color="#0000FF">out</font> Line_Ptr_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Pointer : <font color="#0000FF">out</font> Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Last&nbsp;&nbsp;&nbsp; : <font color="#0000FF">out</font> Integer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
)&nbsp; <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Get_Pointer (Code : 
Source_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Integer<font color="#0000FF"> 
is </font>&lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Get_Backup_Pointer (Code 
: Source_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Integer
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Image (Link : 
Location_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> String<font color="#0000FF"> 
is </font>&lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Link (Code : Source_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Location_Type
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure </font>Next_Line (Code :
<font color="#0000FF">in out </font>Source_Type)<font color="#0000FF"> is </font>
&lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure </font>Reset_Pointer (Code :
<font color="#0000FF">in out </font>Source_Type)<font color="#0000FF"> is </font>
&lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure </font>Set_Pointer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(&nbsp; Code&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out </font>Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Pointer : Integer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
)&nbsp; <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>&quot;<font color="#FF0000">&amp;</font>&quot; 
(Left, Right : Location_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Location_Type<font color="#0000FF"> 
is </font>&lt;&gt;;<br>
<font color="#0000FF">package</font> Parsers.Generic_Source
<font color="#0000FF">is<br>
end</font> Parsers.Generic_Source;</tt></p>
</blockquote>
<p>The package does not provide any operations of its own. It only defines the interface of a source. Here</p>
<blockquote>
<p><tt><font color="#0000FF">type </font>Source_Type (&lt;&gt;)<font color="#0000FF"> 
is limited private</font>;</tt></p>
</blockquote>
<p>is the type of a source. An implementation should maintain two source cursors 
(pointers). As the parser consumes the source text it advances the cursors. The 
source slice between two cursors specifies the last token recognized by the 
parser. It may return back to the token beginning. However if the source 
contains several lines or records, then cursors always point to  same line, 
so a return may never require the previous line:</p>
<blockquote>
<p>
<img border="0" src="source.jpg" alt="source parsing" width="428" height="217"></p>
<p><tt><font color="#0000FF">type </font>Line_Ptr_Type<font color="#0000FF"> is 
private</font>;</tt></p>
</blockquote>
<p>This pointer type is used to reference source line body in the procedure
<a href="#Parsers.Generic_Source.Get_Line-procedure">Get_Line</a>.</p>
<blockquote>
<p><tt><font color="#0000FF">type </font>Location_Type<font color="#0000FF"> is 
private</font>;</tt></p>
</blockquote>
<p>Objects of this type are used to identify a contiguous slice of the source. 
This can be any part of the source, if multiple lines are supported, then 
Location_Type should allow to specify several source lines.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> End_Of (<b>Code</b> : Source_Type) <font color="#0000FF">
return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#1100000">true</font></i> at the source 
end.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Source.Get_Line"></a>function</font> Get_Line (<b>Code</b> : Source_Type) <font color="#0000FF">
return</font> String;</tt></p>
</blockquote>
<p>This function gets the current source code line. It remains valid until the 
first call to <a href="#Parsers.Generic_Source.Next_Line">Next_Line</a>. 
End_Error is propagated when end source was reached either because the source is 
empty or because of a call to <a href="#Parsers.Generic_Source.Next_Line">
Next_Line</a> before.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Source.Get_Line-procedure"></a>procedure </font>
Get_Line<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp; <b>
Code</b>&nbsp;&nbsp;&nbsp; : Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Line</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">out</font> Line_Ptr_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Pointer</b> : <font color="#0000FF">out</font> Integer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Last</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">out</font> Integer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);</tt></p>
</blockquote>
<p>This procedure is combines <a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a> and <a href="#Parsers.Generic_Source.Get_Pointer">
Get_Pointer</a>. It returns a pointer to the buffer containing the current 
source code line (the parameter <b>Line</b>), the current cursor position (the 
parameter <b>Pointer</b>) in that buffer and the position of the last character 
in the buffer (the parameter <b>Last</b>). It might be more efficient than the 
function <a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a> if the compiler optimization is not great and it might happen that 
renaming of a slice returned from <a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a> could result in copying its content. The pointer returned may refer 
to a string longer that the current line. Usually the implementation of a source 
would hold an internal string buffer. <b>Line</b> might point to it, so that <b>
Line</b> (<b>Pointer</b>..<b>Last</b>) would be the rest of the current line, 
yet to parse. The implementation shall ensure equivalence of the value returned 
in the <b>Pointer</b> parameter to the one returned by the function <a href="#Parsers.Generic_Source.Get_Pointer">
Get_Pointer</a> and accepted by <a href="#Parsers.Generic_Source.Set_Pointer">
Set_Pointer</a>. Usually it is achieved when the function
<a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a> returns a slice of the buffer returned by the procedure
<a href="#Parsers.Generic_Source.Get_Line-procedure">Get_Line</a>. Note that in 
Ada string slicing does not shift the lower bound of the result to 1. Thus it is 
safe to use plain slicing there.&nbsp; Like the function, the procedure
<a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a> raises End_Error at the source end or else when the source is 
empty.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Source.Get_Pointer"></a>function </font>Get_Pointer (<b>Code</b> : Source_Type) <font color="#0000FF">
return</font> Integer;</tt></p>
</blockquote>
<p>This function gets the current cursor. The result is an index in the current 
line which would be returned by <a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a>. It is in the range Line'First..Line'Last+1 provided that Line is 
the value returned by <a href="#Parsers.Generic_Source.Get_Line">Get_Line</a>. 
The character pointed by <a href="#Parsers.Generic_Source.Get_Pointer">
Get_Pointer</a> is the first one to parse. The characters before are the 
recognized ones. At the source end, when <a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a> would raise End_Error, 1 is the result.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Source.Get_Backup_Pointer"></a>function </font>Get_Backup_Pointer (<b>Code</b> : Source_Type)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Integer;</tt></p>
</blockquote>
<p>This function returns the saved cursor. It is one to which Restore_Pointer 
would return. At the source end, when <a href="#Parsers.Generic_Source.Get_Line">
Get_Line</a> would raise End_Error, 1 is the result. The slice of the current line starting from the result of
<a href="#Parsers.Generic_Source.Get_Backup_Pointer">Get_Backup_Pointer</a> and 
ending in the character before one pointed by
<a href="#Parsers.Generic_Source.Get_Pointer">Get_Pointer</a> is usually the 
last recognized token.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Source.Next_Line"></a>procedure </font>Next_Line (<b>Code</b> : <font color="#0000FF">in out </font>
Source_Type);</tt></p>
</blockquote>
<p>This procedure advances to the next source line. After a successful 
completion <a href="#Parsers.Generic_Source.Get_Line">Get_Line</a> can be used 
to access the newly read source line. Both cursors are set to
<a href="#Parsers.Generic_Source.Get_Line">Get_Line</a>'First. So when the line 
is not empty <a href="#Parsers.Generic_Source.Get_Pointer">Get_Pointer</a> will 
return the index of the first character in the new source line. Data_Error is 
propagated on I/O errors. End_Error is propagated when the source end is 
reached.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Source.Reset_Pointer"></a>procedure </font>Reset_Pointer (<b>Code</b> :
<font color="#0000FF">in out </font>Source_Type);</tt></p>
</blockquote>
<p>This procedure moves the second cursor back to the first cursor, so that
<a href="#Parsers.Generic_Source.Get_Pointer">Get_Pointer</a> would return the 
value of <a href="#Parsers.Generic_Source.Get_Backup_Pointer">Get_Backup_Pointer</a>. 
The depth of the &quot;unget&quot; need not to be deeper than 1. Consequent calls to 
Reset_Pointer may have no effect. It is also not required to implement return to 
the previous line.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Source.Set_Pointer"></a>procedure </font>Set_Pointer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out </font>Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Pointer</b> : Integer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is used to move the cursors forward. The parameter <b>Pointer</b>
is the new position of the second cursor, it should be in the range between the position returned by
<a href="#Parsers.Generic_Source.Get_Pointer">Get_Pointer</a> and the position 
following the last character of the current line, i.e.
<a href="#Parsers.Generic_Source.Get_Line">Get_Line</a> (<b>Code</b>)'Last + 1. 
At the source end when
<a href="#Parsers.Generic_Source.Get_Line">Get_Line</a> would raise End_Error, 
the only valid value to set is 1. Otherwise Layout_Error is propagated. The
first cursor is moved to the old position of the second one. The following small example illustrates an 
implementation of a routine to skip spaces in the source line:</p>
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">procedure</font> Skip (Code :
<font color="#0000FF">in out </font>Source_Type) <font color="#0000FF">is</font><br>
&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp; : String <font color="#0000FF">renames</font> 
Get_Line (Code);<br>
&nbsp;&nbsp; Pointer : Integer := Get_Pointer (Code);<br>
<font color="#0000FF">begin<br>
</font>&nbsp;&nbsp;&nbsp;<font color="#0000FF">while</font>&nbsp;Pointer&nbsp;&lt;=&nbsp;Line'Last&nbsp;<font color="#0000FF">and</font>&nbsp;<font color="#0000FF">then</font>&nbsp;Line&nbsp;(Pointer)&nbsp;=&nbsp;'&nbsp;'&nbsp;<font color="#0000FF">loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer := Pointer + 1;<br>
&nbsp;&nbsp; <font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp; Set_Pointer (Code, Pointer);<br>
<font color="#0000FF">end</font> Skip;</tt></TD>
  </TR>
</TABLE>
<p>The procedure Skip could be implemented using the procedure
<a href="#Parsers.Generic_Source.Get_Line-procedure">Get_Line</a> as follows:</p>
<TABLE border="1" cellpadding="15" cellspacing="0" id="table1">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">procedure</font> Skip (Code :
<font color="#0000FF">in out </font>Source_Type) <font color="#0000FF">is</font><br>
&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp; : Line_Ptr_Type;<br>
&nbsp;&nbsp; Pointer : Integer;<br>
&nbsp;&nbsp; Last&nbsp;&nbsp;&nbsp; : Integer;<br>
<font color="#0000FF">begin<br>
</font>&nbsp;&nbsp; Get_Line (Code, Line, Pointer, Last);<font color="#0000FF"><br>
</font>&nbsp;&nbsp;&nbsp;<font color="#0000FF">while</font>&nbsp;Pointer&nbsp;&lt;=&nbsp;Last&nbsp;<font color="#0000FF">and</font>&nbsp;<font color="#0000FF">then</font>&nbsp;Line&nbsp;(Pointer)&nbsp;=&nbsp;'&nbsp;'&nbsp;<font color="#0000FF">loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pointer := Pointer + 1;<br>
&nbsp;&nbsp; <font color="#0000FF">end loop</font>;<br>
&nbsp;&nbsp; Set_Pointer (Code, Pointer);<br>
<font color="#0000FF">end</font> Skip;</tt></TD>
  </TR>
</TABLE>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Source.Link"></a>function </font>Link (<b>Code</b> : Source_Type)
<font color="#0000FF">return</font> Location_Type;</tt></p>
</blockquote>
<p>This function gets the source code location between two cursors. The second 
cursor is one returned by <a href="#Parsers.Generic_Source.Get_Pointer">
Get_Pointer</a>. The first cursor is the previous value of the second one 
returned by <a href="#Parsers.Generic_Source.Get_Backup_Pointer">Get_Backup_Pointer</a>. 
The slice in between is usually the last recognized lexical token. It includes 
the character pointed by the first cursor, and does not one pointed by the 
second one. Empty slices are allowed, so Link should never fail even at the end 
of a source. Should Link (<b>Code</b>) called immediately after a call to Skip 
above, it would return a location identifying the blank slice matched by Skip in 
the source code line. </p>
<blockquote>
<p><tt><font color="#0000FF">function </font>Image (<b>Link</b> : Location_Type)
<font color="#0000FF">return</font> String;</tt></p>
</blockquote>
<p>This function returns a text description of a location. The result is a 
string;</p>
<blockquote>
<p><tt><font color="#0000FF">function </font>&quot;<font color="#FF0000">&amp;</font>&quot; (<b>Left</b>,
<b>Right</b> : Location_Type)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Location_Type;</tt></p>
</blockquote>
<p>This function is used to combine two, usually adjacent a source code 
locations. The result is a consecutive code fragment containing positions from 
both <b>Left</b> and <b>Right</b> locations. For example if <b>Left</b> and <b>
Right</b> are locations of &quot;(&quot; and &quot;)&quot; then the result is everything in the 
brackets including the brackets.</p>
<p>Various generic child packages provide parsing facilities to match a thing in 
a source and move the cursor beyond it:</p>
<ul>
	<li>Blanks skipping: <a href="#Parsers.Generic_Source.Get_Blank">plain 
	blanks</a>, <a href="#Parsers.Generic_Source.Get_Ada_Blank">Ada comments</a>,
	<a href="#Parsers.Generic_Source.Get_Cpp_Blank">C++ comments</a>;</li>
	<li>Matching a <a href="#Parsers.Generic_Source.Get_Text">text</a>;</li>
	<li>Matching a <a href="#Parsers.Generic_Source.Get_Token">text from a set</a> 
	of, that is when there is a list of alternatives to choose;</li>
	<li>Matching a <a href="#Parsers.Generic_Source.Keywords">keyword</a>, which 
	is similar to previous, based on a discrete type;</li>
	<li>Matching an XPM image format..</li>
</ul>
<H4>11.4.1. Source cursors I/O</H4>
<p><a name="Parsers.Generic_Source.Text_IO"></a>The child package
<a href="#Parsers.Generic_Source.Text_IO">Parsers.Generic_Source.Text_IO</a> can 
be used for debugging. It provides:</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Put_Line (<b>File</b> : File_Type;
<b>Code</b> : Source_Type);<br>
<font color="#0000FF">procedure</font> Put_Line (<b>Code</b> : Source_Type);</tt></p>
</blockquote>
<p>These procedures output the current source code line following current source 
cursors. The output might look like: </p>
<blockquote>
<p><tt>123.0 + ( Value - 1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^^^^^|</tt></p>
</blockquote>
<p>The parameter <b>File</b> is the text file to write. It is the standard 
output if missing. <b>Code</b> is the source code.</p>
<H4>11.4.2. Procedures to skip blanks </H4>
<p><a name="Parsers.Generic_Source.Get_Blank"></a>There are three child procedures of
<a href="#Parsers.Generic_Source">Parsers.Generic_Source</a> which can be used 
to skip the following blanks and comments:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
<font color="#0000FF">procedure</font> Parsers.Generic_Source.Get_Blank<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b> : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p><a name="Parsers.Generic_Source.Get_Ada_Blank"></a>This procedure  skips spaces, tabulations (HT), line feeds (LF), carriage returns 
(CR), vertical tabulations (VT), form feeds (FF) and 
requests <a href="#Parsers.Generic_Source.Next_Line">new source lines</a> when 
necessary. Upon completion <b>Got_It</b> is set to <i><font color="#1100000">true</font></i> 
if the source end is not yet reached. Otherwise it is <font color="#1100000"><i>
false</i></font>.</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
<font color="#0000FF">procedure</font> Parsers.Generic_Source.Get_Ada_Blank<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b> : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p><a name="Parsers.Generic_Source.Get_Cpp_Blank"></a>This procedure  skips Ada comments, spaces, HT, LF, CR, VT, FF and requests <a href="#Parsers.Generic_Source.Next_Line">new source 
lines</a> when necessary. Upon completion <b>Got_It</b> is set to <i>
<font color="#1100000">true</font></i> if the source end is not yet reached. 
Otherwise it is <font color="#1100000"><i>false</i></font>.
<a name="Ada_comments"></a>Beware that according to ARM 2.2(2) Ada comment ends
either at the physical line end or in either of format effectors: LF, CR, VT, 
FF. This may lead to surprises when format effectors appear in the middle of what 
the operating system counts for a single line.</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
<font color="#0000FF">procedure</font> Parsers.Generic_Source.Get_Cpp_Blank<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Error</b>&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">out</font> Boolean;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
<b>Error_At</b> : <font color="#0000FF">out</font> Location_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure  skips C++ comments, spaces, HT, LF, CR, VT, FF and requests <a href="#Parsers.Generic_Source.Next_Line">new source 
lines</a> when necessary. A C++ comment either starts with <tt>//</tt> (double 
forward slash) and continues to the end of the current line or it does with <tt>/*</tt> 
(forward slash, asterisk) and continues to the first appearance of closing <tt>
*/</tt>. In the latter case nested <tt>/*</tt>..<tt>*/</tt> comments are not 
recognized. Upon completion <b>Got_It</b> is set to <i><font color="#1100000">
true</font></i> if the source end is not yet reached. Otherwise it is
<font color="#1100000"><i>false</i></font>. Error is set to <font color="#1100000">
<i>true</i></font> when no closing <tt>*/</tt>  is found before the source end. In 
this case Error_At contains the location of <tt>/*</tt> in the source. 
Otherwise, Error is <font color="#1100000"><i>false</i></font> and Error_At is 
not defined.</p>
<H4>11.4.3. Procedure to skip text</H4>
<p><a name="Parsers.Generic_Source.Get_Text"></a>There is a child procedure of
<a href="#Parsers.Generic_Source">Parsers.Generic_Source</a> which can be used 
to skip a text in the source:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
<font color="#0000FF">procedure</font>  Parsers.Generic_Source.Get_Text<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp; 
: <font color="#0000FF">in out</font>  Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Text</b>&nbsp;&nbsp;
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b> : <font color="#0000FF">out</font> Boolean;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Map</b>&nbsp;&nbsp;&nbsp;
: Character_Mapping := Identity&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p> Upon completion <b>Got_It</b> is set to <i><font color="#1100000">true</font></i> 
if <b>Text</b> was recognized and skipped. Otherwise it is <font color="#1100000"><i>
false</i></font>. It can be used for creating simple recursively descending
parsers. The parameter <b> Map</b> specifies the  character  equivalence.  A  character  in the source and in
<b> Text</b> are  equivalent  when  they  are  equivalent  in <b>Map</b>.  The default value  considers  all  characters  distinct. To have case-insensitive match  one can use
Ada.Strings.Maps.Constants.Lower_Case_Map.</p>
<H4>11.4.4. Matching keywords</H4>
<p>When writing recursive descent parsers it is common to match the source
against a list of keywords. The child procedure <a href="#Parsers.Generic_Source.Get_Token">Get_Token</a>
of
<a href="#Parsers.Generic_Source">Parsers.Generic_Source</a>  can be used for
this purpose. It has a generic formal parameter Tokens which is an instance of
the package <a href="tables.htm">Tables</a>:</p>
<blockquote>
<p><a name="Parsers.Generic_Source.Get_Token"></a><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; with package </font> Tokens<font color="#0000FF"> is new </font> Tables (&lt;>);<font color="#0000FF"><br>
procedure </font> Parsers.Generic_Source.Get_Token<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp;
: <font color="#0000FF"> in out </font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Folder</b> : Tokens.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Token</b>&nbsp;
: <font color="#0000FF"> out</font> Tokens.Tag;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Got_It</b> :
<font color="#0000FF"> out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>The procedure matches the source <b>Code</b> against the table <b>Folder</b>.
If a token from <b>Folder</b> is matched, then it is skipped in <b>Code</b>, the
value associated with it is stored in <b>Token</b> and <b>Got_It</b> is set to <i><font color="#1100000">true</font></i>.
Otherwise <b>Got_It</b> is set to <font color="#1100000"><i>false</i></font>, and
<b>Token</b> is not changed. Note that <b>Folder </b>can be a descendant of the table type defined in <a href="tables.htm">Tables</a>.
This means that one can also use case-insensitive tables from the package <a href="tables.htm#Tables.Names">Tables.Names</a>.</p>
<p><a name="Parsers.Generic_Source.Keywords"></a>When keywords to match are
plain case-insensitive words, the generic child package <a href="#Parsers.Generic_Source.Keywords">Keywords</a>
can be used instead of <a href="#Parsers.Generic_Source.Get_Token">Get_Token</a>.  An  enumeration type  is  the  generic parameter of the package. The literals of the
type are the keywords to match:</p>
<blockquote>
  <p><tt><font color="#0000FF">generic<br>
  &nbsp;&nbsp; type </font> Keyword <font color="#0000FF"> is</font> (&lt;>);<br>
  <font color="#0000FF">package</font> Parsers.Generic_Source.Keywords<font color="#0000FF">
  is<br>
  </font>&nbsp;&nbsp; ...</tt></p>
</blockquote>
<p>The package provides the procedure:</p>
<blockquote>
<p><tt><font color="#0000FF">
procedure </font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp;
: <font color="#0000FF"> in out </font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Token</b>&nbsp;
: <font color="#0000FF"> out</font>  Keyword;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Got_It</b> :
<font color="#0000FF"> out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This   procedure   matches   a   keyword   in <b>Code</b>.   Matching   is case-insensitive.  When  matched  the keyword value is set into
<b> Token</b> and <b> Got_It</b> is set to <i><font color="#1100000">true</font></i>. The source  cursor  is  then  advanced
behind the  text  matched.  The  longest  possible  token  is  always matched. When no token matches the source
<b> Got_It</b> is set to <font color="#1100000"><i>false</i></font>. The
following code sample illustrates usage of the package:</p>
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6">
<p><tt><font color="#0000FF">     with</font> Parsers.Multiline_Source;<font color="#008000"> --
Muiltiline sources</font><br>
     ...<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Color_Type <font color="#0000FF"> is</font> (Red, Blue, White, Green);<br>
&nbsp;&nbsp; <font color="#0000FF">package</font> Colors<font color="#0000FF"> is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        new </font> Parsers.Multiline_Source.Code.Keywords
(Color_Type);<br>
&nbsp;&nbsp;     ...<br>
&nbsp;&nbsp; Color&nbsp; : Color_Type;<br>
&nbsp;&nbsp; Got_It : Boolean;<br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp;     ...<br>
&nbsp;&nbsp; <font color="#0000FF">loop</font><font color="#008000"> -- Parsing loop</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Colors.Get (Code, Color, Got_It);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if not </font> Got_It <font color="#0000FF"> then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           ... <font color="#008000"> -- This is probably a syntax error</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           case </font> Color<font color="#0000FF"> is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              when
</font> Red&nbsp; =><font color="#008000"> -- "red" was matched</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Blue =><font color="#008000"> -- "blue" was matched</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 ...</tt></p>
</TD>
  </TR>
</TABLE>
<p>This package has a limited use, because many words are reserved in Ada, and
thus cannot be enumeration literals.</p>
<H4>11.4.5. Parsing XPM files</H4>
<p><a name="Parsers.Generic_Source.XPM"></a>This is a useful example of 
designing parsers unrelated to infix expressions, based solely on sources. The 
source code is located in the directory <i>parser-examples/xpm</i>. It provides 
a set of types to deal with XPM image format. The package is generic:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
package </font>Parsers.Generic_Source.XPM<font color="#0000FF"> is</font><br>
&nbsp;&nbsp; ...</tt></p>
</blockquote>
<p><a name="Parsers.Multiline_Source.XPM"></a>It can be instantiated for any 
type sources, but usually it makes sense for <a href="#Parsers.Multiline_Source">
multi-line sources</a> only. The is an instance of the package for this case:
<a href="#Parsers.Multiline_Source.XPM">Parsers.Multiline_Source.XPM</a>.</p>
<p>The generic package provides three subprograms for parsing XPM files. An XPM 
file is basically a C program containing data structures of an image. The source 
of it is usually parsed this way: </p>
<blockquote>
	<p><tt><font color="#0000FF">declare<br>
	</font>&nbsp;&nbsp; Header : Descriptor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	:= Get (Source);<br>
&nbsp;&nbsp; Map&nbsp;&nbsp;&nbsp; : Color_Tables.Table := Get (Source, Header);<br>
&nbsp;&nbsp; Image&nbsp; : Pixel_Buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; := 
	Get (Source, Header, Map);<br>
	<font color="#0000FF">begin<br>
	</font>&nbsp;&nbsp; ... <font color="#008000">-- </font></tt><i>
	<font color="#008000">The image can be used here</font></i></p>
</blockquote>
<p>The package defines the following data types and subroutines:</p>
<blockquote>
  <p><tt><font color="#0000FF">type</font> Descriptor<br>
&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Has_Hotspot : Boolean;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	: Positive<br>
&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is<br>
	record<br>
	</font>&nbsp;&nbsp; Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : String (<font color="#1100000">1</font>..Length);<br>
&nbsp;&nbsp; Width&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Positive;<br>
&nbsp;&nbsp; Height&nbsp;&nbsp;&nbsp;&nbsp; : Positive;<br>
&nbsp;&nbsp; Pixel_Size : Positive;<br>
&nbsp;&nbsp; Map_Size&nbsp;&nbsp; : Positive;<br>
&nbsp;&nbsp; Extended&nbsp;&nbsp; : Boolean;<font color="#0000FF"><br>
&nbsp;&nbsp; case </font>Has_Hotspot<font color="#0000FF"> is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when </font>True =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X_Hotspot : Natural;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y_Hotspot : Natural;<font color="#0000FF"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when </font>False =&gt;<font color="#0000FF"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; null</font>;<font color="#0000FF"><br>
&nbsp;&nbsp; end case</font>;<font color="#0000FF"><br>
	end record</font>;</tt></p>
</blockquote>
<p>The descriptor holds the information about an XPM image:</p>
<ul>
	<li>Name is the name of the image, as found in the file;</li>
	<li>Width is the image width in pixels;</li>
	<li>Height is the image height in pixels;</li>
	<li>Pixel_Size is the number of characters per pixel used in the file;</li>
	<li>Map_Size is the number of colors in the image colormap;</li>
	<li>Extended is <i><font color="#1100000">true</font></i> if the image has 
	XPMEXT part;</li>
	<li>X_Hotspot is the horizontal co-ordinate of hostspot 0..;</li>
	<li>Y_Hotspot is the vertical co-ordinate of hostspot 0...</li>
</ul>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Source.XPM.Get-descriptor"></a>function</font> Get (<b>Code</b> 
: <font color="#0000FF">
access</font> Source_Type) <font color="#0000FF">
return</font> Descriptor;</tt></p>
</blockquote>
<p>This function matches XPM descriptor in <b>Code</b> and returns the value of. 
Syntax_Error is propagated on syntax errors. Other exceptions are related to the 
source access.</p>
<blockquote>
  <p><tt><font color="#0000FF">type</font> RGB_Color <font color="#0000FF">is 
	range</font> <font color="#1100000">0</font>..<font color="#1100000">2</font>**<font color="#1100000">24</font>;<br>
	Transparent : <font color="#0000FF">constant</font> RGB_Color := 
	RGB_Color'Last;<br>
	<font color="#0000FF">package</font> Color_Tables <font color="#0000FF">is 
	new</font> Tables (RGB_Color);</tt></p>
</blockquote>
<p>The color values are encoded as RGB, big-endian. For example, Red is 
16#FF0000#. The value 2**24 is used for the transparent color. The type 
Color_Table.Table is a mapping from String to RGB_Color used to represent color 
maps. It is an instance of <a href="tables.htm">Tables</a>.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Source.XPM.Get-map"></a>function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>&nbsp; Code</b>&nbsp;&nbsp; 
: <font color="#0000FF">
access</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Header</b> 
: Descriptor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Color_Tables.Table;</tt></p>
</blockquote>
<p>This function matches XPM color map in <b>Code</b> and returns the value of.
<b>Header</b> is a descriptor obtained by a call to
<a href="#Parsers.Generic_Source.XPM.Get-descriptor">Get</a> immediately before. 
Syntax_Error is propagated on syntax errors. Other exceptions are related to the 
source access.</p>
<blockquote>
  <p><tt><font color="#0000FF">type</font> Pixel_Buffer <font color="#0000FF">is<br>
&nbsp;&nbsp; array </font>(Positive <font color="#0000FF">range</font> &lt;&gt;, 
	Positive <font color="#0000FF">range</font> &lt;&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">of</font> RGB_Color;</tt></p>
</blockquote>
<p>This type is used to represent the image pixels as <i>row</i> x <i>column</i>.</p>
<blockquote>
<p><tt><font color="#0000FF">
function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Code</b>&nbsp;&nbsp; 
: <font color="#0000FF">access</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Header</b> 
: Descriptor;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Map</b>&nbsp;&nbsp;&nbsp; 
: Color_Tables.Table<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Pixel_Buffer;</tt></p>
</blockquote>
<p>This function matches XPM image in <b>Code</b> and returns the value of. <b>
Header</b> is a descriptor obtained by a call to
<a href="#Parsers.Generic_Source.XPM.Get-descriptor">Get</a> and <b>Map</b> is a 
color map obtained by a call to <a href="#Parsers.Generic_Source.XPM.Get-map">
Get</a>. Syntax_Error is propagated on syntax errors. Other exceptions are 
related to the source access.</p>
<H4>11.4.6. String sources</H4>
<p><a name="Parsers.String_Source"></a>The package
<a href="#Parsers.String_Source">Parsers.String_Source</a> provides an 
implementation of code source based on standard strings. The package is 
non-generic. It instantiates <a href="#Parsers.String_Source">
Parsers.Generic_Source</a> under the name Code. So the package 
Parsers.String_Source.Code can be used everywhere an instance of
<a href="#Parsers.String_Source">Parsers.Generic_Source</a> is required. 
Additionally the package defines:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Location <font color="#0000FF">is 
record</font><br>
&nbsp;&nbsp; From&nbsp;&nbsp; : Integer;<br>
&nbsp;&nbsp; Length : Natural;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>This is the type used for string source locations.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.String_Source.Source"></a>type</font> Source (Text : <font color="#0000FF">
access</font> String)<font color="#0000FF"> is limited record</font><br>
&nbsp;&nbsp; Pointer : Integer := Text'First;<br>
&nbsp;&nbsp; Last&nbsp;&nbsp;&nbsp; : Integer := Text'First;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>This is the type of a string source. The discriminant Text points to the 
string being parsed.</p>
<H4>11.4.7. Multi-line sources</H4>
<p><a name="Parsers.Multiline_Source"></a>The package
<a href="#Parsers.Multiline_Source">Parsers.Multiline_Source</a> provides an 
implementation of code sources consisting of several lines. The package is 
non-generic. It instantiates <a href="#Parsers.String_Source">
Parsers.Generic_Source</a> under the name Code. So the package 
Parsers.Multiline_Source.Code can be used everywhere an instance of
<a href="#Parsers.String_Source">Parsers.Generic_Source</a> is required. The 
package defines an abstract base type Source which should be concretized by 
overriding its abstract operations. The package defines: </p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Line_Number <font color="#0000FF">is 
new </font>Natural;</tt></p>
</blockquote>
<p>The source line numbers.</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Position <font color="#0000FF">is 
record</font><br>
&nbsp;&nbsp; Line&nbsp;&nbsp; : Line_Number;<br>
&nbsp;&nbsp; Column : Integer;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>The source position.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">&lt;</font>&quot; (<b>Left</b>,
<b>Right</b> : Position) <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>The source positions are comparable using both <tt> &quot;<font color="#FF0000">=</font>&quot;</tt>
and <tt> &quot;<font color="#FF0000">&lt;</font>&quot;</tt> .</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Location <font color="#0000FF">is 
record</font><br>
&nbsp;&nbsp; First : Position;<br>
&nbsp;&nbsp; Next&nbsp; : Position;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>The source locations are specified by the first character position and the 
position of the first character next to location.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Multiline_Source.Source"></a>type</font> Source<font color="#0000FF"> is<br>
&nbsp;&nbsp; abstract new </font>Ada.Finalization.Limited_Controlled<font color="#0000FF"> 
with <br>
record</font><br>
&nbsp;&nbsp; Buffer&nbsp; : String_Ptr;<br>
&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp; : Line_Number := <font color="#1100000">0</font>;<br>
&nbsp;&nbsp; Length&nbsp; : Natural;<br>
&nbsp;&nbsp; Pointer : Integer;<br>
&nbsp;&nbsp; Last&nbsp;&nbsp;&nbsp; : Integer;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>Here the fields are:</p>
<ul>
<li>Buffer is the current source line buffer</li>
<li>Line is the current source line number</li>
<li>Length is the current line length in the buffer</li>
<li>Pointer is the second cursor</li>
<li>Last is the first (backup) cursor</li>
</ul>
<p>The field Buffer points to a string, which is used to keep the current source 
line. The constructor allocates the buffer of some reasonable size. When a new 
line is requested the buffer can be replaced by a larger one if necessary. </p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Finalize (<b>Code</b> :
<font color="#0000FF">in out </font>Source);</tt></p>
</blockquote>
<p>The destructor deallocates the buffer.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Initialize (<b>Code</b> :
<font color="#0000FF">in out </font>Source);</tt></p>
</blockquote>
<p>The constructor creates the buffer.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Get_Line (<b>Code</b> :
<font color="#0000FF">in out </font>Source)<font color="#0000FF"> is abstract</font>;</tt></p>
</blockquote>
<p>This is an abstract procedure to be overridden. An implementation should read 
a complete next line into <b>Code</b>.Buffer.<font color="#0000FF">all</font>. 
It may reallocate the buffer if necessary. After a successful completion <b>Code</b>.Buffer 
should point to a buffer containing the line and <b>Code</b>.Length should be 
the line length. The rest of the buffer is ignored. End_Error is propagated if 
no more lines available. Other exceptions can be used on I/O error.</p>
<H4>11.4.8. Text file sources</H4>
<p><a name="Parsers.Multiline_Source.Text_IO"></a>The package
<a href="#Parsers.Multiline_Source.Text_IO">Parsers.Multiline_Source.Text_IO</a> provides
sources based on text files. It declares the type Source:</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Multiline_Source.Text_IO.Source">
</a>type</font> Source (File : <font color="#0000FF">
access</font> File_Type) <font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">new</font> Multiline_Source.Source<font color="#0000FF">
with private</font>;</tt></p>
</blockquote>
<p>The discriminant File points to the file to read. The type File_Type is defined 
in Ada.Text_IO.</p>
<H4>11.4.9. Standard input source</H4>
<p><a name="Parsers.Multiline_Source.Standard_Input"></a>The package
<a href="#Parsers.Multiline_Source.Standard_Input">Parsers.Multiline_Source.Standard_Input</a> provides
sources based on the standard input file. It declares the type Source:</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Multiline_Source.Standard_Input.Source"></a>type</font> Source <font color="#0000FF">is</font> <font color="#0000FF">new</font> Multiline_Source.Source<font color="#0000FF">
with private</font>;</tt></p>
</blockquote>
<p align="right">
  <A name="11.5"></A><a href="#11.4"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.6"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.5. Tokens</H3>
<p><a name="Parsers.Generic_Token"></a>The expression tokens are operations and 
operands. The generic package <a href="#Parsers.Generic_Token">Parsers.Generic_Token</a> defines the token types:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Argument_Type <font color="#0000FF">&nbsp;is private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Operation_Type
<font color="#0000FF">is private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Priority_Type
<font color="#0000FF">&nbsp;is private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">with package</font>  Sources <font color="#0000FF">is new</font> Generic_Source (&lt;&gt;); <br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>&quot;<font color="#FF0000">and</font>&quot; 
(Left, Right : Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Is_Commutative (Left, 
Right : Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Is_Inverse (Binary_Operator 
: Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>Group_Inverse (Binary_Operator 
: Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> 
Operation_Type <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function </font>&quot;<font color="#FF0000">&lt;</font>&quot; 
(Left, Right : Priority_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
<font color="#0000FF">package</font> Parsers.Generic_Token <font color="#0000FF">
is</font> ...</tt></p>
</blockquote>
<p>The parameters of the package defines the operations and the operands to use:</p>
<ul>
<li>Argument_Type is the type used to identify expression arguments (operands). 
Interpreted expressions usually have Argument_Type being directly the type of 
the expression values. If generating a parsing tree is the goal, then 
Argument_Type is usually a reference to a node;</li>
<li>Operation_Type is the type to uniquely identify operations such as unary, binary 
operator, bracket. For an interpreted expression Operation_Type could directly 
refer to some code to execute an operation. In a parsing tree Operation_Type 
objects can be used for building the overloading list of the operation symbol, 
because usually operations are overloaded for different types and different 
visibility contexts. The generic formal functions &quot;<font color="#FF0000">and</font>&quot;, 
Is_Commutative, Is_Inverse and Group_Inverse provide operations on the type 
Operation_Type. They are used for operation <a href="#association_checks">
association checks</a> and for <a href="#commutative_operators">commutative
operation optimizations</a> as described in the package
<a href="#Parsers.Generic_Operation">Parsers.Generc_Operation</a>;</li>
<li>Priority_Type is the operation priority. Priorities are ordered using the
operation &quot;<font color="#FF0000">&lt;</font>&quot;, which is also a generic parameter of 
the package. Higher priority operations have <a href="#operation_association">
higher association</a> with the arguments;</li>
<li>Sources is an instance of <a href="#Parsers.Generic_Source">
Parsers.Generic_Source</a> providing access to the source code.</li>
</ul>
<p>The package provides implementation of the following data structures used 
during expression parsing:</p>
<ul>
<li>Stacks of arguments are provided by the package <b>Arguments</b> through 
instantiation of <a href="#Parsers.Generic_Argument">Parsers.Generic_Argument</a>:</li>
</ul>
<blockquote>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Arguments"></a>package</font> Arguments <font color="#0000FF">is<br>
&nbsp;&nbsp; new</font> Generic_Argument (Argument_Token);</tt></p>
</blockquote>
</blockquote>
<ul>
<li>Operation descriptors are provided by the package <b>Descriptors</b>, which is an 
instance of <a href="#Parsers.Generic_Operation">Parsers.Generic_Operation</a>:</li>
</ul>
<blockquote>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Descriptors"></a>package</font> Descriptors <font color="#0000FF">is<br>
&nbsp;&nbsp; new</font> Generic_Operation (Operation_Token, Priority_Type);</tt></p>
</blockquote>
</blockquote>
<ul>
<li>Tables of expression tokens are provided by the package <b>Vocabulary</b>, which is 
an instance of the package <a href="tables.htm">Table</a>:</li>
</ul>
<blockquote>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Vocabulary"></a>package</font> Vocabulary <font color="#0000FF">is new</font> Tables (Table_Token);</tt></p>
</blockquote>
<p>Token tables are used by parser to recognize operation symbols in the source. 
In accordance with three expression contexts there are at least tree token 
tables: the table of prefixes, the table of infixes and the table of postfixes. 
Each table contains the tokens which may appear in the corresonding context.</p>
</blockquote>
<p>To make these instantiations the package defines the following types:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Argument_Token <font color="#0000FF">is record</font><br>
&nbsp;&nbsp;
Value&nbsp;&nbsp;&nbsp; : Argument_Type;<br>
&nbsp;&nbsp;
Location : Location_Type;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>This type describes an appearance of an argument (operand) in the source. The 
field Value identifies the argument. The field Location is the argument 
location.</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Operation_Token <font color="#0000FF">is record</font><br>
&nbsp;&nbsp;
Operation : Operation_Type;<br>
&nbsp;&nbsp;
Location&nbsp; : Location_Type;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>This type describes an appearance of an operation in the source. Operation 
identifies the operation, Location is the operation location.</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Table_Token (Class : Token_Class := 
Operator) <font color="#0000FF">is record</font><br>
&nbsp;&nbsp; Operation : Operation_Type;<br>
&nbsp;&nbsp; <font color="#0000FF">case</font> Class <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Operator =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left&nbsp; : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Index | 
Semicolon_Class'Range =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Priority : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Bracket | Comma 
| Ligature | Modifier_Class'Range =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">null</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end case</font>;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>This type describes the tokens associated with expression operations to 
recognize in the source. The discriminant Class specifies the class of the 
operation. The field Operation identifies the operation. Additional fields 
determine the operation priorities, if applied. The following operations on 
tables of Table_Table token can be used for filling the tables:</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Operator"></a>procedure</font> Add_Operator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Table</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out </font>Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Operator</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp;&nbsp; : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Right</b>&nbsp;&nbsp;&nbsp; : Priority_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>This procedure is used to add an <a href="#operator">operator</a> to a token 
table. It can be either a prefix unary operator for a table of prefixes, or a 
binary infix operator for an table of infixes or a postfix unary operator for a table of postfixes. 
The parameter <b>Table</b> is the corresponding token table. <b>Name</b> is the 
operator name. Note that the same operator can be specified under different 
names. <b>Operator</b> is the operation associated with the name. <b>Left</b> 
and <b>Right</b> are the <a href="#operation_association">operator priorities</a>. Constraint_Error
is propagated on an incorrectly spelled name, if spelling is checked (see <a href="tables.htm">Table</a>). Name_Error 
is propagated if the name is already in the table.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Bracket"></a>procedure</font> Add_Bracket<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Table</b>&nbsp;&nbsp; : <font color="#0000FF">in out</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Bracket</b> : Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>This procedure is used to add a left order <a href="#brackets">bracket</a> or one of an aggregate to a table of prefixes. It can also be used to add a right bracket of any kind to a table of postfixes. 
The parameter <b>Table</b> is the corresponding token table. <b>Name</b> is the 
bracket name. Note that the same bracket can be specified under different names.
<b>Bracket</b> is the operation associated with the name. Constraint_Error is 
propagated on an incorrectly spelled name. Name_Error is propagated if the name is already in the table.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Comma"></a>procedure</font> Add_Comma<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Table</b> : <font color="#0000FF">in out</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Comma</b> : Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>This procedure is used to add a comma to a table of infixes. The parameter <b>
Table</b> is the table. <b>Name</b> is the comma&nbsp; name. The same comma can 
be specified under different names. <b>Comma </b>&nbsp;is the operation 
associated with the name. Constraint_Error is propagated on an incorrectly spelled name. Name_Error 
is propagated if the name is already in the table.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Index"></a>procedure</font> Add_Index<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Table</b> : <font color="#0000FF">in out</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Index</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp; : Priority_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>This procedure is used to add a <a href="#brackets">left index bracket</a> to a table of infixes. 
The parameter <b>Table</b> is the table. <b>Name</b> is the name of the left 
array index or function call bracket. Note that the same bracket can be 
specified under different names. <b>Index</b> is the operation associated with 
the name. <b>Left</b> is the left priority of the bracket. Constraint_Error is 
propagated on an incorrectly spelled name. Name_Error is propagated if the name is already in the table.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Ligature"></a>procedure</font> Add_Ligature<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Table</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Ligature</b> : Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>This procedure is used to add a <a href="#ligature">ligature</a> to a table of infixes. 
The parameter <b>Table</b> is the table. <b>Name</b> is the name of the 
ligature. Note that the same ligature can be specified under different names. <b>
Ligature</b> is the operation associated with the name. Constraint_Error is 
propagated on an incorrectly spelled name. Name_Error is propagated if the name is already in the table.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Postmodifier"></a>procedure</font> 
Add_Postmodifier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Table</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;&nbsp; : String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Modifier</b> : Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>This procedure is used to add a <a href="#modifier">postmodifier</a> to  a table. The parameter <b>Table</b> is the table. <b>Name</b> is the name of the 
modifier. <b>Modifier</b> is the operation associated with the name. Constraint_Error is 
propagated on an incorrectly spelled name. Name_Error is propagated if the name is already in the table.</p>
<p>Modifiers 
cause call to <a href="#Parsers.Generic_Lexer.On_Postmodifier">On_Postmodifier</a> handler when recognized.</p>
<ul>
  <li>When
a modifier appears 
after an operation it is applied to the operation. This can be used to implement
multi-word operators. For example, to implement a multi-word infix operation one
can add a <a href="#modifier">postmodifier</a> to the prefix table.</li>
  <li>When a
modifier appears immediately after an 
argument it is applied to the argument.</li>
  <li>In all other cases the modifier forces
the parser to finish 
expression processing. If that happens after an infix operation it causes a call 
to <a href="#Parsers.Generic_Lexer.On_Missing_Operand">On_Missing_Operand</a>.</li>
</ul>
<p>A <a href="#modifier">postmodifier</a> added to the table of <i> infixes</i> is always discarded, because an infix operation is 
mandatory to appear after an operand. This has the effect of stopping parsing at 
the modifier, which can be utilized when there are reserved keywords used to 
bound expressions.</p>
<p>A <a href="#modifier">postmodifier</a> added to a <i> prefix</i> or <i> postfix</i> table may appear several times.
This behavior may require special handling. For example, let &quot;<tt><font color="#008000">in</font></tt>&quot;
be a <a href="#modifier">postmodifier</a> for &quot;<tt><font color="#1100000">is</font></tt>&quot;.
Then &quot;<tt>x<font color="#1100000">&nbsp;is</font><font color="#008000">&nbsp;in</font>&nbsp;y</tt>&quot;
and &quot;<tt>x<font color="#1100000">&nbsp;is</font><font color="#008000">&nbsp;in&nbsp;in</font>&nbsp;y</tt>&quot;
will all be legal. To prevent this, one should change the
operation to an equivalent once upon a call to <a href="#Parsers.Generic_Lexer.On_Postmodifier">On_Postmodifier</a>,
so that by the next call to it, one could detect that &quot;<tt><font color="#008000">in</font></tt>&quot;
was already applied and discard the second &quot;<tt><font color="#008000">in</font></tt>&quot;.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Premodifier">
</a>procedure</font> Add_Premodifier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Table</b>&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Modifier</b> : Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is used to add a <a href="#modifier">premodifier</a> either to a table of prefixes or to a table of postfixes. The premodifier when recognized causes a call to
<a href="#Parsers.Generic_Lexer.On_Premodifier">On_Premodifier</a> when the operation following it appears. If the latter does not, 
<a href="#Parsers.Generic_Lexer.On_Missing_Operation">On_Missing_Operation</a> is called. Note that a premodifier cannot be returned back, thus a dangling premodifier is usually a severe error if it cannot be ignored. So it is preferable to use postmodifiers whenever possible. Constraint_Error is 
propagated on an incorrectly spelled name. Name_Error is propagated if the name is already in the table.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Add_Semicolon"></a>procedure</font> Add_Semicolon<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Table</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Name</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: String;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Semicolon</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Class</b>&nbsp;&nbsp;&nbsp;&nbsp; : Semicolon_Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Priority</b>&nbsp; : Priority_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is used to add a <a href="#semicolons">semicolon</a> to a table of infixes. The parameter <b>
Table</b> is the table. <b>Name</b> is the semicolon&nbsp; name. The same 
semicolon can 
be specified under different names. <b>Semicolon</b>&nbsp;is the operation 
associated with the name, argument sublists separated by the semicolon will be 
merged by this operation. The parameter <b>Class</b> specifies the
<a href="#Parsers.Semicolon_Class">semicolon type</a>. Constraint_Error is propagated on an incorrectly spelled name. Name_Error 
is propagated if the name is already in the table. When a sublist obtains all it
is elements <a href="#Parsers.Generic_Lexer.Enclose">Enclose</a> is called with
the parameters indicating <a href="#brackets">left index bracket</a>, <a href="#brackets">bracket</a>
or <a href="#semicolons">semicolon</a> enclosing the sublist. Among the
operations of <a href="#Parsers.Generic_Lexer.Enclose">Enclose</a> at least one
is a <a href="#semicolons">semicolon</a>. The parameter <b>Priority</b> control
the association priority of the separator among other separators. It is the left
association priority when <b>Class</b> is <i> Sublist_Close</i> or <i>Sublist_Separator</i>. It
is the right priority if Class is <i> Sublist_Open</i> or <i>Sublist_Separator</i>.</p>
<p>Additionally the package defines:</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Token.Link"></a>function</font> Link (<b>List</b> : Arguments.Frame) 
<font color="#0000FF">return</font> Location_Type;</tt></p>
</blockquote>
<p>This function merges the locations of all arguments in <b>List</b>. The 
result is a minimal contiguous location containing locations of all arguments 
from <b>List</b>.</p>
<H4>11.5.1. Table driven lexers</H4>
<p><a name="Parsers.Generic_Token.Generic_Token_Lexer"></a>The child generic package
<a href="#Parsers.Generic_Token.Generic_Token_Lexer">
Parsers.Generic_Token.Generic_Token_Lexer</a> an abstract type for table driven
infix expression lexers:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
</font>&nbsp;&nbsp; <font color="#0000FF">type</font> Argument_Stack
<font color="#0000FF">is new</font> Arguments.Stack <font color="#0000FF">with 
private</font>;<br>
<font color="#0000FF">&nbsp;&nbsp; with package </font>Operations
<font color="#0000FF">is new</font> Descriptors.Generic_Stack (&lt;&gt;);<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Operation_Stack
<font color="#0000FF">is abstract new</font> Operations.Stack
<font color="#0000FF">with private</font>;<br>
<font color="#0000FF">package</font> Parsers.Generic_Token.Generic_Token_Lexer
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The package has the following formal parameters:</p>
<ul>
<li>Argument_Stack implements <a href="#argument_stack">argument stack</a>. It
is a descendant of Stack defined in the package
<a href="#Parsers.Generic_Token.Arguments">Arguments</a>;</li>
<li>Operations is an implementation of <a href="#operation_stack">operation
stacks</a>. It is an instance of
<a href="#Parsers.Generic_Operation.Generic_Stack">
Parsers.Generic_Operation.Generic_Stack</a> based on the package
<a href="#Parsers.Generic_Token.Descriptors">Descriptors</a>;</li>
<li>Operation_Stack is the operation stack type, a descendant of the abstract 
type defined in Operations.</li>
</ul>
<p>The package instantiates <a href="#Parsers.Generic_Lexer">
Parsers.Generic_Lexer</a> to provide lexers operating on the Argument_Stack and 
Operation_Stack:</p>
<blockquote>
<p><tt><font color="#0000FF">package</font> Implementation <font color="#0000FF">
is</font> <br>
&nbsp;&nbsp; <font color="#0000FF">new</font> Parsers.Generic_Lexer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
=&gt; Arguments,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Descriptors&nbsp;&nbsp;&nbsp;&nbsp; 
=&gt; Descriptors,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
=&gt; Operations,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Argument_Stack&nbsp; =&gt; 
Argument_Stack,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operation_Stack =&gt; 
Operation_Stack,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sources&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&gt; Sources<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>The obtained lexer type is then extended:</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Token.Generic_Token_Lexer.Lexer"></a>type</font> Lexer<br>
&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Prefixes&nbsp; : <font color="#0000FF">access</font> 
Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Infixes&nbsp;&nbsp; :
<font color="#0000FF">access</font> Vocabulary.Table'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Postfixes : <font color="#0000FF">
access</font> Vocabulary.Table'Class<br>
&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">is abstract new</font> 
Implementation.Lexer <font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The type Lexer has the following discriminants:</p>
<ul>
<li>Prefixes is the table of prefix operations. It contains prefix
<a href="#operator">operators</a> and left order and aggregate
<a href="#brackets">brackets</a>;</li>
<li>Infixes is the table of infix operations. It contains binary infix 
operators, left array index and function call brackets, commas and
<a href="#ligature">ligatures</a>. The infix table may contain an operator with
  empty name. This operator serves as a default as multiplication does in
  mathematical notation like 2<i>x</i> + 4<i>y</i>. This operator is implied
  everywhere an infix operation is expected. The lexer automatically discards it
  at the expression end, which is recognized by absence of an operand. Note that
  <a href="#Parsers.Generic_Lexer.On_Missing_Operand">On_Missing_Operand</a> is
  not called if lexer discards an implied operator;</li>
<li>Postfixes is the table of postfix operations. It contains postfix operators 
and right brackets.</li>
</ul>
<p>A type derived from Lexer has to implement the following abstract subroutines 
defined for the base type in <a href="#Parsers.Generic_Lexer">
Parsers.Generic_Lexer</a>:</p>
<ul>
<li><a href="#Parsers.Generic_Lexer.Call">Call</a> to evaluate an
<a href="#operator">operator</a> or <a href="#ligature">ligature</a>;</li>
<li><a href="#Parsers.Generic_Lexer.Enclose">Enclose</a> to evaluate a function, 
index, aggregate, <a href="#brackets">brackets</a> or a sublist;</li>
<li><a href="#Parsers.Generic_Lexer.Get_Blank">Get_Blank</a> to skip blanks and 
comments in the source;</li>
<li><a href="#Parsers.Generic_Lexer.Get_Operand">Get_Operand</a> to recognize an 
operand in the source.</li>
</ul>
<p>The following error handlers can be overridden if other behavior required: </p>
<ul>
<li><a href="#Parsers.Generic_Lexer.On_Association_Error">On_Association_Error</a> 
raises Syntax_Error;</li>
<li><a href="#Parsers.Generic_Lexer.On_Missing_Operand">On_Missing_Operand</a> 
raises Syntax_Error;</li>
<li><a href="#Parsers.Generic_Lexer.On_Missing_Operand">On_Missing_Operation</a> 
raises Syntax_Error;</li>
<li><a href="#Parsers.Generic_Lexer.On_Missing_Right_Bracket">
On_Missing_Right_Bracket</a> raises Syntax_Error;</li>
<li><a href="#Parsers.Generic_Lexer.On_Postmodifier">On_Postmodifier</a> returns the 
reserved word back and finishes parsing;</li>
<li><a href="#Parsers.Generic_Lexer.On_Premodifier">On_Premodifier</a> returns 
the operation following it back and ignores the modifier;</li>
<li><a href="#Parsers.Generic_Lexer.On_Unexpected">On_Unexpected</a> returns the 
unexpected comma or bracket back and finishes parsing;</li>
<li><a href="#Parsers.Generic_Lexer.On_Wrong_Comma">On_Wrong_Comma</a> raises 
Syntax_Error;</li>
<li><a href="#Parsers.Generic_Lexer.On_Wrong_Right_Bracket">
On_Wrong_Right_Bracket</a> raises Syntax_Error.</li>
</ul>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Parse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Context</b> :
<font color="#0000FF">in out</font> Implementation.Lexer'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out </font>Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Result</b>&nbsp; : <font color="#0000FF">out</font> Argument_Token<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">renames</font> Implementation.Parse;</tt></p>
</blockquote>
<p>This class-wide procedure renames <a href="#Parsers.Generic_Lexer.Parse">
Parsers.Generic_Lexer.Parse</a>. Upon successful completion <b>Result</b> is one 
of the expression. Note that <b>Result</b> is of Argument_Token type. So it 
contains both the expression result and its location, which is usually the 
expression location. The state of <b>Code</b> indicates how far the expression 
parsing advanced even in case of an exception. Parse is recursive-call safe as 
long as implementations of the abstract operations do not change <b>Context</b> 
and <b>Code</b> in an inappropriate way.</p>
<H4>11.5.2. Table driven segmented lexers</H4>
<p><a name="Parsers.Generic_Token.Segmented_Lexer"></a>The child generic package
<a href="#Parsers.Generic_Token.Segmented_Lexer">
Parsers.Generic_Token.Segmented_Lexer</a> provides table driven infix expression 
lexers based on segmented stack implementations:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp; Argument_Frame_Segment_Size : Positive := <font color="#1100000">128</font>;<br>
&nbsp;&nbsp; Argument_Frame_Minimal_Size : Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp; Argument_Frame_Increment&nbsp;&nbsp;&nbsp; : Natural&nbsp; :=
<font color="#1100000">50</font>;<br>
&nbsp;&nbsp; Argument_Stub_Minimal_Size&nbsp; : Positive :=
<font color="#1100000">64</font>;<br>
&nbsp;&nbsp; Argument_Stub_Increment&nbsp;&nbsp;&nbsp;&nbsp; : Natural&nbsp; :=
<font color="#1100000">50</font>;<br>
&nbsp;&nbsp; Operation_Segment_Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Positive :=
<font color="#1100000">128</font>;<br>
&nbsp;&nbsp; Operation_Minimal_Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Positive :=
<font color="#1100000">64</font>;<br>
&nbsp;&nbsp; Operation_Increment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Natural&nbsp; := <font color="#1100000">50</font>;<br>
<font color="#0000FF">package</font> Parsers.Generic_Token.Segmented_Lexer
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The formal parameters Argument_* control argument stack allocation policy, 
see <a href="#Parsers.Generic_Argument.Segmented_Stack">
Parsers.Generic_Argument.Segmented_Stack</a>. The formal parameters Operation_* 
control operation stack allocation policy, see
<a href="#Parsers.Generic_Operation.Segmented_Stack">
Parsers.Generic_Operation.Segmented_Stack</a>.</p>
<p>The package instantiates <a href="#Parsers.Generic_Token.Generic_Token_Lexer">
Parsers.Generic_Token.Generic_Lexer</a> under the name Token_Lexer. The type
<a href="#Parsers.Generic_Token.Generic_Token_Lexer.Lexer">Lexer</a> defined 
there is used as an abstract base:</p>
<blockquote>
<p><tt><font color="#0000FF">subtype</font> Lexer <font color="#0000FF">is</font> 
Token_Lexer.Lexer;</tt></p>
</blockquote>
<p>A type derived from Lexer has to implement the following abstract subroutines 
defined for the base type in <a href="#Parsers.Generic_Lexer">
Parsers.Generic_Lexer</a>:</p>
<ul>
<li><a href="#Parsers.Generic_Lexer.Call">Call</a> to evaluate an
<a href="#operator">operator</a>, <a href="#ligature">ligature</a> or
<a href="#semicolons">semicolon</a>;</li>
<li><a href="#Parsers.Generic_Lexer.Enclose">Enclose</a> to evaluate a function, 
index, aggregate or <a href="#brackets">brackets</a>;</li>
<li><a href="#Parsers.Generic_Lexer.Get_Blank">Get_Blank</a> to skip blanks and 
comments in the source;</li>
<li><a href="#Parsers.Generic_Lexer.Get_Operand">Get_Operand</a> to recognize an 
operand in the source.</li>
</ul>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Parse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Context :
<font color="#0000FF">in out</font> Token_Lexer.Implementation.Lexer'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result&nbsp; 
: <font color="#0000FF">out</font> Argument_Token<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">renames</font> Token_Lexer.Implementation.Parse;</tt></p>
</blockquote>
<p>This class-wide procedure renames <a href="#Parsers.Generic_Lexer.Parse">
Parsers.Generic_Lexer.Parse</a>. Upon successful completion <b>Result</b> is one 
of the expression. Note that <b>Result</b> is of Argument_Token type. So it 
contains both the expression result and its location, which is usually the 
expression location. The state of <b>Code</b> indicates how far the expression 
parsing advanced even in case of an exception. Parse is recursive-call safe as 
long as implementations of the abstract operations do not change <b>Context</b> 
and <b>Code</b> in an inappropriate way.</p>
<p align="right">
  <A name="11.6"></A><a href="#11.5"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.7"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.6. Lexers</H3>
<p><a name="Parsers.Generic_Lexer"></a>The package
<a href="#Parsers.Generic_Lexer">Parsers.Generic_Lexer</a> provides abstract 
infix expression lexer. A lexer scans the source for an expression. It stops scanning 
at the expression end. As it scans the source it uses two stacks to arrange the 
operands and operations it recognizes. Operands are stored on the
<a href="#argument_stack">argument stack</a>, operations are pushed onto the
<a href="#operation_stack">operation stack</a>. To recognize the expression
tokens abstract subroutines are used to be implemented by concrete derived 
types.</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; with package </font>Arguments <font color="#0000FF">is new</font> 
Generic_Argument (&lt;&gt;);<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Argument_Stack
<font color="#0000FF">is new</font> Arguments.Stack <font color="#0000FF">with 
private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">with package </font>Descriptors
<font color="#0000FF">is new</font> Generic_Operation (&lt;&gt;); <br>
&nbsp;&nbsp; <font color="#0000FF">with package</font> Operations
<font color="#0000FF">is new</font> Descriptors.Generic_Stack (&lt;&gt;);<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Operation_Stack
<font color="#0000FF">is abstract new</font> Operations.Stack
<font color="#0000FF">with private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">with package</font>  Sources <font color="#0000FF">is new</font> Generic_Source (&lt;&gt;);<br>
<font color="#0000FF">package</font> Parsers.Generic_Lexer <font color="#0000FF">
is</font> ...</tt></p>
</blockquote>
<p>The package generic parameters: </p>
<ul>
<li>Arguments is an instance of <a href="#Parsers.Generic_Argument">
Parsers.Generic_Argument</a> providing an implementation of argument stacks;</li>
<li>Argument_Stack is a concrete argument stack type. It is a descendant of the 
base type defined in the package Arguments. So the type provided by Arguments 
can be additionally specialized if necessary;</li>
<li>Descriptors is the parent of an implementation of operation stacks. It is an 
instance of the package <a href="#Parsers.Generic_Operation">Parsers.Generic_Operation</a> 
defining the expression operations;</li>
<li>Operations is an implementation of operation stacks based on Descriptors. It is an 
instance of <a href="#Parsers.Generic_Operation.Generic_Stack">Parsers.Generic_Operation.Generic_Stack</a>; </li>
<li>Operation_Stack is the operation stack type, a descendant of the abstract type defined in Operations;</li>
<li>Code is an instance of <a href="#Parsers.Generic_Source">Parsers.Generic_Source</a>, defining the type Source_Type.</li>
</ul>
<p>The package defines the abstract type <a href="#Parsers.Generic_Lexer.Lexer">Lexer</a>:</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.Lexer"></a>type</font> Lexer <font color="#0000FF">is abstract<br>
&nbsp;&nbsp; new</font> Ada.Finalization.Limited_Controlled
<font color="#0000FF">with private</font>; </tt></p>
</blockquote>
<p>and the type of lexical tokens used to communicate with lexical callbacks:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Lexical_Token (Class : Token_Class := 
Operator) <font color="#0000FF">is record</font><br>
&nbsp;&nbsp; Operation : Operation_Type;<br>
&nbsp;&nbsp; <font color="#0000FF">case</font> Class <font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Operator =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Left&nbsp; : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Right : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> Index | 
Semicolon_Class'Range =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Priority : Priority_Type;<br>
<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when</font> Bracket | Comma 
| Ligature | Modifier_Class'Range =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">null</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end case</font>;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<p>The class-wide operation</p>
<blockquote>
<p>
<tt><a name="Parsers.Generic_Lexer.Parse"></a><font color="#0000FF">procedure</font> Parse<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Code</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Result</b>&nbsp; : 
<font color="#0000FF">out</font> Argument_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>is used to scan the source <b>Code</b>. Upon successful completion <b>Result</b> is one of the expression. 
In any outcome the source cursor indicates how far the expression parsing has 
managed to proceed. <a href="#Parsers.Generic_Lexer.Parse">Parse</a> is recursive-call safe as long as implementations of the abstract operations do not change 
<b>Context</b> and <b>Code</b> in an inappropriate way. It means that an implementation of an operation may in turn call 
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> to get a subexpression from source if that necessary.</p>
<p>A type derived from Lexer has to implement the following abstract subroutines:</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.Call"></a>function</font> Call<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Context</b>&nbsp;&nbsp; 
: <font color="#0000FF">access</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Operation</b> 
: Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>List</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Frame<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; <font color="#0000FF">
return</font> Argument_Type <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called to execute an <a href="#operator">operator</a> when 
all its arguments become known. <a href="#ligature">Ligatures</a> and
<a href="#semicolons">semicolons</a> are also 
executed by making a call to this procedure. The parameter <b>Operation</b> 
identifies the operator being called. <b>List</b> is the list of the 
arguments. The first element of <b>List</b> is the first argument for <b>
Operation</b>. The result is one of the operation. Any exception raised in Call 
will abort parsing and propagate out of <a href="#Parsers.Generic_Lexer.Parse">
Parse</a>. Note that binary commutative operations for 
which <a href="#Parsers.Generic_Operation.Is_Commutative">Is_Commutative</a> 
returns <i><font color="#1100000">true</font></i> are optimized, may have <b>List</b> 
larger than of just two arguments. For example: for a commutative <tt>&quot;+&quot;</tt> 
the expression <tt>A+B+C</tt> will result in one call <tt>&quot;+&quot;(A,B,C)</tt> instead of 
two: <tt>&quot;+&quot;(&quot;+&quot;(A,B),C)</tt>.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.Enclose"></a>function</font> Enclose<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">access</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp; : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Right</b>&nbsp;&nbsp; : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>List</b>&nbsp;&nbsp;&nbsp; : Frame<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">return</font> Argument_Type <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called to execute <a href="#brackets">brackets</a>. 
Brackets could be  order, aggregate, array index or function calls. In the 
latter two cases the first argument in <b>List</b> is the array to be indexed or the function 
to be called. The parameter <b>Left</b> identifies the left bracket. The 
parameter <b>Right</b> does the right one. The result is one of the bracket 
operation. Any exception raised in Enclose will abort parsing and propagate out 
of <a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.Get_Blank"></a>procedure</font> Get_Blank<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Got_It</b>&nbsp; : 
<font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p align="left">An implementation should skip everything till the next valid 
lexeme in the source <b>Code</b>. It starts from the current source position 
(see <a href="#Parsers.Generic_Source.Get_Line">Get_Line</a> and <a href="#Parsers.Generic_Source.Get_Pointer">Get_Pointer</a>) and advances 
it to the first non-blank character (see
<a href="#Parsers.Generic_Source.Set_Pointer">Set_Pointer</a>). The parameter <b>Got_It</b> is set to 
<i><font color="#1100000">false</font></i> when the end of expression reached. This could be the end of file or a reserved keyword. 
Usually Get_Blank skips spaces, tabs, linefeeds and comments. Get_Blank may 
raise an exception to be propagated out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> on an error, like unclosed 
comment etc. There are child packages implementing different variants of 
Get_Blank: see
<a href="#Parsers.Generic_Lexer.Blanks">
Parsers.Generic_Lexer.Blanks</a> /
<a href="#Parsers.Generic_Lexer.Ada_Blanks">
Ada_Blanks</a> / <a href="#Parsers.Generic_Lexer.Cpp_Blanks">Cpp_Blanks</a>.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Get_Infix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Code</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Token</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Lexical_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>Got_It</b>&nbsp; : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>An implementation should recognize a valid infix token and skip it in the source
<b>Code</b> by advancing the source cursor (see
<a href="#Parsers.Generic_Source.Set_Pointer">Set_Pointer</a>). <b>Got_It</b> indicates success. 
When <b>Got_It</b> is set to <font color="#1100000"><i>true</i></font>, <b>Token</b> contains a valid infix token. That is either of:</p>
<ul>
<li>A binary infix <a href="#operator">operator</a>: <b>Token</b>.Class = 
Operator, other components specify the operation associated with the operator 
and <a href="#operation_association">operator's priorities</a>;</li>
<li>A left index brackets: <b>Token</b>.Class = Index, other components are the 
bracket operation and its <a href="#left_bracket_priority">left priority</a>;</li>
<li>A commas: <b>Token</b>.Class = Comma and the operation associated with.</li>
</ul>
<p>When <b> Got_It</b> is <i><font color="#1100000">false</font></i>, it means that no 
infix operation was detected. Get_Infix may 
raise an exception to be propagated out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> on an unrecoverable error. <a href="#Parsers.Generic_Lexer.Lexer">Lexer</a>
automatically processes assumed infix operations. When it is necessary to parse
expressions like 5<i>a</i>+1, then the multiplication is an implied operator. <a href="#Parsers.Generic_Lexer.Lexer">Lexer</a>
recognizes this case when the source pointers are equal. Implied operators are
discarded at the expression end without call to <a href="#Parsers.Generic_Lexer.On_Missing_Operand">On_Missing_Operand</a>.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.Get_Operand"></a>procedure</font> Get_Operand<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b>&nbsp; : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp;&nbsp; :
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Argument</b> :
<font color="#0000FF">out</font> Argument_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Got_It</b>&nbsp;&nbsp; : 
<font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
) <font color="#0000FF">&nbsp;is abstract</font>;</tt></p>
</blockquote>
<p>An implementation should recognize a valid operand token and skip it in the source
<b>Code</b>. <b>Got_It</b> indicates success. If <b>Got_It</b> is <i>
<font color="#1100000">true</font></i> then <b>Argument</b> contains or 
references to the operand such as literal, name etc. Otherwise, it means that no 
operand was recognized in the source. Get_Operand may raise an exception to be 
propagated out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> on an unrecoverable error. Note 
that syntax errors in operands should not necessarily be fatal. <b>Argument</b> 
can be set into a special value indicating a syntactically wrong operand, which 
would allow to continue parsing.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Get_Postfix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Token</b>&nbsp;&nbsp; : 
<font color="#0000FF">out</font> Lexical_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Got_It</b>&nbsp; : 
<font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>An implementation should recognize a valid postfix token and skip it in the source
<b>Code</b>. <b>Got_It</b> indicates success. When Got_It is <i>
<font color="#1100000">true</font></i> then <b>Token</b> contains a valid postfix token. That is either of:</p>
<ul>
<li>Postfix <a href="#operator">operators</a>: <b>Token</b>.Class = Operator, 
other components specify the operation associated with the operator and
<a href="#operation_association">operator's priorities</a>;</li>
<li>Right <a href="#brackets">brackets</a>: <b>Token</b>.Class = Bracket, <b>
Token</b>.Operation indicates the operation associated with the bracket.</li>
</ul>
<p>When Got_It is <i><font color="#1100000">false</font></i>, it means that no 
postfix operation was detected. Get_Postfix may 
raise an exception to be propagated out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> on an unrecoverable error.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Get_Prefix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Token</b>&nbsp;&nbsp; : 
<font color="#0000FF">out</font> Lexical_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Got_It</b>&nbsp; : 
<font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>An implementation should recognize a valid prefix token and skip it in the source
<b>Code</b>. <b>Got_It</b> indicates success. When Got_It is <i>
<font color="#1100000">true</font></i> then <b>Token</b> contains a valid prefix token. That is either of:</p>
<ul>
<li>Prefix <a href="#operator">operators</a>: <b>Token</b>.Class = Operator, 
other components specify the operation associated with the operator and
<a href="#operation_association">operator's priorities</a>;</li>
<li>Left <a href="#brackets">brackets</a>: <b>Token</b>.Class = Bracket, <b>
Token</b>.Operation indicates the operation associated with the bracket.</li>
</ul>
<p>When Got_It is <i><font color="#1100000">false</font></i>, it means that no 
postfix operation was detected. Get_Prefix may 
raise an exception to be propagated out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> on an unrecoverable error.</p>
<p>The following procedures are used for error handling. They are called from
<a href="#Parsers.Generic_Lexer.Parse">Parse</a> to handle an exceptional state 
detected during expression parsing.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Lexer.On_Association_Error"></a>procedure</font> On_Association_Error<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Right</b>&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called when two operators sharing or associated in an 
argument are <a href="#association_checks">incompatible</a>. The handler may modify any of the parameters
<b>Left</b> and <b>Right</b> to make them compatible. In this case upon return 
the operation <b>Right</b> will be pushed onto the operation stack again with 
all association checks suppressed. Alternatively it may raise an exception which would then abort parsing 
and propagate out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.On_Missing_Operand">
</a>procedure</font> On_Missing_Operand<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b>&nbsp; : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Argument</b> :
<font color="#0000FF">out</font> Argument_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called when an operand is expected. That is either when no expression was recognized 
at all or when an infix operation or comma is not followed by an operand. The 
handler can return the default operand into the parameter <b>Argument</b>. This 
could be a special kind of Argument_Type reserved for such cases. The expression 
parsing will be then continued. In some languages, like C++ it is legal to omit 
operands in some cases. For example by calling parameterless functions. Alternatively 
On_Missing_Operand may raise an exception which would then abort parsing and 
propagate out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<blockquote>
<p><tt><a name="Parsers.Generic_Lexer.On_Missing_Operation"></a><font color="#0000FF">procedure</font> On_Missing_Operation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Context</b>&nbsp; 
: <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Modifier</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Token</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">out</font> Lexical_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b>&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called when an operation expected after a
<a href="#modifier">premodifier</a> was not found there. The parameter <b>
Modifier</b> identifies it. The handler may ignore the modifier and continue 
parsing the expression as if there where no modifier by setting <b>Got_It</b> to
<font color="#1100000"><i>false</i></font>. It may simulate an operation by 
setting it to <i><font color="#1100000">true</font></i> and placing the operation 
token into <b>Token</b>. 
Alternatively it may raise an exception which would then abort parsing 
propagating out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Lexer.On_Missing_Right_Bracket"></a>procedure</font> On_Missing_Right_Bracket<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out </font>Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out </font>Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Right</b>&nbsp;&nbsp; : 
<font color="#0000FF">out</font> Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called when the lexer detects an unclosed left bracket by finishing expression parsing. 
The handler can modify the left bracket specified by the parameter <b>Left</b> and should specify a suggested right one 
in the parameter <b>Right</b>. Alternatively it may raise an exception which would then 
abort parsing and propagate out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Lexer.On_Postmodifier"></a>procedure</font> 
On_Postmodifier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b>&nbsp;&nbsp; : <font color="#0000FF">in out </font>Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : 
<font color="#0000FF">in out </font>Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Modifier</b>&nbsp; : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b>&nbsp;&nbsp;&nbsp; : out Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
<font color="#0000FF">
procedure</font> 
On_Postmodifier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b>&nbsp;&nbsp; : <font color="#0000FF">in out </font>Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Argument </b>&nbsp;: 
<font color="#0000FF">in out </font>Argument_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Modifier</b>&nbsp; : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>These procedures are called to process <a href="#modifier">postmodifiers</a>. The parameter <b>Modifier</b> 
is the operation associated with the modifier. A <a href="#modifier">postmodifier</a>
can be applied 
to either an operation or an argument it follows. The parameter <b>Operation</b> /
<b>Argument</b> refers to the thing to modify. The procedure may observe it and 
change it. The parameter <b>Got_It</b> is set to <font color="#1100000"><i>true</i></font> 
to indicate that the modifier was successfully processed. It is set to <i>
<font color="#1100000">false</font></i> to finish parsing in which case it
recommended to call <a href="#Parsers.Generic_Source.Reset_Pointer">Reset_Pointer</a>
(<b>Code</b>) to bring source back to the position before the modifier. For an operation 
modifier this will cause a call to the
<a href="#Parsers.Generic_Lexer.On_Missing_Operand">On_Missing_Operand</a> 
handler if that is not a postfix operation.
<a href="#Parsers.Generic_Lexer.On_Postmodifier">On_Postmodifier</a> may raise an 
exception which would then abort parsing. The default implementation returns the 
modifier back and sets <b>Got_It</b> to <i><font color="#1100000">false</font></i>. </p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Lexer.On_Premodifier"></a>procedure</font> 
On_Premodifier<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b>&nbsp;&nbsp; : <font color="#0000FF">in out </font>Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Token</b>&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> 
Lexical_Token;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Modifier</b>&nbsp; : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Got_It</b>&nbsp;&nbsp;&nbsp; : <font color="#0000FF">out</font> Boolean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called to process a <a href="#modifier">premodifier</a>. The parameter <b>Modifier</b> 
is the operation associated with the modifier. A premodifier is applied to the 
operation it precedes. The operation is specified by the parameter <b>Token</b>. 
The handler sets <b>Got_It</b> to <i><font color="#1100000">true</font></i> to 
indicate that <b>Token</b> was modified as necessary. When <b>Got_It</b> is set 
to
<font color="#1100000"><i>false</i></font> then the operation is discarded and 
parsing proceeds either to the next context allowing the modifier to be applied to 
an operation of another class or by discarding the modifier. That means:</p>
<ul>
<li>For a postfix operation, an attempt is made to apply the modifier to an infix 
one which may follow.</li>
<li>In case of a prefix operation the modifier is discarded, which has the 
effect of ignoring it.</li>
<li>For an infix operation, it is discarded and parsing is finished.</li>
</ul>
<p>
<a href="#Parsers.Generic_Lexer.On_Premodifier">On_Premodifier</a> may raise an 
exception which would then abort parsing. The default implementation returns the 
modifier back and sets <b>Got_It</b> to <i><font color="#1100000">false</font></i>. </p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.On_Unexpected"></a>procedure</font> On_Unexpected<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Right</b>&nbsp;&nbsp; : Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
);</tt></p>
</blockquote>
<p>This procedure is called when the lexer meets an unexpected comma, right bracket,
<a href="#ligature">ligature</a> or <a href="#semicolons">semicolon</a> 
specified by the parameter <b>Right</b>. The default implementation returns the unexpected delimiter back and then tries to complete the expression evaluation, 
so that the lexer will stop at the delimiter and return the expression 
result. This behavior is useful when expressions bounded by commas or brackets 
are parsed in case of nested expressions or descending code parsers. An override 
may raise an exception which would then abort parsing and propagate out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Lexer.On_Wrong_Comma"></a>procedure</font> On_Wrong_Comma<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Comma</b>&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>; </tt></p>
</blockquote>
<p>This procedure is called when the lexer finds <a href="#association_checks">incompatible</a> comma,
<a href="#ligature">ligature</a> or <a href="#semicolons">semicolon</a>. It can modify the left bracket
(the parameter <b>Left</b>), the delimiter (the parameter <b>Comma</b>) or both to make them 
compatible. Upon return <b>Comma</b> will be pushed onto the
<a href="#operation_stack">operation stack</a> again with all checks suppressed. Alternatively it may raise an exception which would then abort
and propagate out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Lexer.On_Wrong_Right_Bracket"></a>procedure</font> On_Wrong_Right_Bracket<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; <b>Context</b> : <font color="#0000FF">in out</font> Lexer;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Code</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Source_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Right</b>&nbsp;&nbsp; : 
<font color="#0000FF">in out</font> Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called when the lexer finds <a href="#association_checks">incompatible</a>
brackets. It can modify the left bracket (the parameter <b>Left</b>), the right 
one (the parameter <b>Right</b>) or both to make them compatible. Upon return 
<b>Right</b> will be pushed onto the <a href="#operation_stack">operation stack</a>
again with all checks suppressed. Alternatively it may raise an exception which would then abort and 
propagate out of
<a href="#Parsers.Generic_Lexer.Parse">Parse</a>.</p>
<H4>11.6.1. Blank skipping</H4>
<p>There are three child packages of
<a href="#Parsers.Generic_Lexer">Parsers.Generic_Lexer</a> providing lexers with 
<a href="#Parsers.Generic_Lexer.Get_Blank">Get_Blank</a> defined to skip the following blanks and comments:</p>
<ul>
<li><a name="Parsers.Generic_Lexer.Blanks"></a>
<a href="#Parsers.Generic_Lexer.Blanks">
Parsers.Generic_Lexer.Blanks</a> skips spaces, HT, LF, CR, VT, FF 
and requests <a href="#Parsers.Generic_Source.Next_Line">new source lines</a> 
when necessary;</li>
<li><a name="Parsers.Generic_Lexer.Ada_Blanks"></a>
<a href="#Parsers.Generic_Lexer.Ada_Blanks">
Parsers.Generic_Lexer.Ada_Blanks</a> acts like
<a href="#Parsers.Generic_Lexer.Blanks">
Parsers.Generic_Lexer.Blanks</a> and also skips Ada comments starting from 
double hyphen and ending in the line end. Note that an Ada comment may end 
before physical line end (<a href="#Ada_comments">see</a>);</li>
<li><a name="Parsers.Generic_Lexer.Cpp_Blanks"></a>
<a href="#Parsers.Generic_Lexer.Cpp_Blanks">Parsers.Generic_Lexer.Cpp_Blanks</a> 
acts like
<a href="#Parsers.Generic_Lexer.Blanks">
Parsers.Generic_Lexer.Blanks</a> and also skips C++ comments. A C++ 
comment either starts with <tt>//</tt> (double forward slash) and continues to 
the end of the current line or with <tt>/*</tt> (forward slash, asterisk) and 
continues to the first appearance of closing <tt>*/</tt>. In the latter case 
nested <tt>/*</tt>..<tt>*/</tt> comments are not recognized. Further when no 
closing <tt>*/</tt> matched till the source end, Syntax_Error is propagated and 
thus aborts parsing. A handler may look into the field Unclosed_Commend of the 
lexer object to determine the location of <tt>/*</tt> in the source. </li>
</ul>
<p>These packages are generic:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Lexer_Type (&lt;&gt;)
<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">abstract new</font> 
Parsers.Generic_Lexer.Lexer <font color="#0000FF">with private</font>;<br>
<font color="#0000FF">package</font> Parsers.Generic_Lexer...
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The generic parameter Lexer_Type is a descendant of the type Lexer defined in 
the parent package (an instance of
<a href="#Parsers.Generic_Lexer">Parsers.Generic_Lexer</a>). They derive from 
this type a new type and override Get_Blank as described above:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Lexer <font color="#0000FF">is abstract 
new </font>Lexer_Type <font color="#0000FF">with</font> ...</tt></p>
</blockquote>
<p align="right">
  <A name="11.7"></A><a href="#11.6"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.8"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.7. Operations</H3>
<p><a name="Parsers.Generic_Operation"></a>Operations are <a href="#operator">
operators</a>, <a href="#brackets">brackets, commas and ligatures</a>. Each operation 
denotes some action to be executed. The parser uses several data 
structures based operations. These are defined using the generic package
<a href="#Parsers.Generic_Operation">Parsers.Generic_Operation</a> as the base 
package:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
<font color="#0000FF">&nbsp;&nbsp; type</font> Operation_Type
<font color="#0000FF">is private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Priority_Type
<font color="#0000FF">is private</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> &quot;<font color="#FF0000">and</font>&quot; 
(Left, Right : Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> Is_Commutative (Left, 
Right : Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> Is_Inverse (Operation : 
Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> Group_Inverse (Operation 
: Operation_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> 
Operation_Type <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> &quot;<font color="#FF0000">&lt;</font>&quot; 
(Left, Right : Priority_Type)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font> &lt;&gt;;<br>
<font color="#0000FF">package</font> Parsers.Generic_Operation<font color="#0000FF"> 
is</font> ...</tt></p>
</blockquote>
<p>The formal generic parameters define the set of operations and their 
priorities:</p>
<blockquote>
<p><tt>
<font color="#0000FF">type</font> Operation_Type
<font color="#0000FF">is private</font>;</tt></p>
</blockquote>
<p>Objects of Operation_Type identify an appearance of an operation in the 
source. Usually it is the operation identifier with the source location attached 
to it. If no error diagnostic required Operation_Type can directly represent 
operations. The following operations should be defined on Operation_Type:</p>
<blockquote>
<p><tt> <font color="#0000FF"><a name="Parsers.Generic_Operation.and"></a>function</font> &quot;<font color="#FF0000">and</font>&quot; 
(<b>Left</b>, <b>Right</b> : Operation_Type) <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function is used to check operation compatibility. The parameters is one 
in which the corresponding operations appear in the source. The result is
<font color="#1100000"><i>true</i></font> if <b>Left</b> and be associated with
<b>Right</b>. It is safe to return true if all <a href="#operator">operators</a> 
are compatible and there is only one pair of <a href="#brackets">brackets</a>. 
See <a href="#association_checks">association checks</a> for further
information.</p>
<blockquote>
<p><tt> <font color="#0000FF"><a name="Parsers.Generic_Operation.Is_Commutative">
</a>function</font> Is_Commutative (<b>Left</b>, 
<b>Right</b> : Operation_Type)<br>
&nbsp; <font color="#0000FF">&nbsp;return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <i><font color="#1100000">true</font></i> if <b>Left</b> 
and <b>Right</b> are either the same commutative operation or either the group 
or inverse operation of the same group. See <a href="#commutative_operators">
commutative operators</a> for further information. It is safe to define this 
function as <font color="#1100000"><i>false</i></font> for any pair of operations 
if no commutative operator optimization required.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Operation.Is_Inverse"></a>function</font> Is_Inverse (<b>Binary_Operator</b> 
: Operation_Type)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean; </tt></p>
</blockquote>
<p>For binary operators on which Is_Commutative is <font color="#1100000"><i>true</i></font>, 
this function returns <i><font color="#1100000">true</font></i> if <b>
Binary_Operator</b> is an inverse operation of the corresponding commutative 
group. For example, for addition it should be <font color="#1100000"><i>false</i></font>, 
for subtraction it should be <font color="#1100000"><i>true</i></font>.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Operation.Group_Inverse">
</a>function</font> Group_Inverse (<b>Binary_Operator</b> 
: Operation_Type)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Operation_Type; </tt></p>
</blockquote>
<p>For the binary operators on which Is_Commutative is <i><font color="#1100000">
true</font></i> this function returns the unary inverse operation of the 
corresponding commutative group. For example for either addition or subtraction 
it should return unary minus.</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Priority_Type<font color="#0000FF"> is 
private</font>;</tt></p>
</blockquote>
<p>This is the operation priority type. Higher priority operations have higher
<a href="#operation_association">association</a> with the operands. Priorities
are ordered using &quot;<font color="#FF0000">&lt;</font>&quot;:</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> &quot;<font color="#FF0000">&lt;</font>&quot; (<b>Left</b>,
<b>Right</b> : Priority_Type) <font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>The package
<a href="#Parsers.Generic_Operation">Parsers.Generic_Operation</a> also defines 
the type Descriptor used for <a href="#operation_stack">operation stack</a>
items:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Descriptor_Class <font color="#0000FF">
is</font> (Stub, Operator, Default, Sublist, Tuple, Ligature);<br>
<font color="#0000FF">type</font> Descriptor (Class : Descriptor_Class := Stub)
<font color="#0000FF">is record<br>
&nbsp;&nbsp; case </font>Class <font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when </font>Operator..Ligature =&gt; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operation : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">case</font> 
Class <font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when </font>
Operator..Tuple =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Count : Natural;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">case</font> Class <font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
when </font>Operator..Sublist =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Right : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">when others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">null</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">end case</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">when others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">null</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end case</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">null</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end case</font>;<br>
<font color="#0000FF">end record</font>;</tt></p>
</blockquote>
<H4>11.7.1. Operation stack</H4>
<p><a name="operation_stack"></a><a name="Parsers.Generic_Operation.Generic_Stack"></a>Operation stack is one of the basic data
structures used while parsing. It is used to store operations as they are 
recognized and rearrange them according to the precedence rules. When an 
operator is recognized in the source, it is pushed onto the stack. Before that 
all operators with right priorities higher or equal to the left priority of the 
new operator are popped. They get their arguments from another stack and push 
the result there. Left brackets are treated as stack stubs. They are popped when 
a right bracket appears. This simple algorithm allows to parse infix expressions 
without resorting to grammars.</p>
<p>The operation stack is provided by the generic 
child package <a href="#Parsers.Generic_Operation.Generic_Stack">Parsers.Generic_Operation.Generic_Stack</a>:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp;
type </font>Descriptor_Stack<font color="#0000FF"> is limited private</font>;</tt></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr>
<td bgcolor="#FFFF99"><tt>&nbsp;&nbsp; <font color="#0000FF">type</font> Index_Type
<font color="#0000FF">is</font> (&lt;&gt;);<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> Get<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Container : Descriptor_Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index&nbsp;&nbsp;&nbsp;&nbsp; : Index_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">return</font> Descriptor <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">with</font>&nbsp;<font color="#0000FF">function</font>&nbsp;Is_Empty&nbsp;(Container&nbsp;:&nbsp;Descriptor_Stack)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean 
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> Mark (Container : Descriptor_Stack)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Index_Type
<font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure</font> Pop<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;&nbsp;Container&nbsp;:&nbsp;<font color="#0000FF">in</font>&nbsp;<font color="#0000FF">out</font>&nbsp;Descriptor_Stack;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Count&nbsp;&nbsp;&nbsp;&nbsp; : Natural := <font color="#1100000">1</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure</font> Push<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Container : <font color="#0000FF">in out</font> Descriptor_Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Item&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Descriptor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with procedure</font> Put<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(&nbsp; Container : <font color="#0000FF">in out</font> Descriptor_Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index&nbsp;&nbsp;&nbsp;&nbsp; : Index_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Element&nbsp;&nbsp; : Descriptor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
)&nbsp; <font color="#0000FF">is</font> &lt;&gt;;<br>
&nbsp;&nbsp; <font color="#0000FF">with function</font> Top (Container : Descriptor_Stack)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Descriptor 
<font color="#0000FF">is</font> &lt;&gt;;</tt></td>
</tr>
</table>
<p><tt><font color="#0000FF">package</font> Parsers.Generic_Operation.Generic_Stack
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The generic parameters of the package define interface of a raw stack of 
Descriptor items.&nbsp;The type Descriptor is defined in the parent package. The 
stack interface is same as one of <a href="#Generic_Stack">Generic_Stack</a>. In 
the code snippet above it is highlighted. To 
instantiate of <a href="#Parsers.Generic_Operation.Generic_Stack">Parsers.Generic_Operation.Generic_Stack</a> 
one could first instantiate <a href="#Generic_Stack">Generic_Stack</a> (or else
<a href="#Generic_Segmented_Stack">Generic_Segmented_Stack</a>) using Descriptor 
for the stack item (Object_Type), then use the instance package, and finally 
instantiate <a href="#Parsers.Generic_Operation.Generic_Stack">Parsers.Generic_Operation.Generic_Stack</a> 
in this context with Descriptor_Stack parameter set to the raw stack type. The 
result package provides higher level operation stack interface:</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Operation.Generic_Stack.Stack"></a>type</font> Stack <font color="#0000FF">is abstract</font><br>
&nbsp;&nbsp; <font color="#0000FF">new</font> 
Ada.Finalization.Limited_Controlled <font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The operation stack type is an abstract controlled type. The following 
primitive operations has to be implemented by derived types:</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Operaion.Generic_Stack.Call"></a>procedure</font> Call<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out </font>Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Count</b>&nbsp;&nbsp;&nbsp;&nbsp; : Natural<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called to execute an <a href="#operator">operator</a> when 
all its arguments become known. <a href="#ligature">Ligatures</a> are also 
executed by making a call to this procedure. The parameter <b>Operation</b> 
identifies the operator being called. <b>Count</b> is the number of the 
arguments. It is not specified where arguments are located. However, it is 
assumed that they are accessed in LIFO order. Binary commutative operations for 
which <a href="#Parsers.Generic_Operation.Is_Commutative">Is_Commutative</a> 
returns <i><font color="#1100000">true</font></i> are optimized, so that one Call 
is used instead of a sequence of calls in cases like <tt>A+B+C</tt>. Which will 
result in <tt>&quot;+&quot;(A,B,C)</tt> instead of <tt>&quot;+&quot;(&quot;+&quot;(A,B),C)</tt>. </p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Operaion.Generic_Stack.Enclose"></a>procedure</font> Enclose<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Right</b>&nbsp;&nbsp;&nbsp;&nbsp; : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Count</b>&nbsp;&nbsp;&nbsp;&nbsp; : Natural<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure is called to execute <a href="#brackets">brackets</a> and
sublists. 
Brackets could be  order, aggregate, array index or function calls. In the 
latter two cases the first argument is the array to be indexed or the function 
to be called. The parameter <b>Left</b> identifies the left bracket or sublist
separator. The 
parameter <b>Right</b> does the right one. <b>Count</b> is the number of the 
arguments. Note one extra argument for array indices and function calls.</p>
<p>The following operations are defined on operation stacks:</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Empty (<b>Container</b> : 
Stack'Class)
<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <font color="#1100000"><i>true</i></font> if the raw 
stack is empty.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Operaion.Generic_Stack.Push_Abort"></a>procedure</font> 
Push_Abort (<b>Container</b> : <font color="#0000FF">in out</font> Stack'Class);</tt></p>
</blockquote>
<p>This procedure cleans the stack to remove the side-effects of a call to
<a href="#Parsers.Generic_Operaion.Generic_Stack.Push_Start">Push_Start</a>. It 
is used upon an unrecoverable expression evaluation errors.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Operaion.Generic_Stack.Push_End"></a>procedure</font> 
Push_End (<b>Container</b> : <font color="#0000FF">in out</font> Stack'Class);</tt></p>
</blockquote>
<p>This procedure is called when the right margin of the expression reached. 
This can be a source end or a reserved keyword. It also can be an extra 
delimiter (see Unexpected_Comma, Unexpected_Right_Bracket exceptions). After 
successful completion the stack is returned to its state before the call to
<a href="#Parsers.Generic_Operaion.Generic_Stack.Push_Start">Push_Start</a>. 
Missing_Right_Bracket is propagated when some left brackets of the expression 
remain open. A handler should either close them using Push_Right_Bracket and 
then try <a href="#Parsers.Generic_Operaion.Generic_Stack.Push_End">Push_End</a> 
again or call <a href="#Parsers.Generic_Operaion.Generic_Stack.Push_Abort">
Push_Abort</a>.</p>
<blockquote>
<p><tt><font color="#0000FF">
<a name="Parsers.Generic_Operaion.Generic_Stack.Push_Start"></a>procedure</font> 
Push_Start (<b>Container</b> : <font color="#0000FF">in out</font> Stack'Class);</tt></p>
</blockquote>
<p>This procedure pushes a stub onto the stack. A stub is removed by either a 
successful call to <a href="#Parsers.Generic_Operaion.Generic_Stack.Push_End">
Push_End</a> or by a call to
<a href="#Parsers.Generic_Operaion.Generic_Stack.Push_Abort">Push_Abort</a>. 
Parsing an expression starts with a call to
<a href="#Parsers.Generic_Operaion.Generic_Stack.Push_Start">Push_Start</a> and 
ends by either <a href="#Parsers.Generic_Operaion.Generic_Stack.Push_End">
Push_End</a> (normal completion) or
<a href="#Parsers.Generic_Operaion.Generic_Stack.Push_Abort">Push_Abort</a> 
(abnormal completion). The operation stack is safe for recursive calls, so the 
same stack can be used for parsing nested expressions.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Binary<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Right</b>&nbsp;&nbsp;&nbsp;&nbsp; : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Unchecked</b> : Boolean := False;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Explicit</b>&nbsp;
: Boolean := True<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called when a binary infix <a href="#operator">operator</a> 
is recognized in the source. The parameter <b>Operation</b> identifies the 
operator. <b>Left</b> and <b>Right</b> are the operator's
<a href="#operation_association">priorities</a>. Association_Error is propagated
on an incompatible operator on the left. See <a href="#association_checks">association checks</a> for further
information. No checks made if the parameter <b>Unchecked</b> is set to <i>
<font color="#1100000">true</font></i>. The parameter <b> Explicit</b> should  be
<font color="#1100000"><i>false</i></font>  if  the operator was assumed in place of a missing one.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Comma<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Comma</b>&nbsp;&nbsp;&nbsp;&nbsp; : Boolean;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Unchecked</b> : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called when either a comma or a <a href="#ligature">
ligature</a> is recognized in the source. When a plain comma matches the left 
bracket, it increases the number of arguments the list in the brackets has. A 
ligature does not increase the number of arguments, but binds two arguments it 
separates. <a href="#ligature">Ligatures</a> can be viewed as binary 
non-commutative operations which may appear only within brackets and have no 
priority. <a href="#Parsers.Generic_Operaion.Generic_Stack.Call">Call</a> is 
applied to to execute a ligature. The parameter <b>Comma</b> is true when <b>
Operation</b> identifies a comma, and false if it does a ligature. 
Unexpected_Comma is propagated if there is no any left bracket to match. 
Wrong_Comma_Type is propagated when the left bracket does not match. See <a href="#association_checks">association checks</a> for further
information. No checks made if the parameter <b>Unchecked</b> is set to <i>
<font color="#1100000">true</font></i>.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Left_Bracket<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called when a left order bracket or a left bracket of an 
aggregate is detected. <b>Operation</b> identifies the bracket. Do not confuse 
them with the left brackets of array indices and function calls.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Left_Bracket<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out </font>Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Unchecked</b> : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called when a left bracket of an array index or a function 
call is recognized in the source. Operation identifies the bracket. Left is the
<a href="#left_bracket_priority">left priority of the bracket</a>.
Association_Error is propagated upon an incompatible operator on the left. See <a href="#association_checks">association checks</a> for further
information. No checks made if the parameter <b>Unchecked</b> is set to <i>
<font color="#1100000">true</font></i>.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Right_Bracket<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Unchecked</b> : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called to process a right bracket of any kind. The 
parameter <b>Operation</b> specifies the bracket. Unexpected_Right_Bracket is 
propagated when there is no any left bracket to match. Wrong_Right_Bracket_Type 
is propagated when the left bracket does not match.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Postfix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Right</b>&nbsp;&nbsp;&nbsp;&nbsp; : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Unchecked</b> : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called when a postfix unary <a href="#operator">operator</a> 
is detected. The parameter <b>Operation</b> identifies the operator. <b>Left</b> 
and <b>Right</b> are the operator's <a href="#operation_association">priorities</a>.
Association_Error is propagated on an incompatible operator on the left. No 
checks made if the parameter <b>Unchecked</b> is set to <i>
<font color="#1100000">true</font></i>.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Prefix<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Left</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Right</b>&nbsp;&nbsp;&nbsp;&nbsp; : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Unchecked</b> : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is called when a prefix unary <a href="#operator">operator</a> 
is detected. The parameter <b>Operation</b> identifies the operator. <b>Left</b> 
and <b>Right</b> are the operator's <a href="#operation_association">priorities</a>.
Association_Error is propagated on an incompatible operator on the left. No 
checks made if the parameter <b>Unchecked</b> is set to <i>
<font color="#1100000">true</font></i>.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push_Semicolon <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Operation</b> : Operation_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Class</b>&nbsp;&nbsp;&nbsp;&nbsp; : Semicolon_Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Priority</b>&nbsp; : Priority_Type;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Unchecked</b> : Boolean := False<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure is used to process a sublist separator (<a href="#semicolons">semicolon</a>). 
The paramter <b>Operation</b> identifies the semicolon and is used in
<a href="#Parsers.Generic_Operaion.Generic_Stack.Call">Call</a> when the 
operands: items of a sublist become all known. The parameter <b>Class</b> 
specifies the <a href="#Parsers.Semicolon_Class">semicolon type</a>. <b> Priority</b> is 
the association priority. Unexpected_Comma is propagated if there is no any left bracket to match.
Association_Error is propagated on an operation association error, Wrong_Comma_Type
does on bracket error. See <a href="#association_checks">association checks</a> for further
information. No checks made if the parameter <b>Unchecked</b> is set to <i>
<font color="#1100000">true</font></i>.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Replace<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b>&nbsp;&nbsp; 
: <font color="#0000FF">in out </font>Stack'Class;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Replacement</b> : Descriptor<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This procedure can be used to replace an item (operation descriptor) on the 
stack top. Immediately after a call to
<a href="#Parsers.Generic_Operaion.Generic_Stack.Push_Start">Push_Start</a>, the 
stack is semantically empty and contains a stub, which should never be replaced 
by any descriptor of other type. Constraint_Error is propagated when <b>
Container</b> is physically empty.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Top (<b>Container</b> : Stack'Class)
<font color="#0000FF">return</font> Descriptor;</tt></p>
</blockquote>
<p>This function returns the stack top. Constraint_Error is propagated when the 
raw stack is empty.</p>
<H4>11.7.2. Segmented operation stack</H4>
<p><a name="Parsers.Generic_Operation.Segmented_Stack"></a>The child generic 
package <a href="#Parsers.Generic_Operation.Segmented_Stack">
Parsers.Generic_Operation.Segmented_Stack</a> instantiates <a href="#Parsers.Generic_Operation.Generic_Stack">Parsers.Generic_Operation.Generic_Stack</a> 
using the segmented stacks from the package
<a href="#Generic_Segmented_Stack">Generic_Segmented_Stack</a>. The package has 
the following generic parameters:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp; Segment_Size : Positive := <font color="#1100000">128</font>;<br>
&nbsp;&nbsp; Minimal_Size : Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp; Increment&nbsp;&nbsp;&nbsp; : Natural&nbsp; :=
<font color="#1100000">50</font>;<br>
<font color="#0000FF">package</font> Parsers.Generic_Operation.Segmented_Stack
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>These parameters controls stack allocation (<a href="#Generic_Segmented_Stack_parameters">see</a>).
The package instantiates <a href="#Parsers.Generic_Operation.Generic_Stack">Parsers.Generic_Operation.Generic_Stack</a> 
under the name Operation:</p>
<blockquote>
<p><tt><font color="#0000FF">package</font> Operation <font color="#0000FF">is 
new </font>Generic_Stack (...);</tt></p>
</blockquote>
<p>So the stack type can be denoted as <i>instance-name</i>.Operation.Stack, 
where <i>instance-name</i> is the name of under which
<a href="#Parsers.Generic_Operation.Segmented_Stack">
Parsers.Generic_Operation.Segmented_Stack</a> is instantiated.</p>
<H4>11.7.3. Example of a direct use of the operation stack</H4>
<p><a name="operation_stack_example"></a>The following example illustrates a direct use of the operation stack without 
source parsing. That is when an external lexer is used for lexical analysis. In 
this case the operation stack can be used as part of syntax analysis dealing 
with operation association. The example starts from defining the operations, their 
priorities and finally instantiates
<a href="#Parsers.Generic_Operation.Segmented_Stack">
Parsers.Generic_Operation.Segmented_Stack</a> providing operation stacks.</p>
File <i>operation_stack_expressions.ads</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#FFDEBD"><tt><font color="#0000FF">with</font> 
Generic_Segmented_Stack;<br>
<font color="#0000FF">with</font> Parsers.Generic_Operation.Segmented_Stack;<br>
<br>
<font color="#0000FF">package</font> Operation_Stack_Expressions
<font color="#0000FF">is</font><br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Integer_Stack -- Stacks of integers to keep arguments<br>
&nbsp;&nbsp; --<br>
</font><font color="#0000FF">&nbsp;&nbsp; package</font> Integer_Stack
<font color="#0000FF">is</font><br>
<font color="#0000FF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new</font> 
Generic_Segmented_Stack<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; Index_Type&nbsp;&nbsp; 
=&gt; Integer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Object_Type&nbsp; =&gt; Integer,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Null_Element =&gt; <font color="#1100000">0</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ); <br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Operations -- The set of operations<br>
&nbsp;&nbsp; --<br>
&nbsp;&nbsp; </font><font color="#0000FF">type</font> Operations
<font color="#0000FF">is</font> (Add, Mul, Inc, Left_Bracket, Right_Bracket);<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> &quot;<font color="#FF0000">and</font>&quot; 
(Left, Right : Operations) <font color="#0000FF">return</font> Boolean;<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font>&nbsp;Is_Commutative&nbsp;(Left,&nbsp;Right&nbsp;:&nbsp;Operations)&nbsp;<font color="#0000FF">return</font>&nbsp;Boolean;<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Is_Inverse (Operation : 
Operations) <font color="#0000FF">return</font> Boolean;<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Group_Inverse (Operation : 
Operations) <font color="#0000FF">return</font> Operations;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Priorities -- The operation priorities<br>
&nbsp;&nbsp; --<br>
&nbsp;&nbsp; </font><font color="#0000FF">type</font> Priorities
<font color="#0000FF">is range</font> <font color="#1100000">1</font>..<font color="#1100000">10</font>;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Raw_Descriptors -- The raw operation stack descriptors<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">package</font> Raw_Descriptors
<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">new</font> 
Parsers.Generic_Operation (Operations, Priorities);<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Descriptor_Stacks -- Operation stack based on raw descriptors<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">package</font> Descriptor_Stacks
<font color="#0000FF">is</font> <font color="#0000FF">new</font> 
Raw_Descriptors.Segmented_Stack;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Use the package of operation stacks deployed there<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">use</font> Descriptor_Stacks.Operation;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Expression_Stack -- Derived from abstract operation stack to<br>
&nbsp;&nbsp; -- provide implementation of operation calls. <br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">type</font> Expression_Stack
<font color="#0000FF">is new</font> Stack <font color="#0000FF">with record</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Data : Integer_Stack.Segmented_Stack.Stack;<br>
&nbsp;&nbsp; <font color="#0000FF">end record</font>;<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Call -- Overrides to implement operators<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Call<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Stack&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> 
Expression_Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Operation : Operations;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Count&nbsp;&nbsp;&nbsp;&nbsp; : Natural<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
<font color="#008000">&nbsp;&nbsp; --<br>
&nbsp;&nbsp; -- Enclose -- Overrides to implement brackets<br>
&nbsp;&nbsp; --<br>
</font>&nbsp;&nbsp; <font color="#0000FF">procedure</font> Enclose<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Stack : <font color="#0000FF">in out</font> Expression_Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Left&nbsp; : Operations;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Right : Operations;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Count : Natural<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
<font color="#0000FF">end</font> Operation_Stack_Expressions;</tt></TD>
  </TR>
</TABLE>
<p>Here Integer_Stack is an instance of <a href="#Generic_Segmented_Stack">
Generic_Segmented_Stack</a> to keep arguments (integers). The type Operations is 
the set of defined operations: addition, multiplication, post-increment, left 
and right order brackets. The function &quot;<font color="#FF0000">and</font>&quot; is 
provided for association checks. Is_Commutative and Is_Inverse always return
<font color="#1100000"><i>false</i></font>. Group_Inverse may return anything, it 
will never be called. The type Priorities defines the operation priorities. 
Raw_Descriptors is an instance of
<a href="#Parsers.Generic_Operation">Parsers.Generic_Operation</a> based on 
Operation and Priority. At this point
<a href="#Parsers.Generic_Operation.Segmented_Stack">
Parsers.Generic_Operation.Segmented_Stack</a> can be instantiated. 
Desciptor_Stacks is the instance which provides the abstract operation stack. 
Expression_Stack is derived from it. It has one additional data member of 
Integer_Stack type, that will keep the arguments of the operations. The abstract 
procedures <a href="#Parsers.Generic_Operaion.Generic_Stack.Call">Call</a> and 
<a href="#Parsers.Generic_Operaion.Generic_Stack.Enclose">Enclose</a> are overridden to implement the operations semantic.</p>
File<i> operation_stack_expressions.adb</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> Ada.Text_IO;&nbsp;
<font color="#0000FF">use</font> Ada.Text_IO;<br>
<br>
<font color="#0000FF">package body </font>Operation_Stack_Expressions
<font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">use</font> Integer_Stack.Segmented_Stack;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> &quot;<font color="#FF0000">and</font>&quot; 
(Left, Right : Operations) <font color="#0000FF">return</font> Boolean
<font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> True;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> &quot;<font color="#FF0000">and</font>&quot;;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Is_Commutative (Left, Right : 
Operations)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Boolean<font color="#0000FF"> 
is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return </font>False;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Is_Commutative;<br>
<br>
&nbsp;&nbsp;&nbsp;<font color="#0000FF">function</font>&nbsp;Is_Inverse&nbsp;(Operation&nbsp;:&nbsp;Operations)&nbsp;<font color="#0000FF">return</font>&nbsp;Boolean&nbsp;<font color="#0000FF">is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return </font>False;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Is_Inverse;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">function</font> Group_Inverse (Operation : 
Operations)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Operations<font color="#0000FF"> 
is<br>
&nbsp;&nbsp; begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise </font>Program_Error; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">return</font> Inc;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Group_Inverse;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Call<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Stack&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">in out</font> 
Expression_Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Operation : Operations;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Count&nbsp;&nbsp;&nbsp;&nbsp; : Natural<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">is</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L, R : Integer;<br>
&nbsp;&nbsp; <font color="#0000FF">begin<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if </font>Count &gt; <font color="#1100000">0</font>
<font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R := Top (Stack.Data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pop (Stack.Data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">if</font> Count &gt;
<font color="#1100000">1</font> <font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L := Top (Stack.Data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pop (Stack.Data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">case</font> Operation
<font color="#0000FF">is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when</font> Add =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Push (Stack.Data, 
L + R);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Mul =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Push (Stack.Data, 
L * R);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when</font> 
Inc =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Push (Stack.Data, 
R + 1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">when 
others</font> =&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#0000FF">raise</font> Constraint_Error;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">end case</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Call;<br>
<br>
&nbsp;&nbsp; <font color="#0000FF">procedure</font> Enclose<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; 
Stack : <font color="#0000FF">in out</font> Expression_Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Left&nbsp; : Operations;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Right : Operations;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Count : Natural<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp; 
<font color="#0000FF">is</font><br>
&nbsp;&nbsp; <font color="#0000FF">begin</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">null</font>;<br>
&nbsp;&nbsp; <font color="#0000FF">end</font> Enclose;<br>
<br>
<font color="#0000FF">end</font> Operation_Stack_Expressions;</tt></TD>
  </TR>
</TABLE>
<p>Implementation of <a href="#Parsers.Generic_Operaion.Generic_Stack.Call">Call</a> is straightforward it gets arguments from the stack
evaluates the operation and pushes the result back. 
<a href="#Parsers.Generic_Operaion.Generic_Stack.Enclose">Enclose</a> need nothing to do 
because order brackets is do not change the argument. Now the operation stack is 
ready to use:</p>
File <i>test_operation_expressions.adb</i>:
<TABLE border="1" cellpadding="15" cellspacing="0">
  <TR>
<TD bgcolor="#C0D8D6"><tt><font color="#0000FF">with</font> 
Operation_Stack_Expressions;<br>
<font color="#0000FF">use</font>&nbsp; Operation_Stack_Expressions;<br>
<br>
<font color="#0000FF">procedure</font> Test_Operation_Stack
<font color="#0000FF">is<br>
&nbsp;&nbsp; use</font> Operation_Stack_Expressions.Raw_Descriptors;<br>
&nbsp;&nbsp; <font color="#0000FF">use</font> 
Operation_Stack_Expressions.Descriptor_Stacks.Operation;<br>
<font color="#0000FF">&nbsp;&nbsp; use</font> 
Operation_Stack_Expressions.Integer_Stack.Segmented_Stack;<br>
<br>
&nbsp;&nbsp; Expression : Expression_Stack;<br>
<font color="#0000FF">begin</font><br>
&nbsp;&nbsp; <font color="#008000">-- 1 + (2 + 3 + 4 * 5)++ + 6 * 7 + 8++</font><br>
&nbsp;&nbsp; Push_Start (Expression);<br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">1</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 1</font><br>
&nbsp;&nbsp; Push_Binary (Expression, Add, <font color="#1100000">5</font>,
<font color="#1100000">6</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- +</font><br>
&nbsp;&nbsp; Push_Left_Bracket (Expression, Left_Bracket);&nbsp;&nbsp;
<font color="#008000">-- (</font><br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">2</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 2</font><br>
&nbsp;&nbsp; Push_Binary (Expression, Add, <font color="#1100000">5</font>,
<font color="#1100000">6</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- +</font><br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">3</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 3</font><br>
&nbsp;&nbsp; Push_Binary (Expression, Add, <font color="#1100000">5</font>,
<font color="#1100000">6</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- +</font><br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">4</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 4</font><br>
&nbsp;&nbsp; Push_Binary (Expression, Mul, <font color="#1100000">7</font>,
<font color="#1100000">8</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- *</font><br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">5</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 5</font><br>
&nbsp;&nbsp; Push_Right_Bracket (Expression, Right_Bracket);
<font color="#008000">-- )</font><br>
&nbsp;&nbsp; Push_Postfix (Expression, Inc, <font color="#1100000">9</font>,
<font color="#1100000">10</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- ++</font><br>
&nbsp;&nbsp; Push_Binary (Expression, Add, <font color="#1100000">5</font>,
<font color="#1100000">6</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- +</font><br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">6</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 6</font><br>
&nbsp;&nbsp; Push_Binary (Expression, Mul, <font color="#1100000">7</font>,
<font color="#1100000">8</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- *</font><br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">7</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 7</font><br>
&nbsp;&nbsp; Push_Binary (Expression, Add, <font color="#1100000">5</font>,
<font color="#1100000">6</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- +</font><br>
&nbsp;&nbsp; Push (Expression.Data, <font color="#1100000">8</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#008000">-- 8</font><br>
&nbsp;&nbsp;&nbsp;Push_Postfix&nbsp;(Expression,&nbsp;Inc,&nbsp;<font color="#1100000">9</font>,&nbsp;<font color="#1100000">10</font>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#008000">-- ++</font><br>
&nbsp;&nbsp; Push_End (Expression);<br>
&nbsp;&nbsp; <font color="#0000FF">if</font> Top (Expression.Data) /=
<font color="#1100000">78</font> <font color="#0000FF">then</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000FF">raise</font>
Constraint_Error;<br>
&nbsp;&nbsp; <font color="#0000FF">end if</font>;<br>
<font color="#0000FF">end</font> Test_Operation_Stack;</tt></TD>
  </TR>
</TABLE>
<p>This procedure evaluates <tt>1 + (2 + 3 + 4 * 5)++ + 6 * 7 + 8++ </tt>just by
pushing arguments and the operations onto the corresponding stacks.
<a href="#Parsers.Generic_Operaion.Generic_Stack.Push_End">Push_End</a> finishes 
the expression evaluation and the stack of arguments contains the only one item, 
the expression result.</p>
<p align="right">
  <A name="11.8"></A><a href="#11.7"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#11.9"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.8. Arguments</H3>
<p><a name="argument_stack"></a>The argument stack is the basic data structure used for parsing. It contains
the expression arguments, that is the operands of operations and their results. 
When expression is interpreted to immediately obtain its result, arguments are 
usually just values. When expression is compiled into some intermediate 
representation, arguments are leaves and nodes of the parsing tree.</p>
<H4>11.8.1. Argument stack</H4>
<p><a name="Parsers.Generic_Argument"></a>The generic package 
<a href="#Parsers.Generic_Argument">Parsers.Generic_Argument</a> defines the base abstract type for argument stacks:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp; <font color="#0000FF">type</font> Argument_Type i<font color="#0000FF">s 
private</font>;<br>
<font color="#0000FF">package</font> Parsers.Generic_Argument
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The generic parameter Argument_Type identifies appearance of an argument in 
the source. Usually it is the argument and a source location link. The package 
defines:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Argument_No <font color="#0000FF">is 
new </font>Positive;<br>
<font color="#0000FF">type</font> Frame <font color="#0000FF">is array</font> (Argument_No
<font color="#0000FF">range</font> &lt;&gt;) <font color="#0000FF">of</font> 
Argument_Type;</tt></p>
</blockquote>
<p>The type Frame is used to pass argument lists to the expression operations.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Argument.Stack"></a>type</font> Stack <font color="#0000FF">is abstract<br>
&nbsp;&nbsp; new </font>Ada.Finalization.Limited_Controlled
<font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p>The abstract base type of argument stacks. An implementation should provide 
the following abstract subprograms:</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Empty (<b>Container</b> : Stack)
<font color="#0000FF">return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <font color="#1100000"><i>true</i></font> if the current 
stack fragment is empty.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Argument.Mark"></a>procedure</font> Mark (<b>Container</b> : <font color="#0000FF">in out</font> 
Stack) <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure creates a new stack fragment. A stack fragment represents an 
independent argument stack. No arguments below mark can be accessed in any way 
until <a href="#Parsers.Generic_Argument.Release">Release</a> is called. </p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Pop<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>List</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">in out</font> Frame<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure pops an argument frame from the stack. The arguments fill the 
list provided by the parameter List. The number of arguments is defined by <b>
List</b>'Length. Constraint_Error is propagated when <b>Container</b> does not 
contain enough arguments in the current fragment (above the last
<a href="#Parsers.Generic_Argument.Mark">mark</a>).</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Push<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Container</b> 
: <font color="#0000FF">in out</font> Stack;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>
Argument</b>&nbsp; : Argument_Type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;
<font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure pushes one argument onto the stack.</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Parsers.Generic_Argument.Release"></a>procedure</font> Release (<b>Container</b> : <font color="#0000FF">in out</font> 
Stack) <font color="#0000FF">is abstract</font>;</tt></p>
</blockquote>
<p>This procedure should be called for each call to
<a href="#Parsers.Generic_Argument.Mark">Mark</a> to remove the stack fragment 
created by the mark. If there are any arguments on the stack pushed after the
mark, they are removed. Constraint_Error is propagated when the stack does not 
contain any mark.</p>
<H4>11.8.2. Segmented argument stack</H4>
<p><a name="Parsers.Generic_Argument.Segmented_Stack"></a>The generic child 
package <a href="#Parsers.Generic_Argument.Segmented_Stack">
Parsers.Generic_Argument.Segmented_Stack</a> provides an implementation of 
argument stack using segmented stacks from the package
<a href="#Generic_Segmented_Stack">Generic_Segmented_Stack</a>. The package has 
the following generic parameters:</p>
<blockquote>
<p><tt><font color="#0000FF">generic</font><br>
&nbsp;&nbsp; Frame_Segment_Size : Positive := <font color="#1100000">128</font>;<br>
&nbsp;&nbsp; Frame_Minimal_Size : Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp; Frame_Increment&nbsp;&nbsp;&nbsp; : Natural&nbsp; :=
<font color="#1100000">50</font>;<br>
&nbsp;&nbsp; Stub_Minimal_Size&nbsp; : Positive := <font color="#1100000">64</font>;<br>
&nbsp;&nbsp; Stub_Increment&nbsp;&nbsp;&nbsp;&nbsp; : Natural&nbsp; :=
<font color="#1100000">50</font>;<br>
<font color="#0000FF">package</font> Parsers.Generic_Argument.Segmented_Stack
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The parameters Frame_Segment_Size, Frame_Minimal_Size and Frame_Increment 
controls <a href="#Generic_Segmented_Stack_parameters">allocation of stack
segments</a>. The parameters Stub_Minimal_Size and Stub_Increment controls a
<a href="#Generic_Unbounded_Array">Generic_Unbounded_Array</a> used to keep 
stack stubs (fragments bounds). The type Stack defined in the package: </p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Stack <font color="#0000FF">is new
</font>Parsers.Generic_Argument.Stack <font color="#0000FF">with private</font>;</tt></p>
</blockquote>
<p align="right">
  <A name="11.9"></A><a href="#11.8"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#12"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>11.9. Parsing tree example. Ada 95 expression parser</H3>
<p><a name="Parsers.Ada"></a>The package <a href="#Parsers.Ada">Parsers.Ada</a> provides a full Ada 95 expression analyzer. The 
analyzer has the type Ada_Expression defined in the package. The analyzer 
recognizes an Ada expression in the source and stops at its end. The type 
Operations defines the Ada operations:</p>
<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080" height="19" valign="top"><FONT color="#FFFFFF"><B>Name<br>
    (Operation)</B></FONT></TD>
    <TD bgcolor="#008080" height="19" valign="top">
    <p align="center"><font color="#FFFFFF"><b>Ada 95<br>
    notation</b></font></P></TD>
    <TD bgcolor="#008080" height="19" valign="top"><font color="#FFFFFF"><b>Comment. 
    References to the corresponding sections of <i>Ada Reference Manual</i> are 
    given in round brackets where appropriate</b></font></TD>
  </TR>
  <TR>
    <TD height="19">Logical_And</TD>
    <TD height="19" align="center"><font color="#0000FF"><tt>and</tt></font></TD>
    <TD rowspan="5" height="127" valign="top">Logical operators and short-circuit 
    control 
    forms (<a href="http://www.adaic.com/standards/05rm/html/RM-4-5-1.html">4.5.1</a>). Logical and/or are implemented as <a href="#modifier">
    premodifiers</a> turning into infix operators when no short-circuit suffix 
    defined as a <a href="#modifier">postmodifier</a> follows. As the operators 
    all of them are declared
    commutative in the sense that the adjacent operators of same type will be 
    merged into one as in the case of<blockquote>
    <tt>A<font color="#0000FF">&nbsp;and&nbsp;then&nbsp;</font>B<font color="#0000FF">&nbsp;and&nbsp;then&nbsp;</font>C</tt>
    </blockquote>
    Parsed to And_Then (A, B, C). All these operators have the priority level
    2 (both the left and the right ones).</TD>
  </TR>
  <TR>
    <TD height="19">Logical_Or</TD>
    <TD height="19" align="center"><font color="#0000FF"><tt>or</tt></font></TD>
  </TR>
  <TR>
    <TD height="19">Logical_Xor</TD>
    <TD height="19" align="center"><font color="#0000FF"><tt>xor</tt></font></TD>
  </TR>
  <TR>
    <TD height="19">And_Then</TD>
    <TD height="19" align="center"><font color="#0000FF"><tt>and&nbsp;then</tt></font></TD>
  </TR>
  <TR>
    <TD height="19">Or_Else</TD>
    <TD height="19" align="center"><font color="#0000FF"><tt>or&nbsp;else</tt></font></TD>
  </TR>
  <TR>
    <TD height="19">EQ</TD>
    <TD height="19" align="center"><tt>=</tt></TD>
    <TD rowspan="8" height="208" valign="top">Relational operators and membership 
    tests (<a href="http://www.adaic.com/standards/05rm/html/RM-4-5-2.html">4.5.2</a>). The operator <tt><font color="#0000FF">not&nbsp;in</font></tt> is 
    implemented as a premodifier <tt><font color="#0000FF">not</font></tt> 
    applied to the following operator <tt><font color="#0000FF">in</font></tt>. 
    Both membership tests are defined as an infix operators. All these operators 
    have the priority level 3.</TD>
  </TR>
  <TR>
    <TD height="19">NE</TD>
    <TD height="19" align="center"><tt>/=</tt></TD>
  </TR>
  <TR>
    <TD height="19">LT</TD>
    <TD height="19" align="center"><tt>&lt;</tt></TD>
  </TR>
  <TR>
    <TD height="19">LE</TD>
    <TD height="19" align="center"><tt>&lt;=</tt></TD>
  </TR>
  <TR>
    <TD height="19">GE</TD>
    <TD height="19" align="center"><tt>&gt;</tt></TD>
  </TR>
  <TR>
    <TD height="19">GT</TD>
    <TD height="19" align="center"><tt>&gt;=</tt></TD>
  </TR>
  <TR>
    <TD height="19">Member</TD>
    <TD height="19" align="center"><tt><font color="#0000FF">in</font></tt></TD>
  </TR>
  <TR>
    <TD height="19">Not_Member</TD>
    <TD height="19" align="center"><tt><font color="#0000FF">not&nbsp;in</font></tt></TD>
  </TR>
  <TR>
    <TD height="19">Add</TD>
    <TD height="19" align="center"><tt>+</tt></TD>
    <TD rowspan="3" height="73" valign="top">Binary adding operators (<a href="http://www.adaic.com/standards/05rm/html/RM-4-5-3.html">4.5.3</a>). 
    The operators <tt>+</tt> and <tt>-</tt> are declared commutative with the 
    group inverse Add_Inv. The infix adding operators have the priority level 4.</TD>
  </TR>
  <TR>
    <TD height="19">Sub</TD>
    <TD height="19" align="center"><tt>-</tt></TD>
  </TR>
  <TR>
    <TD height="19">Concatenate</TD>
    <TD height="19" align="center"><tt>&amp;</tt></TD>
  </TR>
  <TR>
    <TD height="19">Plus</TD>
    <TD height="19" align="center"><tt>+</tt></TD>
    <TD rowspan="2" height="46" valign="top">Unary adding operators (<a href="http://www.adaic.com/standards/05rm/html/RM-4-5-4.html">4.5.4</a>). 
    Association checks prevent multiple unary operations association with 
    themselves, adding, multiplying and highest precedence operators. The 
    priority level is 5.</TD>
  </TR>
  <TR>
    <TD height="19">Minus</TD>
    <TD height="19" align="center"><tt>-</tt></TD>
  </TR>
  <TR>
    <TD height="19">Mul</TD>
    <TD height="19" align="center"><tt>*</tt></TD>
    <TD rowspan="4" height="100" valign="top">Multiplying operators (<a href="http://www.adaic.com/standards/05rm/html/RM-4-5-5.html">4.5.5</a>). 
    The operators <tt>*</tt> and <tt>/</tt> are declared commutative with the 
    group inverse Mul_Inv.&nbsp; The priority level is 6.</TD>
  </TR>
  <TR>
    <TD height="19">Div</TD>
    <TD height="19" align="center"><tt>/</tt></TD>
  </TR>
  <TR>
    <TD height="19">Modulus</TD>
    <TD height="19" align="center"><tt><font color="#0000FF">mod</font></tt></TD>
  </TR>
  <TR>
    <TD height="19">Remainder </TD>
    <TD height="19" align="center"><tt><font color="#0000FF">rem</font></tt></TD>
  </TR>
  <TR>
    <TD height="19">Pow</TD>
    <TD height="19" align="center"><tt>**</tt></TD>
    <TD rowspan="3" height="73" valign="top">Highest precedence operators (<a href="http://www.adaic.com/standards/05rm/html/RM-4-5-6.html">4.5.6</a>). 
    These cannot be associated with themselves. They have the priority 7.</TD>
  </TR>
  <TR>
    <TD height="19">Abs_Value</TD>
    <TD height="19" align="center"><tt><font color="#0000FF">abs</font></tt></TD>
  </TR>
  <tr>
    <TD height="19">Logical_Not</TD>
    <TD height="19" align="center"><tt><font color="#0000FF">not</font></tt></TD>
  </tr>
  <TR>
    <TD height="17">Allocator</TD>
    <TD height="17" align="center"><tt><font color="#0000FF">new</font></tt></TD>
    <TD height="17" valign="top">Allocator (<a href="http://www.adaic.com/standards/05rm/html/RM-4-8.html">4.8</a>). An allocator is treated as a prefix 
    operator&nbsp;with priority 8.</TD>
  </TR>
  <TR>
    <TD height="19">Attribute</TD>
    <TD height="19" align="center"><tt>'</tt></TD>
    <TD height="19" valign="top">Attribute is treated as an infix operator with 
    the priority 9.</TD>
  </TR>
  <TR>
    <TD height="19">Alternative</TD>
    <TD height="19" align="center"><tt>|</tt></TD>
    <TD height="19" valign="top">Separates choices in aggregates, treated as an infix 
    operator. The operator is defined commutative to keep lists of alternatives 
    whole. The operator has the priority 0.</TD>
  </TR>
  <TR>
    <TD height="19">Ellipsis</TD>
    <TD height="19" align="center"><tt>..</tt></TD>
    <TD height="19" valign="top">Used in slices (<a href="http://www.adaic.com/standards/05rm/html/RM-4-1-2.html">4.1.2</a>), treated as an infix operator 
    with the priority 1.</TD>
  </TR>
  <TR>
    <TD height="19">Component </TD>
    <TD height="19" align="center"><tt>.</tt></TD>
    <TD height="19" valign="top">Component selector (<a href="http://www.adaic.com/standards/05rm/html/RM-4-1-3.html">4.1.3</a>), treated as an infix 
    operator. The operator is defined commutative to merge nested component 
    selectors in one list.</TD>
  </TR>
  <TR>
    <TD height="19">Left_Bracket</TD>
    <TD height="19" align="center"><tt>(</tt></TD>
    <TD height="19" valign="top">Order and aggregate brackets (<a href="http://www.adaic.com/standards/05rm/html/RM-4-3.html">4.3</a>)</TD>
  </TR>
  <TR>
    <TD height="19">Left_Index</TD>
    <TD height="19" align="center"><tt>(</tt></TD>
    <TD height="19" valign="top">Indexed components (<a href="http://www.adaic.com/standards/05rm/html/RM-4-1-1.html">4.1.1</a>) and function calls (<a href="http://www.adaic.com/standards/05rm/html/RM-6-4.html">6.4</a>). 
    It has the left priority 9, lower than one of component selector and same as 
    one of attributes.</TD>
  </TR>
  <TR>
    <TD height="19">Right_Bracket</TD>
    <TD height="19" align="center"><tt>)</tt></TD>
    <TD height="19" valign="top">Right bracket</TD>
  </TR>
  <TR>
    <TD height="19">Comma</TD>
    <TD height="19" align="center"><tt>,</tt></TD>
    <TD height="19" valign="top">In brackets of all sorts</TD>
  </TR>
  <TR>
    <TD height="19">Associate </TD>
    <TD height="19" align="center"><tt>=&gt;</tt></TD>
    <TD height="19" valign="top">Named association, treated as a ligature</TD>
  </TR>
  <TR>
    <TD height="19">Extend</TD>
    <TD height="19" align="center"><tt><font color="#0000FF">with</font></tt></TD>
    <TD height="19" valign="top">Extension aggregate separator, treated as a semicolon 
    introducing a sublist</TD>
  </TR>
</TABLE>
<p>The identifiers are not checked against the reserved keywords. That can be
done on 
later stages when necessary. Similarly the attributes names can be any 
expressions. The association checks can be relaxed by overriding corresponding 
error handlers. One might also wish to override the handlers to provide a more 
advanced error messaging mechanism than exception information.</p>
<p>The package defines the type Node a tagged abstract base type of all parsing 
tree nodes:</p>
<blockquote>
<p><tt><font color="#0000FF">type</font> Node<font color="#0000FF"> is abstract 
tagged limited null record</font>;<br>
<font color="#0000FF">function</font> Image (Item : Node) <font color="#0000FF">
return</font> String <font color="#0000FF">is abstract</font>;<br>
<font color="#0000FF">type</font> Node_Ptr <font color="#0000FF">is access</font> 
Node'Class;<br>
<font color="#0000FF">for</font> Node_Ptr'Storage_Pool <font color="#0000FF">use</font> 
Tree_Pool;</tt></p>
</blockquote>
<p>The nodes of the tree are allocated on a stack. The stack is 
provided by a stack pool. This allows to remove the whole tree by deallocating 
its first allocated node or any other pool object allocated before it. Tree_Pool 
is the stack storage pool used for this. Nodes have the primitive operation 
Image used for dumping a parsing tree. The following concrete types are derived
from Node:</p>
<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080" height="19"><FONT color="#FFFFFF"><B>Parsing tree 
    nodes</B></FONT></TD>
    <TD bgcolor="#008080" height="19" align="left">
    <font color="#FFFFFF"><b>Comment</b></font></TD>
  </TR>
  <tr>
    <TD height="19">Character_Literal</TD>
    <TD height="19" align="left">Character expression term</TD>
  </tr>
  <tr>
    <TD height="19">Expression</TD>
    <TD height="19" align="left">An non-terminal node. The dicriminant Count 
    identifies the number of successors. The field Operation is the operation 
    associated with the node. The field Operands is the list of successors.</TD>
  </tr>
  <tr>
    <TD height="19">Identifier</TD>
    <TD height="19" align="left">Identifier expression term</TD>
  </tr>
  <tr>
    <TD height="19">Integer_Literal</TD>
    <TD height="19" align="left">Universal_Integer expression term</TD>
  </tr>
  <TR>
    <TD height="19">Mark</TD>
    <TD height="19" align="left">Used as a stub for the stack pool to mark its 
    state for future stack release</TD>
  </TR>
  <TR>
    <TD height="19">Missing_Operand</TD>
    <TD height="19" align="left">An expression term used where no operand was 
    found</TD>
  </TR>
  <TR>
    <TD height="19">Real_Literal</TD>
    <TD height="19" align="left">Universal_Real expression term</TD>
  </TR>
  <TR>
    <TD height="19">String_Literal</TD>
    <TD height="19" align="left">String expression term</TD>
  </TR>
</TABLE>
<p>All expression nodes have the field Location specifying its source location.</p>
<hr>
<p align="right">
<a name="12"></a><a href="#11.9"><IMG src="prev.gif" alt="[Back]" width="29" height="29"></a><A href="#16"><IMG src="index.gif"
 alt="[TOC]" width="29" height="29"></A><a href="#12.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H2>12. <a name="Cryptography"></a>Cryptography</H2>
<p align="right">
  <A name="12.1"></A><a href="#12"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#12.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>12.1. Sequences of non-repeating pseudo-random number</H3>
<p><a name="Generic_Random_Sequence"></a>The package
<a href="#Generic_Random_Sequence">Generic_Random_Sequence</a> provides means 
for generation of pseudo-random sequences of non-repeating numbers. The package 
is generic:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Item_Type <font color="#0000FF">is mod</font> &lt;&gt;;<br>
<font color="#0000FF">package</font> Generic_Random_Sequence
<font color="#0000FF">is</font> ...</tt></p>
</blockquote>
<p>The generic parameter Item_Type is a modular subtype which base type is used 
for the sequence items. The package declares it as:</p>
<blockquote>
<p><tt><font color="#0000FF">subtype </font>Element<font color="#0000FF"> is
</font>Item_Type'Base;</tt></p>
</blockquote>
<p>The sequence items ignore any constrains the subtype Item_Type might have.</p>
<blockquote>
<p><tt><font color="#0000FF">type </font>Sequence<font color="#0000FF"> is 
limited private</font>;</tt></p>
</blockquote>
<p>This is the type of a sequence of non-repeating items of Element. </p>
<table border="1" cellspacing="0" cellpadding="5">
	<tr>
		<td>Note that the implementation requires O(<i>m</i>) memory where <i>
		m</i> is the modulus of Element. For this reason it is not recommended 
		to instantiate this package with large modular types. </td>
	</tr>
</table>
<p>The following subprograms are provided:</p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Generic_Random_Sequence.Length"></a>function </font>Length (<b>Sequencer</b> : 
Sequence) <font color="#0000FF">return</font> Element;</tt></p>
</blockquote>
<p>This function returns the number of elements already generated by <b>
Sequencer</b>. The sequence wraps at Element'Last. That is when Element'Modulus 
items were generated. This function can be used in order to check whether a call 
to <a href="#Generic_Random_Sequence.Next">Next</a> would yield an unique item. 
When the result is 0, <a href="#Generic_Random_Sequence.Next">Next</a> will 
start to return repeating items. </p>
<blockquote>
<p><tt><font color="#0000FF"><a name="Generic_Random_Sequence.Next"></a>function</font> 
Next (<b>Sequencer</b> : Sequence; <b>Dice</b> : Element)<br>
&nbsp;<font color="#0000FF">&nbsp; return</font> Element;</tt></p>
</blockquote>
<p>This function returns the next sequence item. The parameter <b>Dice</b> is an 
input used in order to randomize the sequence. When <b>Dice</b> is 0 then 
consequent calls to <b>Next</b> will return the sequence of 0,1,2,3,... of 
Element. Typically <b>Dice</b> is an output of some pseudo-random generator of 
Element (or Item_Type'Base). In this case the sequence becomes pseudo-random as 
well. One can also use the parameter <b>Dice</b> for block cipher operation 
modes such as chaining and feedback. The first Element'Modulus items returned by 
the function are non-repeating. After that the next Element'Modulus items do not 
repeat more than once. I.e. in each cycle of Element'Modulus items no item 
repeats. The order in which items repeat depends on <b>Dice</b>. Note that even 
if <b>Dice</b> has a cycle of Element'Modulus outputs, that does not necessary 
imply sequence repetition.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Next<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp; <b>Sequencer</b> 
: <font color="#0000FF">in out</font> Sequence;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Dice</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Element;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Item</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: <font color="#0000FF">out</font> Element<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt></p>
</blockquote>
<p>This is a variant of the function above shaped as a procedure.</p>
<blockquote>
<p><tt><font color="#0000FF">procedure</font> Start (<b>Sequencer</b> :
<font color="#0000FF">in out</font> Sequence);</tt></p>
</blockquote>
<p>This procedure starts a new sequence. It resets <b>Sequencer</b> to its initial 
state, so that the first consequent call to
<a href="#Generic_Random_Sequence.Next">Next</a> will yield exactly the same 
item as it did first time, provided that the <b>Dice</b> parameter is same, and 
that a call to <a href="#Generic_Random_Sequence.Length">Length</a> will yield 
0.</p>
<p align="right">
  <A name="12.2"></A><a href="#12.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#13"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>12.1. Symmetric serialization</H3>
<p><a name="Strings_Edit.Symmetric_Serialization"></a>The package
<a href="#Strings_Edit.Symmetric_Serialization">
Strings_Edit.Symmetric_Serialization</a> provides a simple symmetric encryption 
and encoding for serializing plain strings. The main objective is saving 
and transporting user credentials in a mangled format. Note that this should be 
used only when deploying stronger asymmetric methods were 
impossible. For example when it is necessary to store user password as a string 
with an ability to restore it back. The encoding uses a 64-bit alphabet of 
digits, letters and characters '_' and '~'. Typically the key used for encryption 
is 
derived from the application name, registered user name etc. The package defines 
the following subtype:</p>
<blockquote>
<p><tt><font color="#0000FF">subtype</font> Encoded_String <font color="#0000FF">
is </font>String (<font color="#1100000">1</font>..<i>implementation-defined</i>);</tt></p>
</blockquote>
<p>Objects of this subtype are encoded encrypted strings. The length is fixed because the 
source string is always padded to 256 characters.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Decode (<b>Data</b> : 
Encoded_String; <b>Key</b> : String)<br>
&nbsp;<font color="#0000FF">&nbsp; return</font> String;</tt></p>
</blockquote>
<p>This function decodes and decrypts a string. The parameter <b>Data</b> is the 
input. The parameter <b>Key</b> is the key used while encryption. The exception 
Data_Error is propagated when <b>Data</b> contains invalid characters.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Encode (<b>Text</b> : String; <b>
Key</b> : String)<br>
&nbsp;&nbsp; <font color="#0000FF">return</font> Encoded_String;</tt></p>
</blockquote>
<p>This function encrypts and encodes <b>Text</b>. The parameter <b>Key</b> is 
the key used for encryption. The exception Constraint_Error is propagated when
<b>Text</b> is longer than 256 characters.</p>
<hr>
<p align="right">
<a name="13"></a><a href="#12.2"><IMG src="prev.gif" alt="[Back]" width="29" height="29"></a><A href="#16"><IMG src="index.gif"
 alt="[TOC]" width="29" height="29"></A><a href="#13.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H2>13. Numerics</H2>
<p align="right">
  <A name="13.1"></A><a href="#13"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#14"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>13.1. IEEE 754 representations</H3>
<p> <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
is a widely used standard for floating-point numbers computation&nbsp; The 
floating-point numeric types defined by the Ada language are not necessarily <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a>. 
The choice depends on the target platform's hardware. Nevertheless an Ada 
program may need <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
numbers when it deals with the I/O devices, network protocols, and software 
libraries using <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a>.</p>
<p> The library provides support for conversions between any Ada 
floating-point type and <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
representations. It is designed to work with the machine representations 
different from <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a>, 
including those with non-binary machine radix. Note that it is not intended for 
computations in <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
representations. When numeric computations are required a corresponding native 
Ada floating-point type should be used.</p>
<p><a name="IEEE_754"></a>The package
<a href="#IEEE_754">IEEE_754</a> is the parent of several children packages 
provided for handling <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
floating-point numbers. The package declares:</p>
<blockquote>
<p><tt><font color="#0000FF">subtype </font>Byte<font color="#0000FF"> is </font>
Interfaces.Unsigned_8;</tt></p>
</blockquote>
<p>The type Byte represents one byte of an
<a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> floating-number data 
layout. It also declares the following exceptions:</p>
<blockquote>
<p><tt>Not_A_Number_Error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">
exception</font>;<br>
Positive_Overflow_Error : <font color="#0000FF">exception</font>;<br>
Negative_Overflow_Error : <font color="#0000FF">exception</font>;</tt></p>
</blockquote>
<h4>13.1.1. Single precision 32-bit floating-point numbers</h4>
<p><a name="IEEE_754.Generic_Single_Precision"></a>The generic child package
<a href="#IEEE_754.Generic_Single_Precision">IEEE_754.Generic_Single_Precision</a> 
provides single precision 32-bit floating point numbers. The package is generic:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Number<font color="#0000FF"> is digits</font> &lt;&gt;;<font color="#0000FF"><br>
package </font>IEEE_754.Generic_Single_Precision<font color="#0000FF"> is </font>
...</tt></p>
</blockquote>
<p>The formal parameter Number is the Ada floating-point type to use with the 
package. The type of the <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
numbers is:</p>
<blockquote>
<p><tt><font color="#0000FF">type </font>Float_32<font color="#0000FF"> is array </font>
(1..4) <font color="#0000FF">of</font> Byte;</tt></p>
</blockquote>
<p>The values of the type are 32-bit single-precision 
<a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> floating-point 
numbers .The memory layout of encoding is big endian, i.e. the byte containing 
the number's sign and the most significant bits of the exponent is the first 
array element. The byte containing the least significant bits of the mantissa is 
the last array element. The following operations are defined in the package:</p>
<blockquote>
<p><tt><font color="#0000FF">function </font>From_IEEE (<b>Value</b> : Float_32)<font color="#0000FF"> 
return</font> Number;</tt></p>
</blockquote>
<p>This function converts <b>Value</b> to the corresponding Ada floating-point 
type. Negative zero is converted to zero. An exception is propagated when <b>
Value</b> is not a number or else cannot be converted to Number.</p>

<TABLE border="5" cellpadding="3" cellspacing="0">
  <CAPTION align="top">
    <I>Exceptions</I></CAPTION>
  <TR>
    <TD valign="top">Negative_Overflow_Error</TD>
    <TD> <b>Value</b> is less than Number'First or else is a negative infinity</TD>
  </TR>
  <tr>
    <TD valign="top">Not_A_Number_Error</TD>
    <TD> <b>Value</b> is not a number (NaN)</TD>
  </tr>
  <TR>
    <TD valign="top">Positive_Overflow_Error</TD>
    <TD> <b>Value</b> is greater than Number'Last or else is a positive infinity</TD>
  </TR>
</TABLE>

<blockquote>
<p><tt><font color="#0000FF">function </font>Is_NaN (<b>Value</b> : Float_32)<font color="#0000FF"> 
return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <font color="#800000"><i>true</i></font> if <b>Value</b> 
is an
<a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> NaN (not a number).</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Negative (<b>Value</b> : 
Float_32)<font color="#0000FF"> return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <font color="#800000"><i>true</i></font> if <b>Value</b> 
is an
<a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> negative, Note that
<a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> has negative zeros.</p>
<blockquote>
<p><tt><font color="#0000FF">function</font> Is_Real (<b>Value</b> : Float_32)<font color="#0000FF"> 
return</font> Boolean;</tt></p>
</blockquote>
<p>This function returns <font color="#800000"><i>true</i></font> if <b>Value</b> 
represents a real number. Both <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
zeros are considered numbers.</p>

<blockquote>
<p><tt><font color="#0000FF">function </font>To_IEEE (<b>Value</b> : Number)<font color="#0000FF"> 
return</font> Float_32;</tt></p>
</blockquote>
<p>This function converts Ada floating-point number to the corresponding
<a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> number. The result 
can be an infinity if the value cannot be represented otherwise.</p>

<blockquote>
<p><tt>Positive_Infinity : <font color="#0000FF">constant</font> Float_32;<br>
Positive_Zero&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">constant</font> 
Float_32;<br>
Negative_Infinity : <font color="#0000FF">constant</font> Float_32;<br>
Negative_Zero&nbsp;&nbsp;&nbsp;&nbsp; : <font color="#0000FF">constant</font> 
Float_32;</tt></p>
</blockquote>
<p>These constants define some special
<a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> representations.</p>
<p><a name="IEEE_754.Floats"></a>The package <a href="#IEEE_754.Floats">IEEE_754.Floats</a> is an instantiation of 
<a href="#IEEE_754.Generic_Single_Precision">IEEE_754.Generic_Single_Precision</a> 
with the standard type Float.</p>
<h4>13.1.2. Double precision 64-bit floating-point numbers</h4>
<p><a name="IEEE_754.Generic_Double_Precision"></a>The generic child package
<a href="#IEEE_754.Generic_Double_Precision">IEEE_754.Generic_Double_Precision</a> 
provides single precision 64-bit floating point numbers. The package is generic:</p>
<blockquote>
<p><tt><font color="#0000FF">generic<br>
&nbsp;&nbsp; type </font>Number<font color="#0000FF"> is digits</font> &lt;&gt;;<font color="#0000FF"><br>
package </font>IEEE_754.Generic_Double_Precision<font color="#0000FF"> is </font>
...</tt></p>
</blockquote>
<p>The formal parameter Number is the Ada floating-point type to use with the 
package. The type of the <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
numbers is:</p>
<blockquote>
<p><tt><font color="#0000FF">type </font>Float_64<font color="#0000FF"> is array </font>
(1..8) <font color="#0000FF">of</font> Byte;</tt></p>
</blockquote>
<p>The memory layout of Float_64 is big endian. The rest of the package is 
identical to
<a href="#IEEE_754.Generic_Single_Precision">IEEE_754.Generic_Single_Precision</a> 
with Float_64 used instead of Float_32.</p>
<p><a name="IEEE_754.Long_Floats"></a>The package 
<a href="#IEEE_754.Long_Floats">IEEE_754.Long_Floats</a> is an instantiation of
<a href="#IEEE_754.Generic_Double_Precision">IEEE_754.Generic_Double_Precision</a> 
with the standard type Long_Float.</p>
<hr>
<p align="right">
<a name="14"></a><a href="#13.1"><IMG src="prev.gif" alt="[Back]" width="29" height="29"></a><A href="#16"><IMG src="index.gif"
 alt="[TOC]" width="29" height="29"></A><a href="#14.1"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H2>14. Packages</H2>
<p>The root directory contains only the packages required for software use.
Tests and examples are located in the subdirectory <i>test</i>.</p>
<p align="right">
  <A name="14.1"></A><a href="#14"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#14.2"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>14.1. Source packages</H3>
<p>The following table describes the packages provided by the software.</p>
<TABLE border="5" cellpadding="3" cellspacing="0" style="border-left-width: 0px">
  <TR>
    <TD bgcolor="#008080" colspan="6"><FONT color="#FFFFFF"><B>Package</B></FONT></TD>
    <TD bgcolor="#008080"><FONT color="#FFFFFF"><B>Provides</B></FONT></TD>
  </TR>
  <tr>
    <TD colspan="6" bgcolor="#C0C0C0">APQ</TD>
    <TD>Implementation packages used for <a href="#Persistent.APQ">Persistent.APQ</a></TD>
  </tr>
  <tr>
    <TD colspan="4" rowspan="4" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="2">Common</TD>
    <TD>Thicker bindings to the APQ abstracting away data base specific details</TD>
  </tr>
  <tr>
    <TD colspan="2">Keys</TD>
    <TD>Persistent objects identification in APQ</TD>
  </tr>
  <tr>
    <TD bgcolor="#C0C0C0" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD>Sets</TD>
    <TD>Sets of persistent objects keys</TD>
  </tr>
  <tr>
    <TD colspan="2">Links</TD>
    <TD>Management of persistent objects dependencies in APQ</TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Deposit_Handles">Deposit_Handles</a></TD>
    <TD>An instantiation of <a href="#Object.Archived.Handle">
    Object.Archived.Handle</a></TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Generic_Doubly_Linked_Web">
	Generic_Doubly_Linked_Web</a></TD>
    <TD>Networks of doubly-linked items with referential semantics.</TD>
  </tr>
  <tr>
    <TD colspan="3" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="3"><a href="#Generic_Doubly_Linked_Web.Generic_List">
	Generic_List</a></TD>
    <TD>A specialized list view of a network</TD>
  </tr>
  <tr>
    <TD colspan="6"> <a href="#Generic_Blackboard">Generic_Blackboard</a></TD>
    <TD>One-to-many lock-free generic blackboard</TD>
  </tr>
  <tr>
    <TD colspan="3" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="3"><a href="#Generic_Blackboard.Generic_Task_Safe">Generic_Task_Safe</a></TD>
    <TD>Many-to-many generic blackboard with lock-free read access</TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Generic_Doubly_Linked">Generic_Doubly_Linked</a></TD>
    <TD>Doubly-linked lists of items with referential semantics</TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Generic_FIFO">Generic_FIFO</a></TD>
    <TD>Peer-to-peer lock-free first in, first out generic queue</TD>
  </tr>
  <tr>
    <TD colspan="3" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="3"><a href="#Generic_FIFO.Signaled_FIFO">Generic_Signaled</a></TD>
    <TD>Peer-to-peer almost lock-free first in, first out generic queue</TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Generic_Indefinite_FIFO">Generic_Indefinite_FIFO</a></TD>
    <TD>Peer-to-peer lock-free first in, first out generic queue of indefinite 
	objects</TD>
  </tr>
	<tr>
    <TD colspan="3" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="3"><a href="#Generic_Indefinite_FIFO.Signaled_FIFO">Generic_Signaled</a></TD>
    <TD>Peer-to-peer almost lock-free first in, first out generic queue of 
	indefinite objects</TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Generic_Map">Generic_Map</a></TD>
    <TD>The type <a href="#Map">Map</a></TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Generic_Random_Sequence">Generic_Random_Sequence</a></TD>
    <TD>Random sequences of non-repeating items</TD>
  </tr>
  <TR>
    <TD colspan="6"><a href="#Generic_Set">Generic_Set</a></TD>
    <TD>The type <a href="#Set">Set</a></TD>
  </TR>
  <TR>
    <TD colspan="6"><a href="#Generic_Stack">Generic_Stack</a></TD>
    <TD>The type <a href="#Stack">Stack</a>, a generic stack</TD>
  </TR>
  <TR>
    <TD colspan="6"> <a href="#Generic_Segmented_Stack">Generic_Segmented_Stack</a></TD>
    <TD>Stacks built of segments of same size (generic)</TD>
  </TR>
  <tr>
    <TD colspan="6"><a href="#Generic_Unbounded_Array">Generic_Unbounded_Array</a></TD>
    <TD>The type <a href="#Unbounded_Array">Unbounded_Array</a> and operations 
	on it</TD>
  </tr>
	<tr>
    <TD colspan="6"><a href="#Generic_Unbounded_Ptr_Array">
	Generic_Unbounded_Ptr_Array</a></TD>
    <TD>The type <a href="#Unbounded_Ptr_Array">Unbounded_Ptr_Array</a></TD>
  </tr>
  <tr>
    <TD colspan="6">GNU.DB.CLI.API</TD>
    <TD>Thick bindings to GNADE ODBC</TD>
  </tr>
  <tr>
    <TD colspan="4" rowspan="4" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="2">Keys</TD>
    <TD>Persistent objects identification in ODBC</TD>
  </tr>
  <tr>
    <TD rowspan="2" bgcolor="#C0C0C0" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD>Edit</TD>
    <TD>String conversions for objects keys</TD>
  </tr>
  <tr>
    <TD>Sets</TD>
    <TD>Sets of persistent objects keys for ODBC</TD>
  </tr>
  <tr>
    <TD colspan="2">Links</TD>
    <TD>Management of persistent objects dependencies in ODBC</TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#IEEE_754">IEEE_754</a></TD>
    <TD>The parent package for dealing with <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
	representations</TD>
  </tr>
  <tr>
    <TD colspan="3" rowspan="4" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="3"><a href="#IEEE_754.Floats">Floats</a></TD>
    <TD>An instance of <a href="#IEEE_754.Generic_Double_Precision">IEEE_754.Generic_Double_Precision</a> 
	with Float</TD>
  </tr>
  <tr>
    <TD colspan="3"><a href="#IEEE_754.Generic_Double_Precision">Generic_Double_Precision</a></TD>
    <TD>64-bit double precision <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
	floating-point representations</TD>
  </tr>
  <tr>
    <TD colspan="3"><a href="#IEEE_754.Generic_Single_Precision">Generic_Single_Precision</a></TD>
    <TD>32-bit single precision <a href="http://grouper.ieee.org/groups/754/">IEEE 754</a> 
	floating-point representations</TD>
  </tr>
  <tr>
    <TD colspan="3"><a href="#IEEE_754.Long_Floats">Long_Floats</a></TD>
    <TD>An instance of <a href="#IEEE_754.Generic_Double_Precision">IEEE_754.Generic_Double_Precision</a> 
	with Long_Float</TD>
  </tr>
  <tr>
    <TD colspan="6"><a href="#Object">Object</a></TD>
    <TD>The type <a href="#Entity">Entity</a></TD>
  </tr>
  <tr>
    <TD rowspan="10" bgcolor="#C0C0C0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD colspan="5"><a href="#Object.Archived">Archived</a></TD>
    <TD>The types <a href="#Deposit">Deposit</a>, <a href="#Backward_Link">
    Backward_Link</a> and <a href="#Deposit_Container">Deposit_Container</a> for 
    handling persistency</TD>
  </tr>
  <tr>
    <TD rowspan="4" bgcolor="#C0C0C0" colspan="4" style="border-left-style: none; border-left-width: medium">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD><a href="#Object.Archived.Handle">Handle</a></TD>
    <TD>The type <a href="#Object.Archived.Handle.Handle">Handle</a> (to 
    persistent objects) and operations on it. The package is generic</TD>
  </tr>
  <tr>
    <TD><a href="#Object.Archived.Iterators">Iterators</a></TD>
    <TD>The type <a href="#References_Iterator">References_Iterator</a>, an 
    iterator of object's references</TD>
  </tr>
  <tr>
    <TD><a href="#Object.Archived.Lists">Lists</a></TD>
    <TD>The type <a href="#Deposit_List">Deposit_List</a>, a list of persistent 
    objects</TD>
  </tr>
  <tr>
    <TD><a href="#Object.Archived.Sets">Sets</a></TD>
    <TD>The type <a href="#Deposit_Set">Deposit_Set</a>, a set of persistent 
    objects</TD>
  </tr>
  <tr>
    <TD colspan="5"><a href="#Object.Handle">Handle</a></TD>
    <TD>The type <a href="#Handle">Handle</a> and operations on it</TD>
  </tr>
  <tr>
    <TD rowspan="4" bgcolor="#C0C0C0" colspan="4" style="border-left-style: none; border-left-width: medium">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
    <TD><a href="#Object.Handle.Generic_Bounded_Array">
    Generic_Bounded_Array</a></TD>
    <TD>The type <a href="#Bounded_Array">Bounded_Array</a>, a generic bounded array of 
    objects</TD>
  </tr>
  <tr>
    <TD><a href="#Object.Handle.Generic_Handle_Set">Generic_Handle_Set</a></TD>
    <TD>The type <a href="#Object.Handle.Generic_Set.Set">Set</a>, a generic set of 
    objects</TD>
  </tr>
  <tr>
    <TD><a href="#Object.Handle.Generic_Set">Generic_Set</a></TD>
    <TD>The type <a href="#Object.Handle.Generic_Set.Set">Set</a>, a generic set of 
    objects</TD>
  </tr>
  <tr>
    <TD><a href="#Object.Handle.Generic_Unbounded_Array">
    Generic_Unbounded_Array</a></TD>
    <TD>The type <a href="#Unbounded_Array">Unbounded_Array</a>, a generic unbounded 
    array of objects</TD>
  </tr>
  <TR>
    <TD colspan="6"> <a href="#Parsers">Parsers</a></TD>
    <TD>The base package of syntax analyzers</TD>
  </TR>
  <TR>
    <TD rowspan="27" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="5"><a href="#Parsers.Ada">Ada</a></TD>
    <TD>The type Ada_Expression, an implementation of Ada 95 expression parser</TD>
  </TR>
  <TR>
    <TD colspan="5"><a href="#Parsers.Generic_Argument">Generic_Argument</a></TD>
    <TD>The type <a href="#Parsers.Generic_Argument.Stack">Stack</a>, the 
    abstract base for argument stacks (generic)</TD>
  </TR>
  <TR>
    <TD bgcolor="#C0C0C0" colspan="4" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD> <a href="#Parsers.Generic_Argument.Segmented_Stack">
    Segmented_Stack</a></TD>
    <TD>An implementation of argument stacks based on segmented stacks</TD>
  </TR>
  <TR>
    <TD colspan="5">
<a href="#Parsers.Generic_Lexer">Generic_Lexer</a></TD>
    <TD>The type <a href="#Parsers.Generic_Lexer.Lexer">Lexer</a>, the abstract 
    base for expression analyzers (generic)</TD>
  </TR>
  <TR>
    <TD rowspan="3" bgcolor="#C0C0C0" colspan="4" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD>
<a href="#Parsers.Generic_Lexer.Ada_Blanks">
    Ada_Blanks</a></TD>
    <TD>An analyzer supporting Ada 95 comments and blanks</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Lexer.Blanks">
    Blanks</a></TD>
    <TD>An analyzer supporting blanks of spaces and formatting characters HT, 
    LF, CR, VT, FF</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Lexer.Cpp_Blanks">Cpp_Blanks</a></TD>
    <TD>An analyzer supporting C++ comments and blanks</TD>
  </TR>
  <TR>
    <TD colspan="5">
<a href="#Parsers.Generic_Operation">Generic_Operation</a></TD>
    <TD>The expression operations and their descriptors (generic)</TD>
  </TR>
  <TR>
    <TD rowspan="2" bgcolor="#C0C0C0" colspan="4" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD> <a href="#Parsers.Generic_Operation.Generic_Stack">Generic_Stack</a></TD>
    <TD>The type <a href="#Parsers.Generic_Operation.Generic_Stack.Stack">Stack</a>, 
    the abstract base of operation stacks</TD>
  </TR>
  <TR>
    <TD> <a href="#Parsers.Generic_Operation.Segmented_Stack">
    Segmented_Stack</a></TD>
    <TD>An implementation of operation stacks based on segmented stacks</TD>
  </TR>
  <TR>
    <TD colspan="5">
<a href="#Parsers.Generic_Source">Generic_Source</a></TD>
    <TD>An abstract interface of code source (generic)</TD>
  </TR>
  <TR>
    <TD bgcolor="#C0C0C0" colspan="4" rowspan="8" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD>
<a href="#Parsers.Generic_Source.Get_Ada_Blank">Get_Ada_Blank</a></TD>
    <TD>Matching an Ada comment (generic procedure)</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Source.Get_Blank">Get_Blank</a></TD>
    <TD>Matching blank characters (generic procedure)</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Source.Get_Cpp_Blank">Get_Cpp_Blank</a></TD>
    <TD>Matching an C++ comment (generic procedure)</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Source.Get_Text">Get_Text</a></TD>
    <TD>Matching a text in the code source (generic procedure)</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Source.Get_Token">Get_Token</a></TD>
    <TD>Matching a table against the code source (generic procedure)</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Source.Keywords">Keywords</a></TD>
    <TD>Keyword-matching generated from an enumeration type (generic)&nbsp;</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Source.Text_IO">Text_IO</a></TD>
    <TD>Debugging output for source code cursors</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Source.XPM">XPM</a></TD>
    <TD>Matching XPM image format (generic package)</TD>
  </TR>
  <TR>
    <TD colspan="5"> <a href="#Parsers.Generic_Token">Generic_Token</a></TD>
    <TD>The table tokens for table-driven analyzers (generic)</TD>
  </TR>
  <TR>
    <TD rowspan="2" bgcolor="#C0C0C0" colspan="4" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD>
<a href="#Parsers.Generic_Token.Generic_Token_Lexer">
    Generic_Token_Lexer</a></TD>
    <TD>The type <a href="#Parsers.Generic_Token.Generic_Token_Lexer.Lexer">
    Lexer</a>, the abstract base for table-driven analyzers</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Generic_Token.Segmented_Lexer">
    Segmented_Lexer</a></TD>
    <TD>An implementation of table-driven analyzers based on segmented argument 
    and operation stacks</TD>
  </TR>
  <TR>
    <TD colspan="5">
<a href="#Parsers.Multiline_Source">Multiline_Source</a></TD>
    <TD>The type <a href="#Parsers.Multiline_Source.Source">Source</a>, the 
    abstract base for sources having multiple lines of code</TD>
  </TR>
  <TR>
    <TD bgcolor="#C0C0C0" colspan="4" style="border-left-style: none; border-left-width: medium" rowspan="3">&nbsp;</TD>
    <TD>
<a href="#Parsers.Multiline_Source.Standard_Input">Standard_Input</a></TD>
    <TD>The type <a href="#Parsers.Multiline_Source.Standard_Input.Source">Source</a>, 
    a code source based on Ada.Text_IO</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Multiline_Source.Text_IO">Text_IO</a></TD>
    <TD>The type <a href="#Parsers.Multiline_Source.Text_IO.Source">Source</a>, 
    a code source based on Ada.Text_IO</TD>
  </TR>
  <TR>
    <TD>
<a href="#Parsers.Multiline_Source.XPM">XPM</a></TD>
    <TD>An instance of <a href="#Parsers.Generic_Source.XPM">
	Parsers.Generic_Source.XPM</a> based on
<a href="#Parsers.Multiline_Source">Multiline_Source</a></TD>
  </TR>
  <TR>
    <TD colspan="5">
<a href="#Parsers.String_Source">String_Source</a></TD>
    <TD>The type <a href="#Parsers.String_Source.Source">Source</a>, a single 
    string code source</TD>
  </TR>
  <TR>
    <TD colspan="6"><a href="#Persistent">Persistent</a></TD>
    <TD>Abstract persistent storage interface</TD>
  </TR>
  <TR>
    <TD colspan="4" rowspan="9" bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="2"><a href="#Persistent.APQ">APQ</a></TD>
    <TD>APQ implementation of persistent storage</TD>
  </TR>
  <TR>
    <TD colspan="2"><a href="#Persistent.Directory">Directory</a></TD>
    <TD>Persistent directory objects</TD>
  </TR>
  <TR>
    <TD colspan="2"><a href="#Persistent.Data_Bank">Data_Bank</a></TD>
    <TD>Abstract persistent storage with objects identified by keys</TD>
  </TR>
  <TR>
    <TD rowspan="3" bgcolor="#C0C0C0" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD><a href="#Persistent.Data_Bank.Index">Index</a></TD>
    <TD>Index for an abstract persistent storage</TD>
  </TR>
  <TR>
    <TD><a href="#Persistent.Data_Bank.Indexed">Indexed</a></TD>
    <TD>Abstract indexed persistent storage</TD>
  </TR>
  <TR>
    <TD><a href="#Persistent.Data_Bank.Reference">Reference</a></TD>
    <TD>Persistent storage references for proxy objects</TD>
  </TR>
  <TR>
    <TD colspan="2"><a href="#Persistent.Handle">Handle</a></TD>
    <TD>Handles to persistent storage objects</TD>
  </TR>
  <TR>
    <TD bgcolor="#C0C0C0" style="border-left-style: none; border-left-width: medium">&nbsp;</TD>
    <TD><a href="#Persistent.Handle.Factory">Factory</a></TD>
    <TD>Persistent storage factory</TD>
  </TR>
  <TR>
    <TD colspan="2"><a href="#Persistent.ODBC">ODBC</a></TD>
    <TD>ODBC implementation of persistent storage</TD>
  </TR>
  <tr>
    <TD colspan="6"><a href="#Stack_Storage">Stack_Storage</a></TD>
    <TD>The stack pools implemented by the type <a href="#Stack_Storage.Pool">
    Pool</a></TD>
  </tr>
	<tr>
    <TD bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="5"><a href="#Stack_Storage.Mark_And_Release">Mark_And_Release</a></TD>
    <TD>Mark and release storage pools of limited controlled objects</TD>
  </tr>
	<tr>
    <TD colspan="6"><a href="strings_edit.htm#Strings_Edit">Strings_Edit</a></TD>
    <TD>The packages dealing with strings editing as described in a separate
	<a href="strings_edit.htm">document</a></TD>
  </tr>
	<tr>
    <TD bgcolor="#C0C0C0">&nbsp;</TD>
    <TD colspan="5"><a href="#Strings_Edit.Symmetric_Serialization">
	Symmetric_Serialization</a></TD>
    <TD>Symmetric encoding and decoding strings.</TD>
  </tr>
  <TR>
    <TD colspan="6"> <a href="#Synchronization">Synchronization</a></TD>
    <TD>The parent package of the locking synchronization primitives</TD>
  </TR>
  <TR>
    <TD colspan="3" rowspan="6" bgcolor="#C0C0C0"> &nbsp;</TD>
    <TD colspan="3"> <a href="#Synchronization.Events">Events</a></TD>
    <TD>Plain events which can be signaled, reset and awaited for</TD>
  </TR>
  <TR>
    <TD colspan="3"> <a href="#Synchronization.Generic_Events_Array">
	Generic_Events_Array</a></TD>
    <TD>Arrays of events which can be signaled, reset and awaited in any 
	combination of in race condition free way</TD>
  </TR>
  <TR>
    <TD colspan="3"> <a href="#Synchronization.Generic_Mutexes_Array">
	Generic_Mutexes_Array</a></TD>
    <TD>Arrays of reentrant mutexes, deadlock-free with an enforced order of 
	locking</TD>
  </TR>
  <TR>
    <TD colspan="3"> <a href="#Synchronization.Generic_Pulse_Events">
	Generic_Pulse_Events</a></TD>
    <TD>Race condition free event distributing pulsed value to multiple tasks</TD>
  </TR>
  <TR>
    <TD colspan="3"> <a href="#Synchronization.Mutexes">Muexes</a></TD>
    <TD>Reentrant mutexes</TD>
  </TR>
  <TR>
    <TD colspan="3"> <a href="#Synchronization.Pulse_Events">Pulse_Events</a></TD>
    <TD>Race condition free pulse events</TD>
  </TR>
  <TR>
    <TD colspan="6"> <a href="tables.htm">Tables</a></TD>
    <TD>The packages related to tables management as described in a separate
	<a href="tables.htm">document</a></TD>
  </TR>
  <TR>
    <TD colspan="2" bgcolor="#C0C0C0"> &nbsp;</TD>
    <TD colspan="4"> <a href="tables.htm#Tables.UTF8_Names">UTF8_Names</a></TD>
    <TD>Tables of UTF-8 encoded case-insensitive items</TD>
  </TR>
  </TABLE>
<p>The packages related to tables management are described in <a href="tables.htm">Tables</a>.</p>
<p>For the packages dealing with strings editing see <a href="strings_edit.htm">Strings edit</a>.</p>
<p align="right">
  <A name="14.2"></A><a href="#14.1"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"></A><a href="#15"><IMG src="next.gif" alt="[Next]" width="29" height="29"></a></p>
<H3>14.2. Tests and examples</H3>
<H4>14.2.1. Tests</H4>
<p><a name="tests"></a>The subdirectory <i> test_components</i> contains various tests and examples:</p>
<TABLE border="5" cellpadding="3" cellspacing="0">
  <TR>
    <TD bgcolor="#008080"><font color="#FFFFFF"><b>Compilation unit</b></font></TD>
    <TD bgcolor="#008080" align="center"><font color="#FFFFFF"><b>Executable</b></font></TD>
    <TD bgcolor="#008080"><FONT color="#FFFFFF"><B>Provides</B></FONT></TD>
    <TD bgcolor="#008080" align="center"><font color="#FFFFFF"><b>Requires</b></font></TD>
  </TR>
  <tr>
    <TD bgcolor="#FFFF99">test_APQ_persistence</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">APQ persistent storage test</TD>
    <TD align="center" bgcolor="#FFFF99">APQ</TD>
  </tr>
  <tr>
    <TD>test_APQ_session</TD>
    <TD align="center">no</TD>
    <TD>A package used to open an APQ session. Queries for connection parameters
      using text I/O</TD>
    <TD align="center">APQ</TD>
  </tr>
  <tr>
    <TD bgcolor="#FFFF99">test_association</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for infix operation associations. Uses the file <i>test_association.txt</i>
      as the source to parse.</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_association_expression</TD>
    <TD align="center">no</TD>
    <TD>Used by <i> test_association</i></TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD bgcolor="#FFFF99">test_blackboard</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for blackboards</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD bgcolor="#FFFF99">test_dining_philosophers</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">A solution of the <a href="#Dining_philosophers">
	dining philosophers</a> problem</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_dining_philosophers_forks</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_dining_philosophers</i></TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD bgcolor="#FFFF99">test_fifo</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for FIFO</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD bgcolor="#FFFF99">test_handles</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for handles to objects</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD bgcolor="#FFFF99">test_ieee_754</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for IEEE 754 packages</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_integer_fifo</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_fifo</i></TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_integer_signaled_fifo</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_fifo</i></TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD bgcolor="#FFFF99">test_linked_lists</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for doubly-linked webs and lists</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists.controlled_elements</TD>
    <TD align="center">no</TD>
    <TD>Test for doubly-linked webs and lists, a separate body for class-wide 
	controlled items</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists.string_elements</TD>
    <TD align="center">no</TD>
    <TD>Test for doubly-linked webs and lists, a separate body for string items</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists.task_elements</TD>
    <TD align="center">no</TD>
    <TD>Test for doubly-linked webs and lists, a separate body for task items</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists_of_elements</TD>
    <TD align="center">no</TD>
    <TD>Test package for doubly-linked webs and lists. Instantiations for the 
	base type of for class-wide controlled items</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists_of_elements.strings</TD>
    <TD align="center">no</TD>
    <TD>Test package for doubly-linked webs and lists. Controlled items 
	containing strings</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists_of_strings</TD>
    <TD align="center">no</TD>
    <TD>Test package for doubly-linked webs and lists. Instantiations for string 
	items</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists_of_tasks</TD>
    <TD align="center">no</TD>
    <TD>Test package for doubly-linked webs and lists. Instantiations for task 
	items</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_linked_lists_scheduler</TD>
    <TD align="center">no</TD>
    <TD>Test package for doubly-linked list based scheduler example.</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
	<tr>
    <TD bgcolor="#FFFF99">test_linked_lists_scheduler_test</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test program for doubly-linked list based scheduler example.</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_my_string</TD>
    <TD align="center">no</TD>
    <TD>An implementation of varying strings using objects, illustrative <a href="#test_my_string.ads">example</a>.
      Used in <i>test_handles</i>.</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <tr>
    <TD>test_my_string.handle</TD>
    <TD align="center">no</TD>
    <TD>An implementation of handles to string objects, <a href="#test_my_string.handle.ads">example</a>.
      Used in <i>test_handles</i>.</TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <TR>
    <TD>test_object</TD>
    <TD align="center">no</TD>
    <TD>A test object used in <i>test_handles</i>.</TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_object.handle</TD>
    <TD align="center">no</TD>
    <TD>Handles to test objects. Used in <i>test_handles</i>.</TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_object.handle_array</TD>
    <TD align="center">no</TD>
    <TD>Arrays of test objects. Used in <i>test_handles</i>.</TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD bgcolor="#FFFF99">test_ODBC_persistence</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">ODBC persistent storage test, <a href="#test_ODBC_persistence">example</a>.</TD>
    <TD align="center" bgcolor="#FFFF99"><a href="http://gnade.sourceforge.net/">GNADE</a></TD>
  </TR>
  <TR>
    <TD>test_ODBC_session</TD>
    <TD align="center">no</TD>
    <TD>A package used to open ODBC session. Queries for connection parameters
      using text I/O</TD>
    <TD align="center"><a href="http://gnade.sourceforge.net/">GNADE</a></TD>
  </TR>
  <TR>
    <TD>test_persistent_file_storage</TD>
    <TD align="center">no</TD>
    <TD>An implementation of persistent storage using direct I/O, <a href="#test_persistent_file_storage">example</a></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD bgcolor="#FFFF99">test_persistent_storage</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Persistent storage test, <a href="#test_persistent_storage">example</a>.</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_persistent_tree</TD>
    <TD align="center">no</TD>
    <TD>An implementation of tree nodes as persistent objects, <a href="#test_persistent_tree">example</a></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_record_blackboards</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_blackboard</i></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD bgcolor="#FFFF99">test_sequencer</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for symmetric serialization</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_set</TD>
    <TD align="center">no</TD>
    <TD>A set of string objects declared in <i>test_my_string.handle</i>. Used
      in <i>test_handles</i>.</TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD bgcolor="#FFFF99">test_stack</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for <a href="#Stack_Storage.Mark_And_Release">mark and release
      stacks</a></TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_stack_item</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_stack</i></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_safe_string_blackboards</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_blackboard</i></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
	<tr>
    <TD>test_string_blackboards</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_blackboard</i></TD>
    <TD align="center">&nbsp;</TD>
  </tr>
	<tr>
    <TD>test_string_fifo</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_fifo</i></TD>
    <TD align="center">&nbsp;</TD>
  </tr>
	<tr>
    <TD>test_string_signaled_fifo</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_fifo</i></TD>
    <TD align="center">&nbsp;</TD>
  </tr>
  <TR>
    <TD bgcolor="#FFFF99">test_synchronization_events</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for synchronization primitives</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_synchronization_events_array</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_synchronization_events</i></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_synchronization_pulse_events</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_synchronization_events</i></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
  <TR>
    <TD bgcolor="#FFFF99">test_utf8_tables</TD>
    <TD align="center" bgcolor="#FFFF99">yes</TD>
    <TD bgcolor="#FFFF99">Test for tables of UTF-8 tokens</TD>
    <TD align="center" bgcolor="#FFFF99">&nbsp;</TD>
  </TR>
  <TR>
    <TD>test_utf8_tables_table</TD>
    <TD align="center">no</TD>
    <TD>Used in <i>test_utf8_tables</i></TD>
    <TD align="center">&nbsp;</TD>
  </TR>
</TABLE>
<H4>14.2.2. Building tests with GNAT</H4>
<p>Tests that do not require nether <a href="http://gnade.sourceforge.net/">GNADE</a>
nor APQ can be build using the
following command:</p>
<blockquote>
<p><tt>gnatmake -I..&nbsp;<font color="#000080">&lt;file-name&gt;</font></tt></p>
</blockquote>
<p>Note that <tt><font color="#000080">&lt;file-name&gt;</font></tt> should
refer an *.adb file. For example:</p>
<blockquote>
<p><tt>gnatmake -I..&nbsp;test_handles.adb</tt></p>
</blockquote>
<H4><span style="font-weight: 400">The files <i>components-tests.gpr</i> and <i>
components-gnade-odbc_persistence_tests.gpr</i> are GNAT GPS project files.</span></H4>
<H4>14.2.3. Building tests that use GNADE</H4>
<p>The tests depending on <a href="http://gnade.sourceforge.net/">GNADE</a> will
require an installation of <a href="http://gnade.sourceforge.net/">GNADE</a>. On
a Linux box they could be built like:</p>
<blockquote>
<p><tt>gnatmake -I..&nbsp;-I/usr/local/gnade/include test_odbc_persistence.adb</tt></p>
</blockquote>
<p>Under Windows it might be (one command line):</p>
<blockquote>
<p><tt>gnatmake -I.. -Ic:/gnade/win32-include test_odbc_persistence.adb -largs -Lc:/gnade/win32-lib
-lgnadeodbc -LC:/gnade/lib/win32 -lodbc32</tt></p>
</blockquote>
<p>Refer to <a href="http://gnade.sourceforge.net/">GNADE</a> documentation for
more information. <a href="http://gnade.sourceforge.net/">GNADE</a> is under
development, so paths might change.</p>
<H4>14.2.4. Building tests that use APQ</H4>
<p>The tests that use APQ should require no additional parameters. At least
under Windows APQ is fully integrated with GNAT compiler. If you use a source
distribution of APQ, it would probably be required to specify additional directory
paths.</p>
<H4>14.2.5. Parser examples</H4>
<p>The subdirectory <i>parser-examples</i> contains examples of using parsers.
It has the following subdirectories:</p>
<ul>
  <li><i>calculator</i> contains the sources of the simple <a href="#console_calculator">console
    calculator example</a>;</li>
  <li><i>operation-stacks</i> contains the sources of the <a href="#operation_stack_example">example
    illustrating a direct use of the operation stack</a>;</li>
  <li><i>parsing-tree</i> contains the sources of a <a href="#Parsers.Ada">full
    Ada 95 expression parser</a>;</li>
	<li><i>xpm</i> contains <a href="#Parsers.Generic_Source.XPM">
	Parsers.Generic_Source.XPM</a> and <a href="#Parsers.Multiline_Source.XPM">
	Parsers.Multiline_Source.XPM</a>.</li>
</ul>
<p>The
following command in the corresponding subdirectory can be used to build a
parser example:</p>
<blockquote>
<p><tt>gnatmake -I../..&nbsp;<font color="#000080">&lt;file-name&gt;</font></tt></p>
</blockquote>
<hr>
<p align="right">
  <a name="15"></a><a href="#14.2"><IMG src="prev.gif" alt="[Back]" width="29"
      height="29"></a><A href="#16"><IMG
      src="index.gif" alt="[TOC]" width="29" height="29"><IMG src="next.gif" alt="[Next]" width="29" height="29"></A></p>
<H2>15.
<a name="changes_log"></a>Changes log</H2>
<P>
<i>
The following versions were tested with the compilers:</i>
<ul>
  <li>
	<i>GNAT GPL 2008 (20080521)</i><blockquote>
		<p><i>Warning</i>. The tested version of GNAT compiler has a bug in 
		initialization of record types using aggregates when these types have a 
		discriminant and a controlled component. The bug manifests itself an 
		improper initialization/finalization. The subdirectory <i>
		test_components</i> contains<i> test_handles.adb</i>, which detects this 
		bug. Fortunately, situations where this might become critical are rare.</p>
	</blockquote>
	</li>
</ul>
<P>
Changes to the version 3.2:<ul>
	<li>The procedure Purge and the function Is_Preserved were added to the packages 
	Generic_FIFO and Generic_FIFO.Generic_Signaled in order to remove undesired 
	FIFO elements;</li>
	<li>References of blackboards are made comparable;</li>
	<li>Bug fix in blackboards. The bug manifested itself as ghost elements 
	appearing under certain cicrumstances.</li>
	</ul>
<P>
Changes to the version 3.1:<ul>
	<li>The package IEEE_754 and its children provide portable support of IEEE 
	754 floating-point numbers.</li>
	</ul>
<P>
Changes to the version 3.0:<ul>
	<li>Generic_FIFO.Generic_Signaled allows asynchronous cancelation of 
	waiting;</li>
	<li>Packages Generic_Indefinite_FIFO and its child 
	Generic_Indefinite_FIFO.Generic_Signaled provide lock-free FIFOs of 
	indefinite elements.</li>
	</ul>
<P>
<i>
The following versions were tested with the compilers:</i>
<ul>
  <li>
	<i>GNAT GPL 2007 (20070402);</i></li>
	<li><i>GNAT GPL 2007 (20070405-41)</i></li>
</ul>
<P>
Changes to the version 2.9:<ul>
	<li>Various locking primitives added:</li>
	<li>Plain events which can be signaled, reset and awaited for;</li>
	<li>Arrays of events which can be signaled, reset and awaited in any 
	combination of in race condition free way;</li>
	<li>Arrays of reentrant mutexes, deadlock-free with an enforced order of 
	locking;</li>
	<li>Race condition free event distributing pulsed value to multiple tasks;</li>
	<li>Reentrant mutexes;</li>
	<li>Race condition free pulse events;</li>
	<li>A solution of the problem of mutliple tasks synchronization at a check 
	point based on sets of events;</li>
	<li>A solution of the dining philosophers problem based on sets of mutexes.</li>
	</ul>
<P>
Changes to the version 2.8:<ul>
	<li>Persistent and Persistent.Handle packages use UTF-8 mapping function 
	defined in Strings_Edit.UTF8.Maps;</li>
	<li>Lock-free shared structures are added:</li>
	<li>Generic_FIFO implements a lock-free peer-to-peer FIFO;</li>
	<li>Generic_FIFO.Generic_Signaled implements an almost lock-free 
	peer-to-peer FIFO, which locks only if blocking;</li>
	<li>Generic_Blackboard implements lock-free one to many blackboards;</li>
	<li>Generic_Blackboard.Generic_Task_Safe implements blocking many to 
	lock-free many blackboard.</li>
	</ul>
<P>
Changes to the version 2.7:<ul>
	<li>Tables of UTF-8 encoded case-insensitive strings;</li>
	<li>Is_Named was added to Persistent and Persistent.Handle packages.</li>
	</ul>
<P>
Changes to the version 2.5:<ul>
	<li>Function Is_Empty was added to doubly-linked lists;</li>
	<li>Functions Erase and Take were added for doubly-linked webs and lists:</li>
	<li>Persistent storage packages interface was changed from Wide_String 
	(UCS-2) to String (UTF-8) Unicode support;</li>
	<li>Persistent storage now supports hierarchical names of objects;</li>
	<li>Get_Class abstract operation was added to the persistent storage 
	interface;</li>
	<li>The package Generic_Random_Sequence was added to provide random 
	sequences of non-repeating numbers;</li>
	<li>The package Strings_Edit.Symetric_Serialization provides symmetric 
	encryption and encoding of short plain strings, which can be used for 
	storing user credentials.</li>
	</ul>
<P>
<i>
The following versions were tested with the compilers:</i>
<ul>
  <li>
	<i>GNAT 4.1.1 20070105;</i></li>
	<li><i>GNAT GPL 2007 (20070405-41)</i></li>
</ul>
<P>
Changes to the version 2.4:<ul>
	<li>Functions Is_In were added for doubly-linked webs and lists;</li>
	<li>For GNAT users GPS project files were added.</li>
	</ul>
<P>
<i>
The following versions were tested with the compilers:</i>
<ul>
  <li>
<i>
GNAT 2006, GCC 4.1.1 (20060525);</i></li>
  <li><i>GNAT 3.15p (doubly-linked webs may crash the compiler).</i></li>
</ul>
<P>
Changes to the version 2.3:<ul>
	<li>Doubly-linked webs and lists of items with referential semantics;</li>
	<li>Get_Line procedure was added to the abstract source interface to improve 
	parser performance in the cases when compiler optimization is poor;</li>
	<li>Slicing and concatenation operations were added to the package 
	Object.Handle.Generic_Bounded_Array;</li>
	<li>The code was slightly re-arranged to circumvent bugs of
GNAT 2006, GCC 4.1.1 (20060525).</li>
	</ul>
<P>
<i>
The following versions were tested with the compilers:</i>
<ul>
  <li>
<i>
GNAT 2005, GCC 4.0.2 (20051125);</i></li>
  <li><i>GNAT 3.15p.</i></li>
</ul>
<P>
Changes to the version 2.2:<ul>
	<li>Generic package Object.Handle.Generic_Handle_Set is provided for 
	sets of objects accessed through handles;</li>
	<li>Insert procedure was added to Generic_Set with a parameter to determine 
	whether the item has been added to the set:</li>
	<li>Bug fix in Stack_Storage.</li>
	<li>Bug fix in the implementation of &quot;and&quot; in Generic_Set and 
	Object.Handle.Generic_Set;</li>
	<li>The package Parsers.Multiline_Sources.Standard_Input was added to 
	provide interface to the standard input file;</li>
	<li>Packages for dealing with XPM image format were added.</li>
	</ul>
<P>
Changes to the version 2.1:
<ul>
  <li>Conformity with Ada 2005;</li>
	<li>Procedure Set was added to the package Object.Handle;</li>
	<li>Procedure Fetch was added to Generic_Unbounded_Array.</li>
</ul>
<P>
<i>The following versions were tested with the GNAT 3.15p compiler:</i>
<P>
Changes to the version 2.0:<ul>
  <li>Parsers.Multiline_Source.Get_Line raises End_Error at the source end
    (instead of Constraint_Error);</li>
  <li>Behavior of arguments sublists separators was clarified.</li>
  </ul>
<P>
Changes to the version 1.10:<ul>
  <li>Get_Token procedure was added to provide matching sources against a table
    of tokens;</li>
  <li>Keywords package was added to generate keyword matching parser from an
    enumeration type, which literals are the keywords to match.</li>
  </ul>
<P>
Changes to the version 1.9:<ul>
  <li>Support for implied infix operators as in 2<i>x</i> + 3<i>y</i>;</li>
  <li>Get_Text procedure is added to help creation of simple recursively
    descending parsers;</li>
  <li>Ada expression parser bug fix (in numeric literals parsing).</li>
  </ul>
<P>
Changes to the version 1.8:<ul>
  <li>Insert for Generic_Set;</li>
  <li>Minor bug fixing in the Ada expression parser example;</li>
  <li>Changes in the documentation.</li>
  </ul>
<P>
Changes to the version 1.7:<ul>
  <li>Abstract persistent storage interface (package Persistent);</li>
  <li>Handles to persistent storage objects (package Persistent.Handle);</li>
  <li>Persistent storage backed by an ODBC data base;</li>
  <li>Persistent storage backed by an APQ data base;</li>
  <li>Interface for developing new persistent storage objects.</li>
  </ul>
<P>
Changes to the version 1.6:<ul>
  <li>Object persistency implemented by the packages Object.Archived.*.</li>
  </ul>
<P>
Changes to the version 1.5:<ul>
  <li>The child package Object.Handle.Generic_Set provides sets of objects;</li>
  <li>Erase operation was added to Generic_Unbounded_Array, 
  Generic_Unbounded_Ptr_Array and Object.Handle.Generic_Unbounded_Array;</li>
  <li>Bug fix in Generic_Set. Set-theoretic operations work correctly when both 
  arguments are the same set.</li>
  </ul>
<P>
Changes to the version 1.4:<ul>
  <li>Licensing wording was corrected to comply with GMGPL</li>
  </ul>
<P>
Changes to the version 1.3:<ul>
<li>The package Generic_Segmented_Stack provides a specialization of the generic
stack package;</li>
<li>Random access to generic stacks (Get / Put);</li>
<li>The packages rooted in Parsers provide infix expressions syntax analyzers;</li>
<li>Strings edit facilities;</li>
<li>Tables management package.</li>
</ul>
<P>
Changes to the version 1.2:<ul>
<li>The package Generic_Map provides maps (associative arrays);</li>
</ul>
<P>
Changes to the version 1.1:<ul>
<li>The package Generic_Stack provides a stack implemented on a dynamic array 
type;</li>
<li>All packages were reviewed to allow use of pool-specific access types where 
possible. So some changes in the specifications of the package Object.Handle and 
Object were made;</li>
<li>The packages Stack_Storage and its child Mark_And_Release provide stack 
pools. </li>
</ul>
<P>
Changes to the version 1.0:
<ul>
  <li>Child generic packages of Object.Handle were added to deal with arrays of 
  objects;</li>
  <li>Object.Handle was made a public descendant of Ada.Finalization.Controlled;</li>
  <li>Generic_Set has now a new procedure Replace;</li>
  <li>Removed bug in Generic_Set.Erase (wrong dealing with Use_Count).</li>
</ul>
  <HR>
<H2 align="right">
  <a name="16"></a><a href="#15"><IMG src="prev.gif" alt="[Back]" width="29" height="29"></a><a href="#16"><IMG src="index.gif" alt="[TOC]" width="29" height="29"></a></H2>
<H2>16. Table of Contents</H2>
<table border="0" cellpadding="0" cellspacing="20">
	<tr>
		<td valign="top">
<A href="#1">1. Objects and handles (smart pointers)</A><BR>
&nbsp;&nbsp;&nbsp; <A href="#1.1">1.1. Objects</A><BR>
&nbsp;&nbsp;&nbsp; <A href="#1.2">1.2. Handles to objects</A><BR>
&nbsp;&nbsp;&nbsp; <A href="#1.3">1.3. An example of use</a><br>
&nbsp;&nbsp;&nbsp; <A href="#1.4">1.4. Bounded arrays of objects</a><br>
&nbsp;&nbsp;&nbsp; <A href="#1.5">1.5. Unbounded arrays of objects</a><br>
&nbsp;&nbsp;&nbsp; <A href="#1.6">1.6. Sets of objects</a><br>
&nbsp;&nbsp;&nbsp; <A href="#1.7">1.7. Universal sets of objects</a><br>
<A href="#2">2. Persistency</A><BR>
&nbsp;&nbsp;&nbsp; <A href="#2.1">2.1. Persistent objects</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.2">2.2. Handles to persistent objects</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.3">2.3. Persistent directories</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.4">2.4. Persistent storage implementation example</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.5">2.5. Abstract persistent storage</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.6">2.6. Handles to persistent storage</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.7">2.7. Persistent storage factory</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.8">2.8. Persistent storage implementations</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.9">2.9. Implementation of a new persistent storage</a><br>
&nbsp;&nbsp;&nbsp; <A href="#2.10">2.10. Visual browsing of a persistent storage</a><br>
<A href="#3">3. Sets and maps</A><BR>
&nbsp;&nbsp;&nbsp; <A href="#3.1">3.1. Sets</A><BR>
&nbsp;&nbsp;&nbsp; <A href="#3.2">3.2. Maps</A><BR>
<A href="#4">4. Unbounded arrays</A><br>
<A href="#5">5. Unbounded arrays of pointers</A><BR>
<A href="#6">6. Stacks</a><br>
&nbsp;&nbsp;&nbsp; <A href="#6.1">6.1. Stacks based on abstract arrays</A><BR>
&nbsp;&nbsp;&nbsp; <A href="#6.2">6.2. Segmented stacks</A><BR>
<A href="#7">7. Pools</a><br>
&nbsp;&nbsp;&nbsp; <a href="#7.1">7.1. Stack pool</a><BR>
&nbsp;&nbsp;&nbsp; <a href="#7.2">7.2. Mark and release pool for controlled objects</a><br>
<a href="#8">8. Doubly-linked networks</a><br>
&nbsp;&nbsp;&nbsp; <a href="#8.1">8.1. Doubly-linked lists of networks (specialization)</a><BR>
&nbsp;&nbsp;&nbsp; <a href="#8.2">8.2. Doubly-linked lists</a><br>
&nbsp;</td>
<td valign="top"><a href="#9">9. Lock-free structures</a><br>
&nbsp;&nbsp;&nbsp; <a href="#9.1">9.1. FIFO</a><BR>
&nbsp;&nbsp;&nbsp; <a href="#9.2">9.2. Blackboard</a><br>
<a href="#10">10. Locking synchronization primitives</a><br>
&nbsp;&nbsp;&nbsp; <a href="#10.1">10.1. Notes on programming with protected objects</a><BR>
&nbsp;&nbsp;&nbsp; <a href="#10.2">10.2. Events</a><BR>
&nbsp;&nbsp;&nbsp; <a href="#10.3">10.3. Mutexes</a><br>
<a href="#11">11. Parsers</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.1">11.1. Example first, a small calculator</a><BR>
&nbsp;&nbsp;&nbsp; <a href="#11.2">11.2. Basic considerations</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.3">11.3. The base package</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.4">11.4. Sources</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.5">11.5. Tokens</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.6">11.6. Lexers</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.7">11.7. Operations</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.8">11.8. Arguments</a><br>
&nbsp;&nbsp;&nbsp; <a href="#11.9">11.9. Parsing tree example. Ada 95 expression parser</a><br>
<a href="#12">12. Cryptography</a><br>
&nbsp;&nbsp;&nbsp; <a href="#12.1">12.1. Sequences of non-repeating pseudo random numbers</a><br>
&nbsp;&nbsp;&nbsp; <a href="#12.2">12.2. Symmetric serialization</a><br>
<a href="#13">13. Numerics</a><br>
&nbsp;&nbsp;&nbsp; <a href="#13.1">13.1. IEEE 754 representations</a><br>
<a href="#14">14. Packages</a><br>
&nbsp;&nbsp;&nbsp; <a href="#14.1">14.1. Source packages</a><br>
&nbsp;&nbsp;&nbsp; <a href="#14.2">14.2. Tests and examples</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="tables.htm">Tables</a> (a separate document)<br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="strings_edit.htm">Strings edit</a> (a separate document)<br>
<a href="#15">15. Changes log</a><br>
<a href="#16">16. Table of contents</a></td>
	</tr>
</table>
<p>&nbsp;</p>
<P>
&nbsp;
</BODY>
</HTML>