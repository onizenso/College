Problems ch3-3 3-4 

#1. Consider this Grammar

    <assign> -> <id> = <expr>
    <expr> -> <expr> + <term> | <term>
    <term> -> <term> * <factor>  | <factor>
    <factor> -> ( <expr> ) | <id>
    <id> -> A | B | C

    Is + right or left associative?

    How would you change the associativity of +?

#2. Consider the folowing two grammars, each of which generates strings of
    correctly balanced parentheses and brackets. Determine if either or both
    is ambiguous. The letter "e" represents the Greek letter epsilon; i.e., 
    the empty string.

 (a) <string> ::= <string> <string> | (<string>) | [<string>] | e
 (b) <string> ::= ( <string> ) <string> | [ <string> ]  <string> | e


#3. Consider the following specification of expressions:

    <expr> ::= <element> | <expr> <weak op> <expr>
    <element> ::= <numeral> | <variable>
    <weak op> ::= + | -

    Demonstrate its ambiguity by displaying two derivation trees for the
    expression a - b - c.


#4. Modify the following grammar to add a unary minus operator that has
    higher precedence than either + or *.

    <assign> -> <id> = <expr>
    <id> -> A | B | C
    <expr> -> <expr> + <term> | <term>
    <term> -> <term> * <factor>  | <factor>
    <factor> -> ( <expr> ) | <id>

#5. Consider the following grammar:

<expr> ::- <term> | <expr> + <term>
<term ::= <element> | <term> * <element>
<element> ::= <num> | <var>

Draw the parse tree for this valid expression:

    5 * Z + 30 + 7

#6. Consider the grammar

  S -> AB | AD
  A -> Aa | b
  B -> Bb | a
  D -> cDc | d 

  Are these valid strings in the language generated by the grammar?

  ba        ?

  bbbbab    ?

  aaaacccc  ?

  bcdcc     ?

  baaab     ?

  baccdcc   ?

#8. Consider this grammar:

     <assign> -> <id> = <expr>
     <id> -> A | B | C
     <expr> -> <id> + <expr> | <id> * <expr> | ( <expr> ) | <id>

   Show a parse tree and a leftmost derivation for the following statement:

     A = A * ( B + ( C * A))

1. <assign> => <id> = <expr>
2.          => A = <expr>
3.          => A = <id> * <expr>
4.          => A = A  * <expr>
5.          => A = A  * (<expr>)
6.          => A = A  * (<id> + <expr>)
7.          => A = A  * (B + <expr>)
8.          => A = A  * (B + (<expr>))
9.          => A = A  * (B + (<id> * <expr>))
10.         => A = A  * (B + ( C * <expr>))
11.         => A = A  * (B + ( C * <id>))
12.         => A = A  * (B + ( C * A))

   Parse tree.

             <assign>
                     /    |    \
                   <id>   =     <expr>
                    |           /  |  \
                    A         <id> *  <expr>
                               |        |
                               A     ( <expr> )
                                       /  |  \
                                     <id> +  <expr>
                                      |        |
                                      B    ( <expr> )
                                             /  |  \
                                          <id>  *  <expr>
                                            |        |
                                            C       <id>
                                                     |
                                                     A

 To prove that a grammar is ambiguous, provide a sentence in the grammar that
  has two different parse trees. (You can't show this with derivations.)

   <S> -> <A>
   <A> -> <A> + <A>  | <id>
   <id> -> a | b | c

  Sentence:   a + b + c

  Tree 1.             <S>
                       |
                      <A>
                    /  |  \
                  <A>  +  <A>
                   |     / | \
                 <id>  <A> + <A>
                   |    |     |
                   a   <id>  <id>
                        |     |
                        b     c


  Tree 2.            <S>
                      |
                     <A>
                    / |  \
                  <A> +   <A>
                 / | \     |
               <A> + <A>  <id>
                |     |    |
               <id>  <id>  c
                |     |
                a     b


Describe the language defined by the following grammar:

  <S> -> <A> a <B> b
  <A> -> <A> b | b
  <B> -> a <B> | a



Start by finding the behavior of <A> and <B> :

 <A> ->  b
         bb
         bbb ...

 <A> is 1 or more "b"s.

 <B> -> a
        aa
        aaa ...
        
  <B> is 1 or more "a"s

  Thus,

  <A>a<B>b defines the language of all strings of 1 or more "b"s followed 
  by 2 or more "a"s ending with a "b". 

